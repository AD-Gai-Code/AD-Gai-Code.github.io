<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Spring5框架学习系列（三）</title>
    <url>/2021/09/04/Spring5%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0(%E4%B8%89)/</url>
    <content><![CDATA[<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="Ⅰ-事务操作-事务的概念"><a href="#Ⅰ-事务操作-事务的概念" class="headerlink" title="Ⅰ.事务操作(事务的概念)"></a>Ⅰ.事务操作(事务的概念)</h2><h3 id="1、什么是事务"><a href="#1、什么是事务" class="headerlink" title="1、什么是事务"></a>1、什么是事务</h3><p>（1）事务是数据库操作最基本单元，逻辑上的一组操作，要么都成功，如果有一个失败所有操作都失败。</p>
<p>（2）典型场景：银行转账。</p>
<span id="more"></span>

<ul>
<li><p>lucy 转账 100 元 给 mary </p>
</li>
<li><p>lucy 少 100，mary 多 100</p>
</li>
</ul>
<h3 id="2、事务四个特性（ACID）"><a href="#2、事务四个特性（ACID）" class="headerlink" title="2、事务四个特性（ACID）"></a>2、事务四个特性（ACID）</h3><p>（1）原子性：整体 【原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚】</p>
<p>（2）一致性：数据 【一个事务执行之前和执行之后都必须处于一致性状态】</p>
<blockquote>
<p>拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。</p>
</blockquote>
<p>（3）隔离性: 隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。</p>
<blockquote>
<p>并发 【对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。】 </p>
</blockquote>
<p>（4）持久性: 结果 【持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作】</p>
<h2 id="Ⅱ-事务操作（搭建事务操作环境）"><a href="#Ⅱ-事务操作（搭建事务操作环境）" class="headerlink" title="Ⅱ.事务操作（搭建事务操作环境）"></a>Ⅱ.事务操作（搭建事务操作环境）</h2><p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/%E5%9B%BE6.png" alt="图6"></p>
<p>WEB层（视图层）、Service（业务逻辑层）、Dao（数据访问层）是Javaee操作中的三层结构。</p>
<h3 id="1、创建数据库表，添加记录"><a href="#1、创建数据库表，添加记录" class="headerlink" title="1、创建数据库表，添加记录"></a>1、创建数据库表，添加记录</h3><p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/image-20210409163453184.png" alt="image-20210409163453184"></p>
<h3 id="2、创建-service，搭建-dao，完成对象创建和注入关系"><a href="#2、创建-service，搭建-dao，完成对象创建和注入关系" class="headerlink" title="2、创建 service，搭建 dao，完成对象创建和注入关系"></a>2、创建 service，搭建 dao，完成对象创建和注入关系</h3><p>（1）service 注入 dao，在 dao 注入 JdbcTemplate，在 JdbcTemplate 注入 DataSource</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"> 	<span class="comment">//注入 dao</span></span><br><span class="line"> 	<span class="meta">@Autowired</span></span><br><span class="line"> 	<span class="keyword">private</span> UserDao userDao;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"> 	<span class="meta">@Autowired</span> <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3、在-dao-创建两个方法：多钱和少钱的方法，在-service-创建方法（转账的方法）"><a href="#3、在-dao-创建两个方法：多钱和少钱的方法，在-service-创建方法（转账的方法）" class="headerlink" title="3、在 dao 创建两个方法：多钱和少钱的方法，在 service 创建方法（转账的方法）"></a>3、在 dao 创建两个方法：多钱和少钱的方法，在 service 创建方法（转账的方法）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"> 	<span class="meta">@Autowired</span></span><br><span class="line"> 	<span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"> 	<span class="comment">//lucy 转账 100 给 mary</span></span><br><span class="line"> 	<span class="comment">//少钱</span></span><br><span class="line"> 	<span class="meta">@Override</span></span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reduceMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 	String sql = <span class="string">&quot;update t_account set money=money-? where username=?&quot;</span>;</span><br><span class="line"> 	jdbcTemplate.update(sql,<span class="number">100</span>,<span class="string">&quot;lucy&quot;</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="comment">//多钱</span></span><br><span class="line"> 	<span class="meta">@Override</span></span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 	String sql = <span class="string">&quot;update t_account set money=money+? where username=?&quot;</span>;</span><br><span class="line"> 	jdbcTemplate.update(sql,<span class="number">100</span>,<span class="string">&quot;mary&quot;</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"> 	<span class="comment">//注入 dao</span></span><br><span class="line"> 	<span class="meta">@Autowired</span></span><br><span class="line"> 	<span class="keyword">private</span> UserDao userDao;</span><br><span class="line"> 	<span class="comment">//转账的方法</span></span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accountMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 	<span class="comment">//lucy 少 100</span></span><br><span class="line"> 	userDao.reduceMoney();</span><br><span class="line"> 	<span class="comment">//mary 多 100</span></span><br><span class="line"> 	userDao.addMoney();</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、上面代码，如果正常执行没有问题的，但是如果代码执行过程中出现异常就会有问题"><a href="#4、上面代码，如果正常执行没有问题的，但是如果代码执行过程中出现异常就会有问题" class="headerlink" title="4、上面代码，如果正常执行没有问题的，但是如果代码执行过程中出现异常就会有问题"></a>4、上面代码，如果正常执行没有问题的，但是如果代码执行过程中出现异常就会有问题</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//转账的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accountMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//lucy少100</span></span><br><span class="line">            userDao.reduceMoney();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//模拟异常</span></span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">10</span>/<span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">//mary多100</span></span><br><span class="line">            userDao.addMoney();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，如果在少钱方法执行以后发生了异常，就会导致少钱方法得到了执行而多钱方法没有得到执行的现象出现，即总的钱少了 100，从而不满足事务的一致性原则。</p>
<h3 id="5-如何解决上面的问题？"><a href="#5-如何解决上面的问题？" class="headerlink" title="5. 如何解决上面的问题？"></a>5. 如何解决上面的问题？</h3><p>使用事务来解决，也就是一个失败的话，所有的都失败。</p>
<h4 id="事务操作过程"><a href="#事务操作过程" class="headerlink" title="事务操作过程"></a>事务操作过程</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//转账的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accountMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//        try &#123;</span></span><br><span class="line">            <span class="comment">//第一步 开启事务</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//第二步 进行业务操作</span></span><br><span class="line">            <span class="comment">//lucy少100</span></span><br><span class="line">            userDao.reduceMoney();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//模拟异常</span></span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">10</span>/<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//mary多100</span></span><br><span class="line">            userDao.addMoney();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//第三步 没有发生异常，提交事务</span></span><br><span class="line"><span class="comment">//        &#125;catch(Exception e) &#123;</span></span><br><span class="line">            <span class="comment">//第四步 出现异常，事务回滚（回滚就是回到操作前的状态）</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Ⅲ-事务操作（Spring-事务管理介绍）"><a href="#Ⅲ-事务操作（Spring-事务管理介绍）" class="headerlink" title="Ⅲ.事务操作（Spring 事务管理介绍）"></a>Ⅲ.事务操作（Spring 事务管理介绍）</h2><h3 id="1、事务添加到-JavaEE-三层结构里面-Service-层（业务逻辑层）"><a href="#1、事务添加到-JavaEE-三层结构里面-Service-层（业务逻辑层）" class="headerlink" title="1、事务添加到 JavaEE 三层结构里面 Service 层（业务逻辑层）"></a>1、事务添加到 JavaEE 三层结构里面 Service 层（业务逻辑层）</h3><p>理论上加到哪一层都可以，但是建议加到Service层中去，因为Service层会调用Dao层里面的多个方法。</p>
<h3 id="2、在-Spring-进行事务管理操作"><a href="#2、在-Spring-进行事务管理操作" class="headerlink" title="2、在 Spring 进行事务管理操作"></a>2、在 Spring 进行事务管理操作</h3><p>有两种方式：编程式事务管理和声明式事务管理（使用）</p>
<h3 id="3、声明式事务管理"><a href="#3、声明式事务管理" class="headerlink" title="3、声明式事务管理"></a>3、声明式事务管理</h3><p>（1）基于注解方式（使用） </p>
<p>（2）基于 xml 配置文件方式</p>
<h3 id="4、在-Spring-进行声明式事务管理，底层使用-AOP-原理"><a href="#4、在-Spring-进行声明式事务管理，底层使用-AOP-原理" class="headerlink" title="4、在 Spring 进行声明式事务管理，底层使用 AOP 原理"></a>4、在 Spring 进行声明式事务管理，底层使用 AOP 原理</h3><p>即在不改变源代码的情况下可以增强类中的方法。</p>
<h3 id="5、Spring-事务管理-API"><a href="#5、Spring-事务管理-API" class="headerlink" title="5、Spring 事务管理 API"></a>5、Spring 事务管理 API</h3><p>提供一个接口，代表事务管理器（Spring中做事务管理都是用接口做到的），这个接口针对不同的框架提供不同的实现类。</p>
<p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/image-20210409171918791.png" alt="image-20210409171918791"></p>
<h2 id="Ⅳ-事务操作（注解声明式事务管理）"><a href="#Ⅳ-事务操作（注解声明式事务管理）" class="headerlink" title="Ⅳ.事务操作（注解声明式事务管理）"></a>Ⅳ.事务操作（注解声明式事务管理）</h2><h3 id="1、在-spring-配置文件配置事务管理器"><a href="#1、在-spring-配置文件配置事务管理器" class="headerlink" title="1、在 spring 配置文件配置事务管理器"></a>1、在 spring 配置文件配置事务管理器</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--创建事务管理器,就是创建实现类的对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--注入数据源--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2、在-spring-配置文件，开启事务注解"><a href="#2、在-spring-配置文件，开启事务注解" class="headerlink" title="2、在 spring 配置文件，开启事务注解"></a>2、在 spring 配置文件，开启事务注解</h3><p>（1）在 spring 配置文件引入名称空间 tx</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span> </span></span><br><span class="line"><span class="tag"> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> </span></span><br><span class="line"><span class="tag"> <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span> </span></span><br><span class="line"><span class="tag"> <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span> </span></span><br><span class="line"><span class="tag"> <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span> </span></span><br><span class="line"><span class="tag"> <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/beans/spring-beans.xsd </span></span></span><br><span class="line"><span class="string"><span class="tag"> http://www.springframework.org/schema/context </span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/context/spring-context.xsd </span></span></span><br><span class="line"><span class="string"><span class="tag"> http://www.springframework.org/schema/aop </span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/aop/spring-aop.xsd  http://www.springframework.org/schema/tx </span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/tx/spring-tx.xsd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（2）开启事务注解</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--开启事务注解--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transactionManager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">tx:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3、在-service-类上面（或者-service-类里面方法上面）添加事务注解"><a href="#3、在-service-类上面（或者-service-类里面方法上面）添加事务注解" class="headerlink" title="3、在 service 类上面（或者 service 类里面方法上面）添加事务注解"></a>3、在 service 类上面（或者 service 类里面方法上面）添加事务注解</h3><p>（1）@Transactional，这个注解添加到类上面，也可以添加方法上面 </p>
<p>（2）如果把这个注解添加类上面，这个类里面所有的方法都添加事务 </p>
<p>（3）如果把这个注解添加方法上面，那么只是为这个方法添加事务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br></pre></td></tr></table></figure>

<h2 id="Ⅴ-事务操作（声明式事务管理参数配置）"><a href="#Ⅴ-事务操作（声明式事务管理参数配置）" class="headerlink" title="Ⅴ.事务操作（声明式事务管理参数配置）"></a>Ⅴ.事务操作（声明式事务管理参数配置）</h2><h3 id="1、在-service-类上面添加注解-Transactional，在这个注解里面可以配置事务相关参数"><a href="#1、在-service-类上面添加注解-Transactional，在这个注解里面可以配置事务相关参数" class="headerlink" title="1、在 service 类上面添加注解@Transactional，在这个注解里面可以配置事务相关参数"></a>1、在 service 类上面添加注解@Transactional，在这个注解里面可以配置事务相关参数</h3><p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/image-20210409174536216.png" alt="image-20210409174536216"></p>
<h3 id="2、propagation：事务传播行为"><a href="#2、propagation：事务传播行为" class="headerlink" title="2、propagation：事务传播行为"></a>2、propagation：事务传播行为</h3><p>（1）多事务方法直接进行调用，这个过程中事务 是如何进行管理的</p>
<p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/%E5%9B%BE7.png" alt="图7"></p>
<p>事务的传播行为可以由传播属性决定。Spring指定了7种类传播行为。</p>
<p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/image-20210409214546605.png" alt="image-20210409214546605"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br></pre></td></tr></table></figure>



<h3 id="3、isolation：事务隔离级别"><a href="#3、isolation：事务隔离级别" class="headerlink" title="3、isolation：事务隔离级别"></a>3、isolation：事务隔离级别</h3><p>隔离级别是为了解决事务中的隔离性，事务的隔离性指的是在并发操作中产生的一些问题。</p>
<p> 事务有特性称为隔离性，多事务操作之间不会产生影响。但是不考虑隔离性会产生很多问题 </p>
<ul>
<li><p> 有三个读问题：脏读、不可重复读、虚（幻）读</p>
</li>
<li><p> 脏读：一个未提交事务读取到另一个未提交事务的数据</p>
</li>
<li><p> 不可重复读：一个未提交事务读取到另一提交事务修改数据</p>
</li>
</ul>
<p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/%E5%9B%BE8.png" alt="图8"></p>
<p>（5）虚读：一个未提交事务读取到另一提交事务添加数据 </p>
<p>（6）解决：通过设置事务隔离级别，解决读问题</p>
<p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB.bmp" alt="事务隔离级别"></p>
<h3 id="4、timeout：超时时间"><a href="#4、timeout：超时时间" class="headerlink" title="4、timeout：超时时间"></a>4、timeout：超时时间</h3><p>（1）事务需要在一定时间内进行提交，如果不提交进行回滚 </p>
<p>（2）默认值是 -1 ，设置时间以秒单位进行计算</p>
<h3 id="5、readOnly：是否只读"><a href="#5、readOnly：是否只读" class="headerlink" title="5、readOnly：是否只读"></a>5、readOnly：是否只读</h3><p>（1）读：查询操作，写：添加修改删除操作 </p>
<p>（2）readOnly 默认值 false，表示可以查询，可以添加修改删除操作</p>
<p>（3）设置 readOnly 值是 true，设置成 true 之后，只能查询</p>
<h3 id="6、rollbackFor：回滚"><a href="#6、rollbackFor：回滚" class="headerlink" title="6、rollbackFor：回滚"></a>6、rollbackFor：回滚</h3><p>设置出现哪些异常进行事务回滚</p>
<h3 id="7、noRollbackFor：不回滚"><a href="#7、noRollbackFor：不回滚" class="headerlink" title="7、noRollbackFor：不回滚"></a>7、noRollbackFor：不回滚</h3><p>设置出现哪些异常不进行事务回滚</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional(readOnly = false,timeout = -1,propagation = Propagation.REQUIRED,isolation = Isolation.REPEATABLE_READ)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br></pre></td></tr></table></figure>

<h2 id="Ⅵ-事务操作（XML-声明式事务管理）"><a href="#Ⅵ-事务操作（XML-声明式事务管理）" class="headerlink" title="Ⅵ.事务操作（XML 声明式事务管理）"></a>Ⅵ.事务操作（XML 声明式事务管理）</h2><h3 id="1、在-spring-配置文件中进行配置"><a href="#1、在-spring-配置文件中进行配置" class="headerlink" title="1、在 spring 配置文件中进行配置"></a>1、在 spring 配置文件中进行配置</h3><p>第一步 配置事务管理器 </p>
<p>第二步 配置通知(增强的部分就叫做通知，这里要增强的部分就是事务)</p>
<p>第三步 配置切入点（即将事务加到哪个类的哪个方法上）和切面（就是把事务加到方法的过程）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 组件扫描 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.atguigu&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 数据库连接池 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql:///user_db&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- JdbcTemplate对象 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jdbcTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--注入dataSource--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--1 创建事务管理器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--注入数据源--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--2 配置通知--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txadvice&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置事务参数--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--指定哪种规则的方法上面添加事务--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;accountMoney&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--&lt;tx:method name=&quot;account*&quot;/&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--3 配置切入点和切面--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置切入点--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pt&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.atguigu.spring5.service.UserService.*(..))&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置切面--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txadvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Ⅶ-事务操作（完全注解声明式事务管理）"><a href="#Ⅶ-事务操作（完全注解声明式事务管理）" class="headerlink" title="Ⅶ.事务操作（完全注解声明式事务管理）"></a>Ⅶ.事务操作（完全注解声明式事务管理）</h2><h3 id="1、创建配置类，使用配置类替代-xml-配置文件"><a href="#1、创建配置类，使用配置类替代-xml-配置文件" class="headerlink" title="1、创建配置类，使用配置类替代 xml 配置文件"></a>1、创建配置类，使用配置类替代 xml 配置文件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">//配置类</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.atguigu&quot;)</span> <span class="comment">//组件扫描</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span> <span class="comment">//开启事务</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TxConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建数据库连接池</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DruidDataSource <span class="title">getDruidDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DruidDataSource dataSource = <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">        dataSource.setDriverClassName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        dataSource.setUrl(<span class="string">&quot;jdbc:mysql:///user_db&quot;</span>);</span><br><span class="line">        dataSource.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        dataSource.setPassword(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建JdbcTemplate对象</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JdbcTemplate <span class="title">getJdbcTemplate</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//到ioc容器中根据类型找到dataSource</span></span><br><span class="line">        JdbcTemplate jdbcTemplate = <span class="keyword">new</span> JdbcTemplate();</span><br><span class="line">        <span class="comment">//注入dataSource</span></span><br><span class="line">        jdbcTemplate.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建事务管理器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSourceTransactionManager <span class="title">getDataSourceTransactionManager</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">        DataSourceTransactionManager transactionManager = <span class="keyword">new</span> DataSourceTransactionManager();</span><br><span class="line">        transactionManager.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> transactionManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring5框架学习系列（二）</title>
    <url>/2021/09/04/Spring5%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0(%E4%BA%8C)/</url>
    <content><![CDATA[<h1 id="AOP-面向切面编程"><a href="#AOP-面向切面编程" class="headerlink" title="AOP(面向切面编程)"></a>AOP(面向切面编程)</h1><h2 id="Ⅰ-什么是-AOP"><a href="#Ⅰ-什么是-AOP" class="headerlink" title="Ⅰ.什么是 AOP"></a>Ⅰ.什么是 AOP</h2><p>（1）面向切面编程（方面），利用 AOP 可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p>
<p> （2）通俗描述：不通过修改源代码方式，在主干功能里面添加新功能 </p>
<p> （3）使用登录例子说明 AOP</p>
<span id="more"></span>

<p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/%E5%9B%BE3.png" alt="图3"></p>
<h2 id="Ⅱ-AOP底层原理"><a href="#Ⅱ-AOP底层原理" class="headerlink" title="Ⅱ.AOP底层原理"></a>Ⅱ.AOP底层原理</h2><h3 id="1、AOP-底层使用动态代理"><a href="#1、AOP-底层使用动态代理" class="headerlink" title="1、AOP 底层使用动态代理"></a>1、AOP 底层使用动态代理</h3><h4 id="1-有两种情况动态代理"><a href="#1-有两种情况动态代理" class="headerlink" title="(1)有两种情况动态代理"></a>(1)有两种情况动态代理</h4><p>第一种 有接口情况，使用 JDK 动态代理</p>
<ul>
<li>创建接口实现类代理对象，增强类的方法</li>
</ul>
<p>第二种 没有接口情况，使用 CGLIB 动态代理</p>
<ul>
<li>创建子类的代理对象，增强类的方法</li>
</ul>
<p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/%E5%9B%BE4.png"></p>
<h2 id="Ⅲ-AOP-JDK动态代理"><a href="#Ⅲ-AOP-JDK动态代理" class="headerlink" title="Ⅲ.AOP(JDK动态代理)"></a>Ⅲ.AOP(JDK动态代理)</h2><h3 id="1、使用-JDK-动态代理，使用-Proxy-类里面的方法创建代理对象"><a href="#1、使用-JDK-动态代理，使用-Proxy-类里面的方法创建代理对象" class="headerlink" title="1、使用 JDK 动态代理，使用 Proxy 类里面的方法创建代理对象"></a>1、使用 JDK 动态代理，使用 Proxy 类里面的方法创建代理对象</h3><p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/image-20210406205345738.png" alt="image-20210406205345738"></p>
<p>（1）调用 newProxyInstance 方法</p>
<p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/image-20210406205503654.png" alt="image-20210406205503654"></p>
<p>该方法有三个参数： </p>
<p>第一参数，类加载器 </p>
<p>第二参数，增强方法所在的类，这个类实现的接口，支持多个接口 </p>
<p>第三参数，实现这个接口 InvocationHandler，创建代理对象，写增强的部分</p>
<h3 id="2、编写-JDK-动态代理代码"><a href="#2、编写-JDK-动态代理代码" class="headerlink" title="2、编写 JDK 动态代理代码"></a>2、编写 JDK 动态代理代码</h3><p>（1）创建接口，定义方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">update</span><span class="params">(String id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）创建接口实现类，实现方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;add方法执行了.....&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">update</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;update方法执行了.....&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）使用 Proxy 类创建接口代理对象(即增强的功能)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDKProxy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建接口实现类代理对象</span></span><br><span class="line">        Class[] interfaces = &#123;UserDao.class&#125;;</span><br><span class="line"><span class="comment">//        Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces, new InvocationHandler() &#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span></span><br><span class="line"><span class="comment">//                return null;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;); 即使用匿名内部类实现</span></span><br><span class="line">        UserDaoImpl userDao = <span class="keyword">new</span> UserDaoImpl();</span><br><span class="line">        UserDao dao = (UserDao)Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces, <span class="keyword">new</span> UserDaoProxy(userDao));</span><br><span class="line">        <span class="keyword">int</span> result = dao.add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;result:&quot;</span>+result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建代理对象代码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserDaoProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1 把创建的是谁的代理对象，把谁传递过来</span></span><br><span class="line">    <span class="comment">//有参数构造传递</span></span><br><span class="line">    <span class="keyword">private</span> Object obj;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserDaoProxy</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//增强的逻辑</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//方法之前</span></span><br><span class="line">        System.out.println(<span class="string">&quot;方法之前执行....&quot;</span>+method.getName()+<span class="string">&quot; :传递的参数...&quot;</span>+ Arrays.toString(args));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//被增强的方法执行</span></span><br><span class="line">        Object res = method.invoke(obj, args);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方法之后</span></span><br><span class="line">        System.out.println(<span class="string">&quot;方法之后执行....&quot;</span>+obj);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Ⅳ-AOP术语"><a href="#Ⅳ-AOP术语" class="headerlink" title="Ⅳ.AOP术语"></a>Ⅳ.AOP术语</h2><h3 id="1-连接点"><a href="#1-连接点" class="headerlink" title="1.连接点"></a>1.连接点</h3><p>类里面有哪些方法可以被增强，这些方法就被叫做连接点。</p>
<h3 id="2-切入点"><a href="#2-切入点" class="headerlink" title="2.切入点"></a>2.切入点</h3><p>实际真正被增强的方法就被称为切入点。</p>
<h3 id="3-通知（增强）"><a href="#3-通知（增强）" class="headerlink" title="3.通知（增强）"></a>3.通知（增强）</h3><p>（1）实际增强的逻辑部分就叫做通知（增强）。</p>
<p>（2）通知有多种类型</p>
<ul>
<li>前置通知：在被增强方法之前执行</li>
<li>后置通知：在被增强方法之后执行</li>
<li>环绕通知：在被增强方法之前和之后都会执行</li>
<li>异常通知：在被增强方法抛出异常时会执行</li>
<li>最终通知：类似finally，一定会执行</li>
</ul>
<h3 id="4-切面"><a href="#4-切面" class="headerlink" title="4.切面"></a>4.切面</h3><p>是动作上的一个操作，即把通知应用到切入点的过程就叫做切面。</p>
<h2 id="Ⅴ-AOP-操作（准备工作）"><a href="#Ⅴ-AOP-操作（准备工作）" class="headerlink" title="Ⅴ.AOP 操作（准备工作）"></a>Ⅴ.AOP 操作（准备工作）</h2><h3 id="1、Spring-框架一般都是基于-AspectJ-实现-AOP-操作"><a href="#1、Spring-框架一般都是基于-AspectJ-实现-AOP-操作" class="headerlink" title="1、Spring 框架一般都是基于 AspectJ 实现 AOP 操作"></a>1、Spring 框架一般都是基于 AspectJ 实现 AOP 操作</h3><p><strong>什么是AspectJ：</strong>AspectJ 不是 Spring 组成部分，独立 AOP 框架，一般把 AspectJ 和 Spirng 框架一起使用，进行 AOP 操作。</p>
<h3 id="2、基于-AspectJ-实现-AOP-操作"><a href="#2、基于-AspectJ-实现-AOP-操作" class="headerlink" title="2、基于 AspectJ 实现 AOP 操作"></a>2、基于 AspectJ 实现 AOP 操作</h3><p>（1）基于 xml 配置文件实现 </p>
<p>（2）基于注解方式实现（实际中一般使用注解方式实现）</p>
<h3 id="3、在项目工程里面引入-AOP-相关依赖"><a href="#3、在项目工程里面引入-AOP-相关依赖" class="headerlink" title="3、在项目工程里面引入 AOP 相关依赖"></a>3、在项目工程里面引入 AOP 相关依赖</h3><p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/image-20210407155239140.png" alt="image-20210407155239140"></p>
<h3 id="4、切入点表达式"><a href="#4、切入点表达式" class="headerlink" title="4、切入点表达式"></a>4、切入点表达式</h3><p>（1）切入点表达式作用：知道对哪个类里面的哪个方法进行增强 </p>
<p>（2）语法结构： execution([权限修饰符] [返回类型] [类全路径] [方法名称] （[参数列表]）)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//举例 1：对 com.atguigu.dao.BookDao 类里面的 add 进行增强 *表示任意修饰符，返回类型可以省略</span></span><br><span class="line">execution(* com.atguigu.dao.BookDao.add(..))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//举例 2：对 com.atguigu.dao.BookDao 类里面的所有的方法进行增强</span></span><br><span class="line">execution(* com.atguigu.dao.BookDao.* (..))</span><br></pre></td></tr></table></figure>

<h2 id="Ⅵ-AOP-操作（AspectJ-注解）"><a href="#Ⅵ-AOP-操作（AspectJ-注解）" class="headerlink" title="Ⅵ.AOP 操作（AspectJ 注解）"></a>Ⅵ.AOP 操作（AspectJ 注解）</h2><h3 id="1、创建类，在类里面定义方法"><a href="#1、创建类，在类里面定义方法" class="headerlink" title="1、创建类，在类里面定义方法"></a>1、创建类，在类里面定义方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;add.......&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2、创建增强类（编写增强逻辑）"><a href="#2、创建增强类（编写增强逻辑）" class="headerlink" title="2、创建增强类（编写增强逻辑）"></a>2、创建增强类（编写增强逻辑）</h3><p>（1）在增强类里面，创建方法，让不同方法代表不同通知类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//增强的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserProxy</span> </span>&#123;</span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;<span class="comment">//前置通知</span></span><br><span class="line"> 	System.out.println(<span class="string">&quot;before......&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、进行通知的配置"><a href="#3、进行通知的配置" class="headerlink" title="3、进行通知的配置"></a>3、进行通知的配置</h3><p>（1）在 spring 配置文件中，开启注解扫描</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开启注解扫描 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.atguigu.spring5.aopanno&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（2）使用注解创建 User 和 UserProxy 对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//被增强的类</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增强的类</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order(3)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserProxy</span> </span>&#123;</span><br></pre></td></tr></table></figure>

<p>（3）在增强类上面添加注解 @Aspect</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//增强的类</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span>  <span class="comment">//生成代理对象</span></span><br><span class="line"><span class="meta">@Order(3)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserProxy</span> </span>&#123;</span><br></pre></td></tr></table></figure>

<p>（4）在 spring 配置文件中开启生成代理对象</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开启Aspect生成代理对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:aspectj-autoproxy</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="4、配置不同类型的通知"><a href="#4、配置不同类型的通知" class="headerlink" title="4、配置不同类型的通知"></a>4、配置不同类型的通知</h3><p>（1）在增强类的里面，在作为通知方法上面添加通知类型注解，使用切入点表达式配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//增强的类</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span> <span class="comment">//生成代理对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserProxy</span> </span>&#123;</span><br><span class="line"> 	<span class="comment">//前置通知</span></span><br><span class="line"> 	<span class="comment">//@Before 注解表示作为前置通知</span></span><br><span class="line"> 	<span class="meta">@Before(value = &quot;execution(* com.atguigu.spring5.aopanno.User.add(..))&quot;)</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 		System.out.println(<span class="string">&quot;before.........&quot;</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//后置通知（返回通知）</span></span><br><span class="line"> 	<span class="meta">@AfterReturning(value = &quot;execution(* </span></span><br><span class="line"><span class="meta">								com.atguigu.spring5.aopanno.User.add(..))&quot;)</span></span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 		System.out.println(<span class="string">&quot;afterReturning.........&quot;</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//最终通知</span></span><br><span class="line"> 	<span class="meta">@After(value = &quot;execution(* com.atguigu.spring5.aopanno.User.add(..))&quot;)</span></span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 		System.out.println(<span class="string">&quot;after.........&quot;</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//异常通知</span></span><br><span class="line"> 	<span class="meta">@AfterThrowing(value = &quot;execution(* </span></span><br><span class="line"><span class="meta">								com.atguigu.spring5.aopanno.User.add(..))&quot;)</span></span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowing</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 		System.out.println(<span class="string">&quot;afterThrowing.........&quot;</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//环绕通知</span></span><br><span class="line"> 	<span class="meta">@Around(value = &quot;execution(* com.atguigu.spring5.aopanno.User.add(..))&quot;)</span></span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">around</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="keyword">throws</span> </span></span><br><span class="line"><span class="function">		Throwable </span>&#123;</span><br><span class="line"> 			System.out.println(<span class="string">&quot;环绕之前.........&quot;</span>);</span><br><span class="line"> 			<span class="comment">//被增强的方法执行</span></span><br><span class="line"> 			proceedingJoinPoint.proceed();</span><br><span class="line"> 			System.out.println(<span class="string">&quot;环绕之后.........&quot;</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5、相同的切入点抽取"><a href="#5、相同的切入点抽取" class="headerlink" title="5、相同的切入点抽取"></a>5、相同的切入点抽取</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//相同切入点抽取</span></span><br><span class="line"><span class="meta">@Pointcut(value = &quot;execution(* com.atguigu.spring5.aopanno.User.add(..))&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointdemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//前置通知</span></span><br><span class="line"><span class="comment">//@Before注解表示作为前置通知</span></span><br><span class="line"><span class="meta">@Before(value = &quot;pointdemo()&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;before.........&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6、有多个增强类多同一个方法进行增强，设置增强类优先级"><a href="#6、有多个增强类多同一个方法进行增强，设置增强类优先级" class="headerlink" title="6、有多个增强类多同一个方法进行增强，设置增强类优先级"></a>6、有多个增强类多同一个方法进行增强，设置增强类优先级</h3><p>（1）在增强类上面添加注解 @Order(数字类型值)，数字类型值<strong>越小优先级越高</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Order(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonProxy</span></span></span><br></pre></td></tr></table></figure>

<h3 id="7、完全使用注解开发"><a href="#7、完全使用注解开发" class="headerlink" title="7、完全使用注解开发"></a>7、完全使用注解开发</h3><p>（1）创建配置类，不需要创建 xml 配置文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;com.atguigu&quot;&#125;)</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy(proxyTargetClass = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigAop</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Ⅶ-AOP-操作（AspectJ-配置文件）"><a href="#Ⅶ-AOP-操作（AspectJ-配置文件）" class="headerlink" title="Ⅶ.AOP 操作（AspectJ 配置文件）"></a>Ⅶ.AOP 操作（AspectJ 配置文件）</h2><h3 id="1、创建两个类，增强类和被增强类，创建方法"><a href="#1、创建两个类，增强类和被增强类，创建方法" class="headerlink" title="1、创建两个类，增强类和被增强类，创建方法"></a>1、创建两个类，增强类和被增强类，创建方法</h3><h3 id="2、在-spring-配置文件中创建两个类对象"><a href="#2、在-spring-配置文件中创建两个类对象" class="headerlink" title="2、在 spring 配置文件中创建两个类对象"></a>2、在 spring 配置文件中创建两个类对象</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--创建对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.aopxml.Book&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookProxy&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.aopxml.BookProxy&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3、在-spring-配置文件中配置切入点"><a href="#3、在-spring-配置文件中配置切入点" class="headerlink" title="3、在 spring 配置文件中配置切入点"></a>3、在 spring 配置文件中配置切入点</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置aop增强--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--切入点--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;p&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.atguigu.spring5.aopxml.Book.buy(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置切面（切面：将通知应用到切入点的过程）--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;bookProxy&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--增强作用在具体的方法上--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;before&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;p&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo个人博客搭建</title>
    <url>/2021/09/04/hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>在gitee上搭建Hexo个人博客所需的环境和大致步骤(Windows系统命令，Linux和Mac命令相差不大)：<br>1.安装git。<br>2.安装node、hexo。<br>3.使用git命令创建个人博客对应的blog文件夹<br>4.在gitee注册账号，创建新仓库。<br>5.将本地的博客提交到gitee仓库。<br>6.使用gitee pages服务获取自己的个人博客地址，使用该网址访问自己的个人博客。</p>
<span id="more"></span>

<h1 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1 准备工作"></a>1 准备工作</h1><h2 id="1-1-git的下载与安装"><a href="#1-1-git的下载与安装" class="headerlink" title="1.1 git的下载与安装"></a>1.1 git的下载与安装</h2><p>打开 [git官网]<a href="https://git-scm.com/">https://git-scm.com</a>，下载git对应操作系统的版本。如果官网下载太慢，我们可以使用淘宝镜像下载：<a href="https://npm.taobao.org/mirrors/git-for-windows">https://npm.taobao.org/mirrors/git-for-windows</a>。安装无脑下一步即可。</p>
<h3 id="1-1-1-常用的git命令"><a href="#1-1-1-常用的git命令" class="headerlink" title="1.1.1 常用的git命令"></a>1.1.1 常用的git命令</h3><p>(1).cd 改变目录 </p>
<p>(2).cd.. 回退到上一个目录 </p>
<p>(3).rm 删除一个文件 </p>
<p>(4).mkdir 新建一个文件夹 </p>
<p>(5).mv 移动文件 </p>
<p>(6).reset 重新初始化终端 </p>
<p>(7).clear 清屏 </p>
<p>(8).history 查看命令历史 </p>
<p>(9).exit 退出 </p>
<p>(10).# 注释</p>
<h3 id="1-1-2-git配置"><a href="#1-1-2-git配置" class="headerlink" title="1.1.2 git配置"></a>1.1.2 git配置</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git config --global --list 查看当前用户配置</span><br><span class="line">git config --system --list 查看系统config</span><br></pre></td></tr></table></figure>

<h3 id="1-1-3-设置用户名与邮箱"><a href="#1-1-3-设置用户名与邮箱" class="headerlink" title="1.1.3 设置用户名与邮箱"></a>1.1.3 设置用户名与邮箱</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;yourUsername&quot;</span>  #名称</span><br><span class="line">git config --global user.email yourEmail   #邮箱</span><br></pre></td></tr></table></figure>



<h2 id="1-2-node和hexo的下载安装"><a href="#1-2-node和hexo的下载安装" class="headerlink" title="1.2 node和hexo的下载安装"></a>1.2 node和hexo的下载安装</h2><p>直接打开[node官网]<a href="https://nodejs.org/en/">https://nodejs.org/en/</a>下载对应的node版本安装即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">node -v	#查看node版本</span><br><span class="line">npm -v	#查看npm版本</span><br><span class="line">npm install -g cnpm --registry=http:<span class="comment">//registry.npm.taobao.org	#安装淘宝的cnpm 管理器</span></span><br><span class="line">cnpm -v	#查看cnpm版本</span><br><span class="line">cnpm install -g hexo-cli    #安装hexo框架</span><br><span class="line">hexo -v	#查看hexo版本</span><br></pre></td></tr></table></figure>

<h1 id="2-开始创建自己的个人博客"><a href="#2-开始创建自己的个人博客" class="headerlink" title="2.开始创建自己的个人博客"></a>2.开始创建自己的个人博客</h1><h2 id="2-1-创建blog本地文件夹"><a href="#2-1-创建blog本地文件夹" class="headerlink" title="2.1 创建blog本地文件夹"></a>2.1 创建blog本地文件夹</h2><p>首先，选择一个想要创建blog文件夹的地方然后右键—&gt;选择Git Bash Here打开git窗口。</p>
<p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/1.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mkdir blog	#创建blog目录</span><br><span class="line">cd blog	 #进入blog目录</span><br><span class="line">sudo hexo init 	#生成博客 初始化博客</span><br><span class="line">hexo s	#启动本地博客服务</span><br><span class="line">http:<span class="comment">//localhost:4000/	#本地访问地址</span></span><br><span class="line">hexo g #生成</span><br></pre></td></tr></table></figure>

<p>打开访问地址能看到hexo的博客界面，说明准备工作已经成功了，就可以进行接下来将博客搭建到gitee上的工作了。</p>
<h2 id="2-2将博客部署到gitee上"><a href="#2-2将博客部署到gitee上" class="headerlink" title="2.2将博客部署到gitee上"></a>2.2将博客部署到gitee上</h2><p>先注册登录一个gitee账号，新建一个仓库。</p>
<p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/2.png"></p>
<p><strong>此处的路径和仓库名称必须与账户名一致</strong>，否则博客无法正常显示。</p>
<p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/3.png"></p>
<p>创建成功后会有一个地址，复制下来。</p>
<p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/4.png"></p>
<p>其中repo的值就是刚才复制的地址。执行下列git命令：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cnpm install --save hexo-deployer-git #在blog目录下安装git部署插件</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/5.png"></p>
<p>而后打开blog文件夹中的配置文件_config.yml，拉到最下面，进行如图所示的配置：</p>
<p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/6.png"></p>
<p>最后执行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hexo d -g #将本地博客部署到gitee上</span><br></pre></td></tr></table></figure>

<p>大功告成，最后使用gittee pages服务生成个人博客网址。</p>
<p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/7.png"></p>
<p>选择gitee，启动就能生成一个网址。</p>
<p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/8.png"></p>
<p>需要注意的是每次更新了博客内容以后都需要重新执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo d -g #每次更新后都要重新上传部署一下</span><br></pre></td></tr></table></figure>

<p>然后在gitee pages服务页面点击更新。</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Java参数及参数传递</title>
    <url>/2021/09/04/java%E5%8F%82%E6%95%B0%E5%8F%8A%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/</url>
    <content><![CDATA[<p>今天刷牛客网 Java 专项习题的时候碰到了一道关于 <code>Java</code> 参数及参数传递和<code>String</code>类型数据作为参数传递的情况，回顾了一下知识点，现在做一下简单的总结。</p>
<span id="more"></span>

<h1 id="1-形式参数和实际参数"><a href="#1-形式参数和实际参数" class="headerlink" title="1. 形式参数和实际参数"></a>1. 形式参数和实际参数</h1><p>在程序语言设计中，参数是有形式参数和实际参数之分的，先看一下形参和实参的定义：</p>
<blockquote>
<p>形式参数：是在定义函数名和函数体的时候使用的参数，目的是用来接收调用该函数时传入的参数，简称“形参”。</p>
<p>实际参数：在主调函数中调用一个函数时，函数名后面括号中的参数称为“实际参数”，简称“实参”。</p>
</blockquote>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        <span class="comment">// 实际参数为“张三”</span></span><br><span class="line">        p.sout(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sout</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 形式参数为 name</span></span><br><span class="line">        System.out.print(name);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Person类中定义了一个sout方法，该方法有个String类型的参数name，该参数即为形参。在main方法中，调用了sout方法，传入了一个参数“张三”，该参数即为实参。</p>
<p>问题来了：实际参数是如何传入方法的呢？</p>
<h1 id="2-值传递和引用传递"><a href="#2-值传递和引用传递" class="headerlink" title="2. 值传递和引用传递"></a>2. 值传递和引用传递</h1><p>参数传递的机制有两种：值传递和引用传递，先上定义：</p>
<blockquote>
<p>值传递：是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。</p>
<p>引用传递：是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</p>
</blockquote>
<h2 id="基本数据类型作为参数传递"><a href="#基本数据类型作为参数传递" class="headerlink" title="基本数据类型作为参数传递"></a>基本数据类型作为参数传递</h2><p><strong>基本数据类型作为参数传递时都是传递值的拷贝。</strong> 即在调用方法时，将要传递的值（实参）拷贝一份传入方法，因此无论方法怎么改变传入的值都不会影响实际参数的值。</p>
<p>简单地说就是把实参的拷贝值赋给形参，对形参的改变不会影响实参的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test test1 = <span class="keyword">new</span> Test();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用前的i=&quot;</span> + i);</span><br><span class="line">        test1.testPassParameter(i);</span><br><span class="line">        <span class="comment">//传递后,testPassParameter方法中对形参i的改变不会影响这里的i</span></span><br><span class="line">        System.out.println(<span class="string">&quot;调用后的i=&quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPassParameter</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        i = <span class="number">10</span>;<span class="comment">//这里只是对形参的改变</span></span><br><span class="line">        System.out.println(<span class="string">&quot;tpp方法中的i=&quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">调用前的i=<span class="number">5</span></span><br><span class="line">tpp方法中的i=<span class="number">10</span></span><br><span class="line">调用后的i=<span class="number">5</span></span><br></pre></td></tr></table></figure>

<h2 id="对象作为参数传递"><a href="#对象作为参数传递" class="headerlink" title="对象作为参数传递"></a>对象作为参数传递</h2><p>以下代码中 Dog dog 的 dog 是一个指针，存储的是对象的地址。在将一个参数传入一个方法时，本质上是将对象的地址以值的方式传递到形参中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    Dog(String name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">getObjectAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在方法中改变对象的字段值会改变原对象该字段值，因为引用的是同一个对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PassByValueExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Dog dog = <span class="keyword">new</span> Dog(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        func(dog);</span><br><span class="line">        System.out.println(dog.getName());          <span class="comment">// B</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(Dog dog)</span> </span>&#123;</span><br><span class="line">        dog.setName(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是在方法中将指针引用了其它对象，那么此时方法里和方法外的两个指针指向了不同的对象，在一个指针改变其所指向对象的内容对另一个指针所指向的对象没有影响。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PassByValueExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Dog dog = <span class="keyword">new</span> Dog(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        System.out.println(dog.getObjectAddress()); <span class="comment">// Dog@4554617c</span></span><br><span class="line">        func(dog);</span><br><span class="line">        System.out.println(dog.getObjectAddress()); <span class="comment">// Dog@4554617c</span></span><br><span class="line">        System.out.println(dog.getName());          <span class="comment">// A</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(Dog dog)</span> </span>&#123;</span><br><span class="line">        System.out.println(dog.getObjectAddress()); <span class="comment">// Dog@4554617c</span></span><br><span class="line">        dog = <span class="keyword">new</span> Dog(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        System.out.println(dog.getObjectAddress()); <span class="comment">// Dog@74a14482</span></span><br><span class="line">        System.out.println(dog.getName());          <span class="comment">// B</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由此可见，在java中对象作为参数传递时，<strong>传递的是引用的地址，是把对象在内存中的地址拷贝了一份传给了参数</strong>。所以为了方便理解，可以说在java中只有值传递没有引用传递，因为引用传递归根结底也是传递地址的拷贝值。</p>
<h1 id="3-String类型数据作为参数传递"><a href="#3-String类型数据作为参数传递" class="headerlink" title="3.String类型数据作为参数传递"></a>3.String类型数据作为参数传递</h1><p>基本数据类型的包装类型在传递参数时其实也是“按引用传递的”，只是因为包装类型变量都是不可变量，容易误解。</p>
<p>String是final类型，是个特殊的类，对它的一些操作符是<strong>重载</strong>的。比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">&quot;hello&quot;</span>;<span class="comment">//等价于String str=new String(&quot;hello&quot;);</span></span><br><span class="line"></span><br><span class="line"> String str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        str = str + <span class="string">&quot;world&quot;</span>;<span class="comment">//等价于str = new String(new StringBuffer(str).append(&quot;world&quot;));</span></span><br></pre></td></tr></table></figure>

<p>由此容易理解以下代码的输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(String str, <span class="keyword">char</span> ch[])</span> </span>&#123;</span><br><span class="line">        str = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">        ch[<span class="number">0</span>] = <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="keyword">char</span>[] ch = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">        fun(str, ch);</span><br><span class="line">        System.out.println(str);</span><br><span class="line">        System.out.println(ch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hello  </span><br><span class="line">dbc</span><br></pre></td></tr></table></figure>

<p>方法调用时，名称相同的实参和形参并不一样，一个是main()中的str,指向存放”hello”的内存地址。一个是fun()中的str，str=”world”,相当于new String(“world”)。==String是final类型，将在堆中重新分配一个内存空间存放”world”==。ch[0]=’d’,对象的内容发生改变。</p>
<p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/6133202-c0e7ac6f4a16d914.png" alt="img"></p>
<p>参考：</p>
<p><a href="https://www.jianshu.com/p/c63596a87eee">Java参数传递</a></p>
<p><a href="http://depp.wang/2017/07/26/String-Parameter-passing/">String数据类型</a></p>
]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/2021/09/04/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="排序的分类"><a href="#排序的分类" class="headerlink" title="排序的分类"></a>排序的分类</h1><h2 id="内部排序"><a href="#内部排序" class="headerlink" title="内部排序"></a>内部排序</h2><p>在排序时仅使用主存储器的排序算法成为内部排序，对所有的存储器都能够高速随机存储。</p>
<h2 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h2><p>在排序时需要使用外部存储的排序算法都属于外部排序。</p>
<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>冒泡排序的基本思想是迭代地对输入序列中的第一个元素到最后一个元素进行两两比较，当需要时交换这两个元素的位置（升序或者降序），持续迭代直到在一趟排序过程中不需要交换位置为止。由于排序的过程中较小的元素像气泡一样逐渐到序列的顶端，故得名“冒泡排序”。</p>
<p>冒泡排序代码如下：</p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] bubble(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    flag = <span class="keyword">true</span>;</span><br><span class="line">                    temp = arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">                    arr[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>代码中增加了一个附加标志位flag改进算法，用该标志位来记录是否发生了元素的交换，没有交换就意味着排序已经完成，通过判断标志位的状态来结束算法。</p>
<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>选择排序是一种原地排序算法，不需要额外的存储空间。选择排序的基本思路是寻找序列中的最小值，用当前位置的值交换最小值，而后对所有的元素重复执行上述过程，直到整个排序完成。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] fastSort(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">        <span class="keyword">int</span> min = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[i] &gt; arr[j]) &#123;</span><br><span class="line">                    min = arr[j];</span><br><span class="line">                    arr[j] = arr[i];</span><br><span class="line">                    arr[i] = min;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>插入式排序属于内部排序法，是对于欲排序的元素以插入的方式找寻该元素的适当位置，以达到排序的目的。插入排序的基本思想是：<strong>把 n 个待排序的元素看成为一个有序表和一个无序表，开始时有 序表中只包含一个元素，无序表中包含有 n-1 个元素</strong>，排序过程中每次从无序表中取出第一个元素，把它的排 序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。</p>
<p>例子：给定一个序列 6  2  4  5  3  8，按升序排列</p>
<p>​                                   <strong>6</strong>  2  4  5  3  8   （有序数列6，索引位置0，索引1-5为无序数列）</p>
<p>​                                   <strong>2</strong>  <strong>6</strong>  4  5  3  8   （将无序数列的第一个数按照一定的顺序插入到有序数列中）</p>
<p>​                                   <strong>2</strong>  <strong>4</strong>  <strong>6</strong>  5  3  8   （将无序数列中的数依次按顺序加入到有序数列中，知道排序完成）</p>
<p>​                                   <strong>2</strong>  <strong>4</strong>  <strong>5</strong>  <strong>6</strong>  3  8</p>
<p>​                                   <strong>2</strong>  <strong>3</strong>  <strong>4</strong>  <strong>5</strong>  <strong>6</strong>  8</p>
<p>​                                   <strong>2</strong>  <strong>3</strong>  <strong>4</strong>  <strong>5</strong>  <strong>6</strong>  <strong>8</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] insert(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">        <span class="keyword">int</span> insertVal = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> insertIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            insertVal = arr[i];</span><br><span class="line">            insertIndex = i - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1. insertIndex &gt;= 0 保证在给 insertVal 找插入位置，不越界</span></span><br><span class="line">            <span class="comment">// 2. insertVal &lt; arr[insertIndex] 待插入的数，还没有找到插入位置</span></span><br><span class="line">            <span class="comment">// 3. 就需要将 arr[insertIndex] 后移</span></span><br><span class="line">            <span class="keyword">while</span> (insertIndex &gt;= <span class="number">0</span> &amp;&amp; insertVal &lt; arr[insertIndex]) &#123;</span><br><span class="line">                arr[insertIndex + <span class="number">1</span>] = arr[insertIndex];</span><br><span class="line">                insertIndex--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断是否需要赋值，如果相等说明不满足赋值的条件，及还没有找到合适的插入位置，需要继续查找</span></span><br><span class="line">            <span class="keyword">if</span> (insertIndex + <span class="number">1</span> != i) &#123;</span><br><span class="line">                arr[insertIndex + <span class="number">1</span>] = insertVal;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125; </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>枚举与注解复习总结</title>
    <url>/2021/09/04/%E6%9E%9A%E4%B8%BE%E4%B8%8E%E6%B3%A8%E8%A7%A3%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="枚举主要内容"><a href="#枚举主要内容" class="headerlink" title="枚举主要内容:"></a>枚举主要内容:</h1><ul>
<li><p>如何自定义枚举类 </p>
</li>
<li><p>如何使用关键字enum定义枚举类 </p>
</li>
<li><p>Enum类的主要方法 </p>
</li>
<li><p>实现接口的枚举类 </p>
</li>
</ul>
<h2 id="一、枚举类的使用"><a href="#一、枚举类的使用" class="headerlink" title="一、枚举类的使用"></a>一、枚举类的使用</h2><ul>
<li>1.枚举类的理解：类的对象只有有限个，确定的。我们称此类为枚举类</li>
<li>2.当需要定义一组常量(final关键字)时，强烈建议使用枚举类</li>
<li>3.如果枚举类中只有一个对象，则可以作为单例模式的实现方式。</li>
</ul>
<h2 id="二、如何定义枚举类"><a href="#二、如何定义枚举类" class="headerlink" title="二、如何定义枚举类"></a>二、如何定义枚举类</h2><ul>
<li>方式一：jdk5.0之前，自定义枚举类</li>
</ul>
<span id="more"></span>

<ul>
<li>方式二：jdk5.0，可以使用enum关键字定义枚举类</li>
</ul>
<h3 id="1-自定义枚举类"><a href="#1-自定义枚举类" class="headerlink" title="1.自定义枚举类"></a>1.自定义枚举类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自定义枚举类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Season</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.声明Season对象的属性:private final修饰</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.私有化类的构造器,并给对象属性赋值</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Season</span><span class="params">(String seasonName,String seasonDesc)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.seasonName = seasonName;</span><br><span class="line">        <span class="keyword">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.提供当前枚举类的多个对象：public static final的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season SPRING = <span class="keyword">new</span> Season(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春暖花开&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season SUMMER = <span class="keyword">new</span> Season(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;夏日炎炎&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season AUTUMN = <span class="keyword">new</span> Season(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋高气爽&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season WINTER = <span class="keyword">new</span> Season(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;冰天雪地&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.其他诉求1：获取枚举类对象的属性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSeasonName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seasonName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSeasonDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.其他诉求1：提供toString()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Season&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;seasonName=&#x27;&quot;</span> + seasonName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, seasonDesc=&#x27;&quot;</span> + seasonDesc + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-使用enum关键字定义枚举类"><a href="#2-使用enum关键字定义枚举类" class="headerlink" title="2.使用enum关键字定义枚举类"></a>2.使用enum关键字定义枚举类</h3><p>说明：</p>
<ul>
<li>定义的枚举类默认继承于java.lang.Enum类,因此不能再继承其他类</li>
<li>枚举类的构造器只能使用 private 权限修饰符</li>
<li>枚举类的所有实例必须在枚举类中显式列出(, 分隔 ; 结尾)。列出的 实例系统会自动添加 ==public static final==修饰</li>
<li>==必须在枚举类的第一行声明枚举类对象==</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用enum关键字枚举类</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Season1</span> <span class="keyword">implements</span> <span class="title">Info</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.提供当前枚举类的对象，多个对象之间用&quot;,&quot;隔开，末尾对象&quot;;&quot;结束</span></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春暖花开&quot;</span>),</span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;夏日炎炎&quot;</span>),</span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋高气爽&quot;</span>),</span><br><span class="line">    WINTER(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;天寒地冻&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.声明Season对象的属性:private final修饰</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.私有化类的构造器,并给对象属性赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Season1</span><span class="params">(String seasonName,String seasonDesc)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.seasonName = seasonName;</span><br><span class="line">        <span class="keyword">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.其他诉求1：获取枚举类对象的属性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSeasonName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seasonName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSeasonDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure>

<h2 id="三、Enum类的主要方法："><a href="#三、Enum类的主要方法：" class="headerlink" title="三、Enum类的主要方法："></a>三、Enum类的主要方法：</h2><ul>
<li><strong>values()方法：返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值。</strong></li>
<li><strong>valueOf(String str)：可以把一个字符串转为对应的枚举类对象。要求字符 串必须是枚举类对象的“名字”。如不是，会有运行时异常： IllegalArgumentException。</strong></li>
<li><strong>toString()：返回当前枚举类对象常量的名称。</strong></li>
</ul>
<h2 id="四、使用enum关键字定义的枚举类实现接口的情况"><a href="#四、使用enum关键字定义的枚举类实现接口的情况" class="headerlink" title="四、使用enum关键字定义的枚举类实现接口的情况"></a>四、使用enum关键字定义的枚举类实现接口的情况</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">情况一：实现接口，在<span class="class"><span class="keyword">enum</span>类中实现抽象方法</span></span><br><span class="line"><span class="class">情况二：让枚举类的对象分别实现接口中的抽象方法</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Info</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用enum关键字枚举类</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Season1</span> <span class="keyword">implements</span> <span class="title">Info</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.提供当前枚举类的对象，多个对象之间用&quot;,&quot;隔开，末尾对象&quot;;&quot;结束</span></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春暖花开&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;春天在哪里？&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;夏日炎炎&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;宁夏&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋高气爽&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;秋天不回来&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    WINTER(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;冰天雪地&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;大约在冬季&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.声明Season对象的属性:private final修饰</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.私有化类的构造器,并给对象属性赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Season1</span><span class="params">(String seasonName,String seasonDesc)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.seasonName = seasonName;</span><br><span class="line">        <span class="keyword">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.其他诉求1：获取枚举类对象的属性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSeasonName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seasonName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSeasonDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seasonDesc;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="注解主要内容："><a href="#注解主要内容：" class="headerlink" title="注解主要内容："></a>注解主要内容：</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">注解(Annotation)概述</span><br><span class="line">常见的Annotation示例</span><br><span class="line">自定义Annotation</span><br><span class="line">JDK中的元注解</span><br><span class="line">利用反射获取注解信息（在反射部分涉及）</span><br><span class="line">JDK <span class="number">8</span>中注解的新特性</span><br></pre></td></tr></table></figure>

<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><ul>
<li>从 JDK 5.0 开始, Java 增加了对元数据(MetaData) 的支持, 也就是 Annotation(注解)</li>
<li>Annotation 其实就是代码里的特殊标记（如@Override）, 这些标记可以在编译, 类加 载, 运行时被读取, 并执行相应的处理。通过使用 Annotation, 程序员 可以在不改变原有逻辑的情况下, 在源文件中嵌入一些补充信息。代 码分析工具、开发工具和部署工具可以通过这些补充信息进行验证 或者进行部署。</li>
<li>Annotation 可以像修饰符一样被使用, 可用于修饰包,类, 构造器, 方 法, 成员变量, 参数, 局部变量的声明, 这些信息被保存在 Annotation  的 “name=value” 对中。</li>
<li>在 JavaSE 中，注解的使用目的比较简单，例如标记过时的功能， 忽略警告等。在 JavaEE/Android 中注解占据了更重要的角色，例如 用来配置应用程序的任何切面，代替 JavaEE 旧版中所遗留的繁冗 代码和XML配置等。</li>
<li>开发模式都是基于注解的，JPA是基于注解的，Spring2.5以上都是基于注解的，Hibernate3.x 以后也是基于注解的，现在的 Struts2 有一部分也是基于注解的了，注解是一种趋势，一定程度上 可以说：==框架 = 注解 + 反射 + 设计模式==。</li>
<li>使用 Annotation 时要在其前面增加 @ 符号, 并把该 Annotation 当成 一个修饰符使用。用于修饰它支持的程序元素。</li>
</ul>
<h2 id="二、常见的Annotation示例"><a href="#二、常见的Annotation示例" class="headerlink" title="二、常见的Annotation示例"></a>二、常见的Annotation示例</h2><h3 id="（1）在编译时进行格式检查-JDK内置的三个基本注解"><a href="#（1）在编译时进行格式检查-JDK内置的三个基本注解" class="headerlink" title="（1）在编译时进行格式检查(JDK内置的三个基本注解)"></a>（1）在编译时进行格式检查(JDK内置的三个基本注解)</h3><ul>
<li>@Override: 限定重写父类方法, 该注解只能用于方法。</li>
<li>@Deprecated: 用于表示所修饰的元素(类, 方法等)已过时。通常是因为所修饰的结构危险或==存在更好的选择。==但不影响使用。</li>
<li>@SuppressWarnings: 抑制编译器警告。如在IDEA中定义的变量未使用时，变量以灰色的形式显示。加上@SuppressWarnings(“unused”)后以黑色显示。</li>
</ul>
<h3 id="（2）跟踪代码依赖性，实现替代配置文件功能"><a href="#（2）跟踪代码依赖性，实现替代配置文件功能" class="headerlink" title="（2）跟踪代码依赖性，实现替代配置文件功能"></a>（2）跟踪代码依赖性，实现替代配置文件功能</h3><p><strong>Servlet3.0提供了注解(annotation),使得不再需要在web.xml文件中进行Servlet的部署。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/login&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span></span></span><br><span class="line"><span class="function">ServletException, IOException </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span></span></span><br><span class="line"><span class="function">ServletException, IOException </span>&#123;</span><br><span class="line">doGet(request, response);</span><br><span class="line">&#125; &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">&lt;servlet-name&gt;LoginServlet&lt;/servlet-name&gt;</span><br><span class="line">&lt;servlet-<span class="class"><span class="keyword">class</span>&gt;<span class="title">com</span>.<span class="title">servlet</span>.<span class="title">LoginServlet</span>&lt;/<span class="title">servlet</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">servlet</span>&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">servlet</span>-<span class="title">mapping</span>&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">servlet</span>-<span class="title">name</span>&gt;<span class="title">LoginServlet</span>&lt;/<span class="title">servlet</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">url</span>-<span class="title">pattern</span>&gt;/<span class="title">login</span>&lt;/<span class="title">url</span>-<span class="title">pattern</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">servlet</span>-<span class="title">mapping</span>&gt;</span></span><br><span class="line"><span class="class"></span></span><br></pre></td></tr></table></figure>

<p><strong>spring框架中关于“事务”的管理</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation=Propagation.REQUIRES_NEW,</span></span><br><span class="line"><span class="meta">isolation=Isolation.READ_COMMITTED,readOnly=false,timeout=3)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buyBook</span><span class="params">(String username, String isbn)</span> </span>&#123;</span><br><span class="line"><span class="comment">//1.查询书的单价</span></span><br><span class="line"><span class="keyword">int</span> price = bookShopDao.findBookPriceByIsbn(isbn);</span><br><span class="line"><span class="comment">//2. 更新库存</span></span><br><span class="line">bookShopDao.updateBookStock(isbn);</span><br><span class="line"><span class="comment">//3. 更新用户的余额</span></span><br><span class="line">bookShopDao.updateUserAccount(username, price);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、自定义-Annotation，参照-SuppressWarnings定义"><a href="#三、自定义-Annotation，参照-SuppressWarnings定义" class="headerlink" title="三、自定义 Annotation，参照@SuppressWarnings定义"></a>三、自定义 Annotation，参照@SuppressWarnings定义</h2><ul>
<li>定义新的 Annotation 类型使用 @interface 关键字。 </li>
<li>自定义注解自动继承了java.lang.annotation.Annotation接口。 </li>
<li>Annotation 的成员变量在 Annotation 定义中以无参数方法的形式来声明。其 方法名和返回值定义了该成员的名字和类型。我们称为配置参数。==类型只能是八种基本数据类型、String类型、Class类型、enum类型、Annotation类型、 以上所有类型的数组==。 </li>
<li>可以在定义 Annotation 的成员变量时为其指定初始值, 指定成员变量的初始 值可使用 default 关键字。 </li>
<li>如果只有一个参数成员，建议使用参数名为value。 </li>
<li>如果定义的注解含有配置参数，那么使用时必须指定参数值，除非它有默认 值。格式是“参数名 = 参数值” ，如果只有一个参数成员，且名称为value， 可以省略“value=”。 </li>
<li>没有成员定义的 Annotation 称为标记; 包含成员变量的 Annotation 称为元数 据 Annotation。</li>
</ul>
<p>注意：自定义注解必须配上注解的信息处理流程（使用反射）才有意义。自定义注解通过都会指明两个元注解：Retention、Target</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MyAnnotation(value=&quot;尚硅谷&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAnnotationTest</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         Class clazz = MyAnnotationTest.class;</span><br><span class="line">			Annotation a = clazz.getAnnotation(MyAnnotation.class);</span><br><span class="line">			MyAnnotation m = (MyAnnotation) a;</span><br><span class="line">			String info = m.value();</span><br><span class="line">			System.out.println(info);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotation&#123;</span><br><span class="line">	<span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;auguigu&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="JDK-中的元注解"><a href="#JDK-中的元注解" class="headerlink" title="JDK 中的元注解"></a>JDK 中的元注解</h1><h2 id="元注解：对现有的注解进行解释说明的注解。"><a href="#元注解：对现有的注解进行解释说明的注解。" class="headerlink" title="元注解：对现有的注解进行解释说明的注解。"></a>元注解：对现有的注解进行解释说明的注解。</h2><ul>
<li>JDK 的元 Annotation 用于修饰其他 Annotation 定义</li>
<li>JDK5.0提供了4个标准的meta-annotation类型，分别是：</li>
</ul>
<h3 id="Retention"><a href="#Retention" class="headerlink" title="Retention"></a>Retention</h3><p>@Retention: 只能用于修饰一个 Annotation 定义, 用于指定该 Annotation 的生命 周期, @Rentention 包含一个 RetentionPolicy 类型的成员变量, 使用 @Rentention 时必须为该 value 成员变量指定值:</p>
<ul>
<li>RetentionPolicy.SOURCE:在源文件中有效（即源文件保留），编译器直接丢弃这种策略的注释。</li>
<li>RetentionPolicy.CLASS（默认行为）:在class文件中有效（即class保留） ，当运行 Java 程序时, JVM  不会保留注解。 这是默认值</li>
<li>RetentionPolicy.RUNTIME:在运行时有效（即运行时保留），当==运行 Java 程序时, JVM 会 保留注释。程序可以通过反射获取该注释。==只有声明为RUNTIME生命周期的注解，才能通过反射获取。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">RetentionPolicy</span></span>&#123;</span><br><span class="line">	SOURCE,</span><br><span class="line">	CLASS,</span><br><span class="line">	RUNTIME</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotation1&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotation2&#123; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h3><p>@Target: 用于修饰 Annotation 定义, 用于指定被修饰的 Annotation 能用于 修饰哪些程序元素。 @Target 也包含一个名为 value 的成员变量。S</p>
<pre><code>          ###  Documented
</code></pre>
<p>@Documented:用于指定被该元 Annotation 修饰的 Annotation 类将被 javadoc 工具提取成文档。默认情况下，javadoc是不包括注解的。 </p>
<p>定义为Documented的注解必须设置Retention值为RUNTIME。</p>
<pre><code>          ###  Inherited
</code></pre>
<p>@Inherited: 被它修饰的 Annotation 将具有继承性。如果某个类使用了被 @Inherited 修饰的 Annotation, 则其子类将自动具有该注解。 </p>
<ul>
<li><p>比如：如果把标有@Inherited注解的自定义的注解标注在类级别上，子类则可以继承父类类级别的注解 </p>
</li>
<li><p>实际应用中，使用较少</p>
</li>
</ul>
<h1 id="JDK8中注解的新特性"><a href="#JDK8中注解的新特性" class="headerlink" title="JDK8中注解的新特性"></a>JDK8中注解的新特性</h1><p>Java 8对注解处理提供了两点改进：可重复的注解及可用于类型的注解。此外，反射也得到了加强，在Java8中能够得到方法参数的名称。这会简化标注在方法参数上的注解。</p>
<p>① 在MyAnnotation上声明@Repeatable，成员值为MyAnnotations.class<br>       ② MyAnnotation的Target和Retention等元注解与MyAnnotations相同。</p>
<p>类型注解：JDK1.8之后，关于元注解@Target的参数类型ElementType枚举值多了两个： TYPE_PARAMETER,TYPE_USE。在Java 8之前，注解只能是在声明的地方所使用，Java8开始，注解可以应用 在任何地方。</p>
<p> ElementType.TYPE_PARAMETER 表示该注解能写在类型变量的声明语 句中（如：泛型声明）。</p>
<p> ElementType.TYPE_USE 表示该注解能写在使用类型的任何语句中。</p>
]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>递归算法学习笔记</title>
    <url>/2021/09/04/%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="1-递归的概念"><a href="#1-递归的概念" class="headerlink" title="1.递归的概念"></a>1.递归的概念</h1><p>递归就是方法自己调用自己,每次调用时传入不同的变量.递归有助于解决复杂的问题的同时还可以让代码变得更加简洁。但是值得注意的是，递归只是让解决方案变得清晰，并没有性能上的优势，有时甚至还没有循环的性能好，而这也是递归的主要缺点之一。</p>
<p>比如定义函数 f(x)=x+f(x-1)：</p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + f(x-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="1-1-递归的条件和规则"><a href="#1-1-递归的条件和规则" class="headerlink" title="1.1 递归的条件和规则"></a>1.1 递归的条件和规则</h2><p>递归自己调用自己，因此写递归时很容易出错，陷入无限循环。因此编写递归方法时，必须设定条件告诉递归何时停止。如上面的例子：</p>
<p>如果代入 f(2)：</p>
<p>返回 2+f(1)；<br>       调用 f(1)；<br>       返回 1+f(0)；<br>       调用 f(0)；<br>       返回 0+f(-1)；<br>       ……</p>
<p>这时程序会无休止地运行下去，直到崩溃。</p>
<p>如果我们加一个判断语句 <strong>x&gt;0</strong>;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> x + f(x-<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这次计算 f(2)=2+f(1)=2+1+f(0)=2+1+0=3。</p>
<p>由此可得递归的两个规律：</p>
<ul>
<li>递归函数必须要有<strong>终止条件</strong>，否则会出错；</li>
<li>递归函数先不断调用自身，直到遇到终止条件后进行回溯，最终返回答案。</li>
</ul>
<blockquote>
<ol>
<li><p>执行一个方法时，就创建一个新的受保护的独立空间(栈空间)</p>
</li>
<li><p>方法的局部变量是独立的，不会相互影响, 比如 n 变量</p>
</li>
<li><p>如果方法中使用的是引用类型变量(比如数组)，就会共享该引用类型的数据.</p>
</li>
<li><p>递归必须向退出递归的条件逼近，否则就是无限递归,会报栈溢出的错误 。</p>
</li>
<li><p>当一个方法执行完毕，或者遇到 return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或 者返回时，该方法也就执行完毕。   </p>
</li>
</ol>
</blockquote>
<h2 id="1-2-递归的机制图解"><a href="#1-2-递归的机制图解" class="headerlink" title="1.2 递归的机制图解"></a>1.2 递归的机制图解</h2><p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/10.png"></p>
<h1 id="2-递归的应用场景"><a href="#2-递归的应用场景" class="headerlink" title="2 递归的应用场景"></a>2 递归的应用场景</h1><h2 id="2-1-阶乘问题"><a href="#2-1-阶乘问题" class="headerlink" title="2.1 阶乘问题"></a>2.1 阶乘问题</h2><p>问题描述：使用递归方法来完成自然数的阶乘。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> factorial(n - <span class="number">1</span>) * n; <span class="comment">// 1 * 2 * 3</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-迷宫问题"><a href="#2-2-迷宫问题" class="headerlink" title="2.2 迷宫问题"></a>2.2 迷宫问题</h2><p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/11.png"></p>
<p>如图所示的迷宫为小球找到路，使其能走到迷宫的右下角。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.recursion;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MiGong</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先创建一个二维数组，模拟迷宫</span></span><br><span class="line">        <span class="comment">// 地图</span></span><br><span class="line">        <span class="keyword">int</span>[][] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>][<span class="number">7</span>];</span><br><span class="line">        <span class="comment">// 使用1 表示墙</span></span><br><span class="line">        <span class="comment">// 上下全部置为1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">            map[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">            map[<span class="number">7</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左右全部置为1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            map[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            map[i][<span class="number">6</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置挡板, 1 表示</span></span><br><span class="line">        map[<span class="number">3</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        map[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出地图</span></span><br><span class="line">        System.out.println(<span class="string">&quot;地图的情况&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">7</span>; j++) &#123;</span><br><span class="line">                System.out.print(map[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用递归回溯给小球找路</span></span><br><span class="line">        System.out.println(<span class="string">&quot;小球走过，并标识过的 地图的情况&quot;</span>);</span><br><span class="line">        setWay(map, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//setWay2(map, 1, 1);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出新的地图, 小球走过，并标识过的递归</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">7</span>; j++) &#123;</span><br><span class="line">                System.out.print(map[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用递归回溯来给小球找路</span></span><br><span class="line">    <span class="comment">//说明</span></span><br><span class="line">    <span class="comment">//1. map 表示地图</span></span><br><span class="line">    <span class="comment">//2. i,j 表示从地图的哪个位置开始出发 (1,1)</span></span><br><span class="line">    <span class="comment">//3. 如果小球能到 map[6][5] 位置，则说明通路找到.</span></span><br><span class="line">    <span class="comment">//4. 约定： 当map[i][j] 为 0 表示该点没有走过 当为 1 表示墙  ； 2 表示通路可以走 ； 3 表示该点已经走过，但是走不通</span></span><br><span class="line">    <span class="comment">//5. 在走迷宫时，需要确定一个策略(方法) 下-&gt;右-&gt;上-&gt;左 , 如果该点走不通，再回溯</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map 表示地图</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i   从哪个位置开始找</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果找到通路，就返回true, 否则返回false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">setWay</span><span class="params">(<span class="keyword">int</span>[][] map, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (map[<span class="number">6</span>][<span class="number">5</span>] == <span class="number">2</span>) &#123; <span class="comment">// 通路已经找到ok</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;(%d,%d)&quot;</span>, i, j);</span><br><span class="line">            System.out.println();</span><br><span class="line">            <span class="keyword">if</span> (map[i][j] == <span class="number">0</span>) &#123; <span class="comment">//如果当前这个点还没有走过</span></span><br><span class="line">                <span class="comment">//按照策略 下-&gt;右-&gt;上-&gt;左  走</span></span><br><span class="line">                map[i][j] = <span class="number">2</span>; <span class="comment">// 假定该点是可以走通.</span></span><br><span class="line">                <span class="keyword">if</span> (setWay(map, i + <span class="number">1</span>, j)) &#123;<span class="comment">//向下走</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (setWay(map, i, j + <span class="number">1</span>)) &#123; <span class="comment">//向右走</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (setWay(map, i - <span class="number">1</span>, j)) &#123; <span class="comment">//向上</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (setWay(map, i, j - <span class="number">1</span>)) &#123; <span class="comment">// 向左走</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//说明该点是走不通，是死路</span></span><br><span class="line">                    map[i][j] = <span class="number">3</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果map[i][j] != 0 , 可能是 1， 2， 3</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-3-N皇后问题"><a href="#2-3-N皇后问题" class="headerlink" title="2.3 N皇后问题"></a>2.3 N皇后问题</h2><p>问题描述（此处以8皇后为例）：在 8×8 格的国际象棋上摆放八个皇后，使其不能互相攻击，即：任意两个皇后都不能处于同一行、 同一列或同一斜线上，问有多少种摆法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.recursion;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queue8</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个max表示共有多少个皇后</span></span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">8</span>;</span><br><span class="line">    <span class="comment">//定义数组array, 保存皇后放置位置的结果,比如 arr = &#123;0 , 4, 7, 5, 2, 6, 1, 3&#125; </span></span><br><span class="line">    <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[max];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> judgeCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//测试一把 ， 8皇后是否正确</span></span><br><span class="line">        Queue8 queue8 = <span class="keyword">new</span> Queue8();</span><br><span class="line">        queue8.check(<span class="number">0</span>);</span><br><span class="line">        System.out.printf(<span class="string">&quot;一共有%d解法&quot;</span>, count);</span><br><span class="line">        System.out.printf(<span class="string">&quot;一共判断冲突的次数%d次&quot;</span>, judgeCount); <span class="comment">// 1.5w</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写一个方法，放置第n个皇后</span></span><br><span class="line">    <span class="comment">//特别注意： check 是 每一次递归时，进入到check中都有  for(int i = 0; i &lt; max; i++)，因此会有回溯</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == max) &#123;  <span class="comment">//n = 8 , 其实8个皇后就已然放好</span></span><br><span class="line">            print();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//依次放入皇后，并判断是否冲突</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line">            <span class="comment">//先把当前这个皇后 n , 放到该行的第1列</span></span><br><span class="line">            array[n] = i;</span><br><span class="line">            <span class="comment">//判断当放置第n个皇后到i列时，是否冲突</span></span><br><span class="line">            <span class="keyword">if</span> (judge(n)) &#123; <span class="comment">// 不冲突</span></span><br><span class="line">                <span class="comment">//接着放n+1个皇后,即开始递归</span></span><br><span class="line">                check(n + <span class="number">1</span>); <span class="comment">//  </span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果冲突，就继续执行 array[n] = i; 即将第n个皇后，放置在本行得 后移的一个位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查看当我们放置第n个皇后, 就去检测该皇后是否和前面已经摆放的皇后冲突</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n 表示第n个皇后</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        judgeCount++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 说明</span></span><br><span class="line">            <span class="comment">//1. array[i] == array[n]  表示判断 第n个皇后是否和前面的n-1个皇后在同一列</span></span><br><span class="line">            <span class="comment">//2. Math.abs(n-i) == Math.abs(array[n] - array[i]) 表示判断第n个皇后是否和第i皇后是否在同一斜线</span></span><br><span class="line">            <span class="comment">// n = 1  放置第 2列 1 n = 1 array[1] = 1</span></span><br><span class="line">            <span class="comment">// Math.abs(1-0) == 1  Math.abs(array[n] - array[i]) = Math.abs(1-0) = 1</span></span><br><span class="line">            <span class="comment">//3. 判断是否在同一行, 没有必要，n 每次都在递增</span></span><br><span class="line">            <span class="keyword">if</span> (array[i] == array[n] || Math.abs(n - i) == Math.abs(array[n] - array[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写一个方法，可以将皇后摆放的位置输出</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            System.out.print(array[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>说明： 理论上应该创建一个二维数组来表示棋盘，但是实际上可以通过算法，用一个一维数组即可解决问题. </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">arr[<span class="number">8</span>] = &#123;<span class="number">0</span> , <span class="number">4</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">3</span>&#125; <span class="comment">//对应 arr 下标 表示第几行，即第几个皇后，arr[i] = val , val 表示第 i+1 个皇后，放在第 i+1 行的第 val+1 列。</span></span><br></pre></td></tr></table></figure>

<h1 id="3-leetcode上对应的easy递归题目"><a href="#3-leetcode上对应的easy递归题目" class="headerlink" title="3 leetcode上对应的easy递归题目"></a>3 leetcode上对应的easy递归题目</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">206.</span>反转一个单链表。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;NULL</span><br><span class="line">输出: <span class="number">5</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span>-&gt;NULL</span><br><span class="line">进阶:</span><br><span class="line">你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/reverse-linked-list</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">递归解法</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//递归终止条件是当前为空，或者下一个节点为空</span></span><br><span class="line">		<span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> head;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//这里的cur就是最后一个节点</span></span><br><span class="line">		ListNode cur = reverseList(head.next);</span><br><span class="line">		<span class="comment">//这里请配合动画演示理解</span></span><br><span class="line">		<span class="comment">//如果链表是 1-&gt;2-&gt;3-&gt;4-&gt;5，那么此时的cur就是5</span></span><br><span class="line">		<span class="comment">//而head是4，head的下一个是5，下下一个是空</span></span><br><span class="line">		<span class="comment">//所以head.next.next 就是5-&gt;4</span></span><br><span class="line">		head.next.next = head;</span><br><span class="line">		<span class="comment">//防止链表循环，需要将head.next设置为空</span></span><br><span class="line">		head.next = <span class="keyword">null</span>;</span><br><span class="line">		<span class="comment">//每层递归函数都返回cur，也就是最后一个节点</span></span><br><span class="line">		<span class="keyword">return</span> cur;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">509.</span>斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 <span class="number">0</span> 和 <span class="number">1</span> 开始，后面的每一项数字都是前面两项数字的和。也就是：</span><br><span class="line"></span><br><span class="line">F(<span class="number">0</span>) = <span class="number">0</span>，F(<span class="number">1</span>) = <span class="number">1</span></span><br><span class="line">F(n) = F(n - <span class="number">1</span>) + F(n - <span class="number">2</span>)，其中 n &gt; <span class="number">1</span></span><br><span class="line">给你 n ，请计算 F(n) 。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">输入：<span class="number">2</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：F(<span class="number">2</span>) = F(<span class="number">1</span>) + F(<span class="number">0</span>) = <span class="number">1</span> + <span class="number">0</span> = <span class="number">1</span></span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">输入：<span class="number">3</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：F(<span class="number">3</span>) = F(<span class="number">2</span>) + F(<span class="number">1</span>) = <span class="number">1</span> + <span class="number">1</span> = <span class="number">2</span></span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：<span class="number">4</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：F(<span class="number">4</span>) = F(<span class="number">3</span>) + F(<span class="number">2</span>) = <span class="number">2</span> + <span class="number">1</span> = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/fibonacci-number</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">int</span> Fn = <span class="number">0</span>;        </span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;            </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;        </span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;            </span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;        </span><br><span class="line">        &#125;        </span><br><span class="line">        Fn = fib(n-<span class="number">1</span>)+fib(n-<span class="number">2</span>);        </span><br><span class="line">        <span class="keyword">return</span> Fn;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，对这题来说递归并不是最好的解法，相较于动态优化来说其性能并不是很优。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode二叉树刷题总结</title>
    <url>/2021/09/04/LeetCode%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>本篇博客的思路大部分来自labuladong的算法小抄和LeetCode中相应题的题解讨论区。在此做一个总结，以便日后方便复习回顾。</p>
<p>在二叉树的题目中，大多数的二叉树问题的本质都是树的遍历，关于树的增删改查的操作归根结底都是在对树的遍历的基础上进行的，所以在解决二叉树问题时，树的遍历算法占据着举足轻重的地位。而二叉树的遍历又跟递归有着非常紧密的联系，可以说大部分递归的题目都跟树的遍历有关系。</p>
<span id="more"></span>

<p>对于解决二叉树算法的设计的总路线：明确一个节点要做的事情，然后剩下的事让递归解决。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// root 需要做什么？在这做。</span></span><br><span class="line">    <span class="comment">// 其他的不用 root 操心，抛给框架</span></span><br><span class="line">    traverse(root.left);</span><br><span class="line">    traverse(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举两个简单的例子体会一下这个思路:</p>
<p><strong>1. 如何把二叉树所有的节点中的值加一？</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">plusOne</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    root.val += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    plusOne(root.left);</span><br><span class="line">    plusOne(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 如何判断两棵二叉树是否完全相同？</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 都为空的话，显然相同</span></span><br><span class="line">    <span class="keyword">if</span> (root1 == <span class="keyword">null</span> &amp;&amp; root2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 一个为空，一个非空，显然不同</span></span><br><span class="line">    <span class="keyword">if</span> (root1 == <span class="keyword">null</span> || root2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 两个都非空，但 val 不一样也不行</span></span><br><span class="line">    <span class="keyword">if</span> (root1.val != root2.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// root1 和 root2 该比的都比完了</span></span><br><span class="line">    <span class="keyword">return</span> isSameTree(root1.left, root2.left)</span><br><span class="line">        &amp;&amp; isSameTree(root1.right, root2.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二叉搜索树（Binary Search Tree，简称 BST）是一种很常用的的二叉树。它的定义是：一个二叉树中，任意节点的值要大于等于左子树所有节点的值，且要小于等于右边子树的所有节点的值。</p>
<p>如下就是一个符合定义的 BST：</p>
<img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/image-20210415234425307.png" alt="image-20210415234425307" style="zoom: 67%;" />

<p>下面实现 BST 的基础操作：判断 BST 的合法性、增、删、查。其中“删”和“判断合法性”略微复杂。</p>
<h1 id="零、判断-BST-的合法性"><a href="#零、判断-BST-的合法性" class="headerlink" title="零、判断 BST 的合法性"></a>零、判断 BST 的合法性</h1><p>这里是有坑的哦，我们按照刚才的思路，每个节点自己要做的事不就是比较自己和左右孩子吗？看起来应该这样写代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.left != <span class="keyword">null</span> &amp;&amp; root.val &lt;= root.left.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.right != <span class="keyword">null</span> &amp;&amp; root.val &gt;= root.right.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isValidBST(root.left)</span><br><span class="line">        &amp;&amp; isValidBST(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这个算法出现了错误，BST 的每个节点应该要小于右边子树的所有节点，下面这个二叉树显然不是 BST，但是我们的算法会把它判定为 BST。</p>
<img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/image-20210415235003914.png" alt="image-20210415235003914" style="zoom:50%;" />

<p>我们重新看一下 BST 的定义，root 需要做的不只是和左右子节点比较，而是要整个左子树和右子树所有节点比较。怎么办，鞭长莫及啊！</p>
<p>这种情况，我们可以使用辅助函数，增加函数参数列表，在参数中携带额外信息，请看正确的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isValidBST(root, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root, TreeNode min, TreeNode max)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (min != <span class="keyword">null</span> &amp;&amp; root.val &lt;= min.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (max != <span class="keyword">null</span> &amp;&amp; root.val &gt;= max.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> isValidBST(root.left, min, root) </span><br><span class="line">        &amp;&amp; isValidBST(root.right, root, max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="一、在-BST-中查找一个数是否存在"><a href="#一、在-BST-中查找一个数是否存在" class="headerlink" title="一、在 BST 中查找一个数是否存在"></a><strong>一、在 BST 中查找一个数是否存在</strong></h1><p>根据我们的指导思想，可以这样写代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isInBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.val == target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isInBST(root.left, target)</span><br><span class="line">        || isInBST(root.right, target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>考虑一点细节问题：如何充分利用信息，把 BST 这个“左小右大”的特性用上？</p>
<p>很简单，其实不需要递归地搜索两边，类似二分查找思想，根据 target 和 root.val 的大小比较，就能排除一边。我们把上面的思路稍稍改动：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isInBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.val == target)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.val &lt; target) </span><br><span class="line">        <span class="keyword">return</span> isInBST(root.right, target);</span><br><span class="line">    <span class="keyword">if</span> (root.val &gt; target)</span><br><span class="line">        <span class="keyword">return</span> isInBST(root.left, target);</span><br><span class="line">    <span class="comment">// root 该做的事做完了，顺带把框架也完成了，妙</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>于是，我们对原始框架进行改造，抽象出一套<strong>针对 BST 的遍历框架</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BST</span><span class="params">(TreeNode root, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root.val == target)</span><br><span class="line">        <span class="comment">// 找到目标，做点什么</span></span><br><span class="line">    <span class="keyword">if</span> (root.val &lt; target) </span><br><span class="line">        BST(root.right, target);</span><br><span class="line">    <span class="keyword">if</span> (root.val &gt; target)</span><br><span class="line">        BST(root.left, target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二、在-BST-中插入一个数"><a href="#二、在-BST-中插入一个数" class="headerlink" title="二、在 BST 中插入一个数"></a><strong>二、在 BST 中插入一个数</strong></h1><p>对数据结构的操作无非遍历 + 访问，遍历就是“找”，访问就是“改”。具体到这个问题，插入一个数，就是先找到插入位置，然后进行插入操作。</p>
<p>上一个问题，我们总结了 BST 中的遍历框架，就是“找”的问题。直接套框架，加上“改”的操作即可。一旦涉及“改”，函数就要返回 TreeNode 类型，并且对递归调用的返回值进行接收。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode <span class="title">insertIntoBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 找到空位置插入新节点</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">    <span class="comment">// if (root.val == val)</span></span><br><span class="line">    <span class="comment">// BST 中一般不会插入已存在元素</span></span><br><span class="line">    <span class="keyword">if</span> (root.val &lt; val) </span><br><span class="line">        root.right = insertIntoBST(root.right, val);</span><br><span class="line">    <span class="keyword">if</span> (root.val &gt; val) </span><br><span class="line">        root.left = insertIntoBST(root.left, val);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="三、在-BST-中删除一个数"><a href="#三、在-BST-中删除一个数" class="headerlink" title="三、在 BST 中删除一个数"></a><strong>三、在 BST 中删除一个数</strong></h1><p>跟插入操作类似，先“找”再“改”，先把框架写出来再说：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode <span class="title">deleteNode</span><span class="params">(TreeNode root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root.val == key) &#123;</span><br><span class="line">        <span class="comment">// 找到啦，进行删除</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &gt; key) &#123;</span><br><span class="line">        root.left = deleteNode(root.left, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &lt; key) &#123;</span><br><span class="line">        root.right = deleteNode(root.right, key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>找到目标节点了，比方说是节点 A，如何删除这个节点，这是难点。因为删除节点的同时不能破坏 BST 的性质。有三种情况，用图片来说明。</p>
<p>情况 1：A 恰好是末端节点，两个子节点都为空，那么它可以当场去世了。</p>
<p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/image-20210416100602157.png" alt="image-20210416100602157"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<p>情况 2：A 只有一个非空子节点，那么它要让这个孩子接替自己的位置。</p>
<p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/image-20210416100653318.png" alt="image-20210416100653318"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 排除了情况 1 之后</span></span><br><span class="line"><span class="keyword">if</span> (root.left == <span class="keyword">null</span>) <span class="keyword">return</span> root.right;</span><br><span class="line"><span class="keyword">if</span> (root.right == <span class="keyword">null</span>) <span class="keyword">return</span> root.left;</span><br></pre></td></tr></table></figure>

<p>情况 3：A 有两个子节点，麻烦了，为了不破坏 BST 的性质，A 必须找到左子树中最大的那个节点，或者右子树中最小的那个节点来接替自己。我们以第二种方式讲解。</p>
<p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/image-20210416100825031.png" alt="image-20210416100825031"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (root.left != <span class="keyword">null</span> &amp;&amp; root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 找到右子树的最小节点</span></span><br><span class="line">    TreeNode minNode = getMin(root.right);</span><br><span class="line">    <span class="comment">// 把 root 改成 minNode</span></span><br><span class="line">    root.val = minNode.val;</span><br><span class="line">    <span class="comment">// 转而去删除 minNode</span></span><br><span class="line">    root.right = deleteNode(root.right, minNode.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>三种情况分析完毕，填入框架，简化一下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode <span class="title">deleteNode</span><span class="params">(TreeNode root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.val == key) &#123;</span><br><span class="line">        <span class="comment">// 这两个 if 把情况 1 和 2 都正确处理了</span></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span>) <span class="keyword">return</span> root.right;</span><br><span class="line">        <span class="keyword">if</span> (root.right == <span class="keyword">null</span>) <span class="keyword">return</span> root.left;</span><br><span class="line">        <span class="comment">// 处理情况 3</span></span><br><span class="line">        TreeNode minNode = getMin(root.right);</span><br><span class="line">        root.val = minNode.val;</span><br><span class="line">        root.right = deleteNode(root.right, minNode.val);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &gt; key) &#123;</span><br><span class="line">        root.left = deleteNode(root.left, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &lt; key) &#123;</span><br><span class="line">        root.right = deleteNode(root.right, key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode <span class="title">getMin</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// BST 最左边的就是最小的</span></span><br><span class="line">    <span class="keyword">while</span> (node.left != <span class="keyword">null</span>) node = node.left;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除操作就完成了。注意一下，这个删除操作并不完美，因为我们一般不会通过 root.val = minNode.val 修改节点内部的值来交换节点，而是通过一系列略微复杂的链表操作交换 root 和 minNode 两个节点。因为具体应用中，val 域可能会很大，修改起来很耗时，而链表操作无非改一改指针，而不会去碰内部数据。</p>
<h1 id="四、最后总结"><a href="#四、最后总结" class="headerlink" title="四、最后总结"></a><strong>四、最后总结</strong></h1><p>通过这篇文章，你学会了如下几个技巧：</p>
<p>二叉树算法设计的总路线：把当前节点要做的事做好，其他的交给递归框架，不用当前节点操心。</p>
<p>如果当前节点会对下面的子节点有整体影响，可以通过辅助函数增长参数列表，借助参数传递信息。</p>
<p>在二叉树框架之上，扩展出一套 BST 遍历框架：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BST</span><span class="params">(TreeNode root, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root.val == target)</span><br><span class="line">        <span class="comment">// 找到目标，做点什么</span></span><br><span class="line">    <span class="keyword">if</span> (root.val &lt; target) </span><br><span class="line">        BST(root.right, target);</span><br><span class="line">    <span class="keyword">if</span> (root.val &gt; target)</span><br><span class="line">        BST(root.left, target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="五、LeetCode相关题目"><a href="#五、LeetCode相关题目" class="headerlink" title="五、LeetCode相关题目"></a>五、LeetCode相关题目</h1><h2 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100.相同的树"></a>100.<a href="https://leetcode-cn.com/problems/same-tree/">相同的树</a></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">题目描述：</span><br><span class="line">    给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。</span><br><span class="line">    如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</span><br></pre></td></tr></table></figure>

<img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/image-20210416154540531.png" alt="image-20210416154540531"  />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">题解：</span><br><span class="line"><span class="comment">//如果两个二叉树都为空，则两个二叉树相同。如果两个二叉树中有且只有一个为空，则两个二叉树一定不相同。</span></span><br><span class="line"><span class="comment">//如果两个二叉树都不为空，那么首先判断它们的根节点的值是否相同，若不相同则两个二叉树一定不同，若相同，再分别判断两个二叉树的左子树是否相同以及右子树是否相同。这是一个递归的过程，因此可以使用深度优先搜索，递归地判断两个二叉树是否相同。</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p == <span class="keyword">null</span> || q == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.val != q.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101.对称二叉树"></a>101.<a href="https://leetcode-cn.com/problems/symmetric-tree/">对称二叉树</a></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">题目描述：</span><br><span class="line">    给定一个二叉树，检查它是否是镜像对称的。</span><br><span class="line">    例如，二叉树 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">3</span>] 是对称的。</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/image-20210416162740232.png" alt="image-20210416162740232"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">题解：</span><br><span class="line">    <span class="comment">//指定两个节点 p 和 q 都同时指向根节点，当 p 往左子节点遍历时 q 就往右子节点遍历，然后判断 p.val 和 q.val 是否相同，如果值不同或者 p、q 不同时为空的话则树不是镜像对称的。</span></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> check(root,root);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(TreeNode p,TreeNode q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span> || q == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p.val == q.val &amp;&amp; check(p.left,q.right) &amp;&amp; check(p.right,q.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104.二叉树的最大深度"></a>104.<a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">二叉树的最大深度</a></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">题目描述：</span><br><span class="line">    给定一个二叉树，找出其最大深度。</span><br><span class="line">    二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</span><br><span class="line">    说明: 叶子节点是指没有子节点的节点。</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">给定二叉树 [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="number">15</span>,<span class="number">7</span>]，</span><br><span class="line"></span><br><span class="line">    <span class="number">3</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">9</span>  <span class="number">20</span></span><br><span class="line">    /  \</span><br><span class="line">   <span class="number">15</span>   <span class="number">7</span></span><br><span class="line">返回它的最大深度 <span class="number">3</span> 。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">题解：</span><br><span class="line"> <span class="comment">//给定一颗二叉树的根节点求二叉树的最大深度，其最大深度 = max(左子树的深度，右子树的深度) +1</span></span><br><span class="line"> <span class="comment">//同样，左右子树的最大深度也可以用同样的方法来求，故可以使用递归的思想来解决这道题。</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> leftDepth = maxDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> rightDepth = maxDepth(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(leftDepth , rightDepth) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="108-将有序数组转存为搜索二叉树"><a href="#108-将有序数组转存为搜索二叉树" class="headerlink" title="108.将有序数组转存为搜索二叉树"></a>108.<a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/">将有序数组转存为搜索二叉树</a></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">题目描述：</span><br><span class="line">    给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。</span><br><span class="line">高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 <span class="number">1</span> 」的二叉树。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line">输入：nums = [-<span class="number">10</span>,-<span class="number">3</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">9</span>]</span><br><span class="line">输出：[<span class="number">0</span>,-<span class="number">3</span>,<span class="number">9</span>,-<span class="number">10</span>,<span class="keyword">null</span>,<span class="number">5</span>]</span><br><span class="line">解释：[<span class="number">0</span>,-<span class="number">10</span>,<span class="number">5</span>,<span class="keyword">null</span>,-<span class="number">3</span>,<span class="keyword">null</span>,<span class="number">9</span>] 也将被视为正确答案：</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/btree1.jpg" alt="img"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">题解：</span><br><span class="line">    <span class="comment">//二叉搜索树的中序遍历是升序序列，题目给定的数组是按照升序排序的有序数组，因此可以确保数组是二叉搜索树的中序遍历序列。</span></span><br><span class="line">    <span class="comment">//直观地看，我们可以选择中间数字作为二叉搜索树的根节点，这样分给左右子树的数字个数相同或只相差 1，可以使得树保持平衡。如果数组长度是奇数，则根节点的选择是唯一的，如果数组长度是偶数，则可以选择中间位置左边的数字作为根节点或者选择中间位置右边的数字作为根节点，选择不同的数字作为根节点则创建的平衡二叉搜索树也是不同的。</span></span><br><span class="line">    <span class="comment">//确定平衡二叉搜索树的根节点之后，其余的数字分别位于平衡二叉搜索树的左子树和右子树中，左子树和右子树分别也是平衡二叉搜索树，因此可以通过递归的方式创建平衡二叉搜索树。</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 总是选择中间位置左边的数字作为根节点</span></span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">        root.left = helper(nums, left, mid - <span class="number">1</span>);</span><br><span class="line">        root.right = helper(nums, mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110.平衡二叉树"></a>110.<a href="https://leetcode-cn.com/problems/balanced-binary-tree/">平衡二叉树</a></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">题目描述：</span><br><span class="line">    给定一个二叉树，判断它是否是高度平衡的二叉树。</span><br><span class="line">    本题中，一棵高度平衡二叉树定义为：</span><br><span class="line">    一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 <span class="number">1</span> 。</span><br><span class="line">    示例 <span class="number">1</span>：</span><br><span class="line">    输入：root = [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">    输出：<span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/image-20210418225713427.png" alt="image-20210418225713427"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">题解：</span><br><span class="line">    <span class="comment">//这道题中的平衡二叉树的定义是：二叉树的每个节点的左右子树的高度差的绝对值不超过 11，则二叉树是平衡二叉树。根据定义，一棵二叉树是平衡二叉树，当且仅当其所有子树也都是平衡二叉树，因此可以使用递归的方式判断二叉树是不是平衡二叉树，递归的顺序可以是自顶向下或者自底向上。</span></span><br><span class="line">    <span class="comment">//自顶向下递归，对于同一个节点，函数getHeight 会被重复调用，导致时间复杂度较高。如果使用自底向上的做法，则对于每个节点，函数getHeight 只会被调用一次。</span></span><br><span class="line">    <span class="comment">//自底向上递归的做法类似于后序遍历，对于当前遍历到的节点,先递归地判断其左右子树是否平衡，再判断以当前节点为根的子树是否平衡。如果一棵子树是平衡的，则返回其高度（高度一定是非负整数），否则返回 -1−1。如果存在一棵子树不平衡，则整个二叉树一定不平衡。</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getHeight(root) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> leftHeight = getHeight(root.left);</span><br><span class="line">        <span class="keyword">int</span> rightHeight = getHeight(root.right);</span><br><span class="line">        <span class="keyword">if</span>(leftHeight == -<span class="number">1</span> || rightHeight == -<span class="number">1</span> || Math.abs(leftHeight-rightHeight) &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(leftHeight,rightHeight)+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111.二叉树的最小深度"></a>111.<a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">二叉树的最小深度</a></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">题目描述：</span><br><span class="line">    给定一个二叉树，找出其最小深度。</span><br><span class="line">    最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</span><br><span class="line">    说明：叶子节点是指没有子节点的节点。</span><br><span class="line">    输入：root = [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">    输出：<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/image-20210419230338849.png" alt="image-20210419230338849"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">题解：</span><br><span class="line">    <span class="comment">//解题关键是搞清楚递归结束条件</span></span><br><span class="line">    <span class="comment">//叶子节点的定义是左孩子和右孩子都为 null 时叫做叶子节点</span></span><br><span class="line">    <span class="comment">//当 root 节点左右孩子都为空时，返回 1</span></span><br><span class="line">    <span class="comment">//当 root 节点左右孩子有一个为空时，返回不为空的孩子节点的深度</span></span><br><span class="line">    <span class="comment">//当 root 节点左右孩子都不为空时，返回左右孩子较小深度的节点值</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> leftDepth = minDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> rightDepth = minDepth(root.right);</span><br><span class="line">        <span class="keyword">return</span> (root.left == <span class="keyword">null</span> || root.right == <span class="keyword">null</span>) ? leftDepth+rightDepth+<span class="number">1</span> : Math.min(leftDepth,rightDepth)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112.路径总和"></a>112.<a href="https://leetcode-cn.com/problems/path-sum/">路径总和</a></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">题目描述：</span><br><span class="line">    给你二叉树的根节点 root 和一个表示目标和的整数 targetSum ，判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。</span><br><span class="line">     叶子节点 是指没有子节点的节点。</span><br><span class="line">示例：输入：root = [<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">11</span>,<span class="keyword">null</span>,<span class="number">13</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="number">1</span>], targetSum = <span class="number">22</span></span><br><span class="line">     输出：<span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">题解：</span><br><span class="line">    <span class="comment">/*观察要求我们完成的函数，我们可以归纳出它的功能：询问是否存在从当前节点 root 到叶子节点的路径，满足其路径和为 sum。假定从根节点到当前节点的值之和为 val，我们可以将这个大问题转化为一个小问题：是否存在从当前节点的子节点到叶子的路径，满足其路径和为 sum - val。不难发现这满足递归的性质，若当前节点就是叶子节点，那么我们直接判断 sum 是否等于 val 即可（因为路径和已经确定，就是当前节点的值，我们只需要判断该路径和是否满足条件）。若当前节点不是叶子节点，我们只需要递归地询问它的子节点是否能满足条件即可。*/</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root.val == targetSum;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root.left , targetSum-root.val) || hasPathSum(root.right , targetSum-root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226.翻转二叉树"></a>226.<a href="https://leetcode-cn.com/problems/invert-binary-tree/">翻转二叉树</a></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">题目描述：翻转一棵二叉树。</span><br><span class="line">题解：</span><br><span class="line">    <span class="comment">/*我们在做二叉树题目时候，第一想到的应该是用 递归 来解决。</span></span><br><span class="line"><span class="comment">仔细看下题目的 输入 和 输出，输出的左右子树的位置跟输入正好是相反的，于是我们可以递归的交换左右子树来完成这道题。</span></span><br><span class="line"><span class="comment">其实就是交换一下左右节点，然后再递归的交换左节点，右节点</span></span><br><span class="line"><span class="comment">总结出递归的两个条件如下：</span></span><br><span class="line"><span class="comment">   终止条件：当前节点为 null 时返回</span></span><br><span class="line"><span class="comment">   交换当前节点的左右节点，再递归的交换当前节点的左节点，递归的交换当前节点的右节点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode temp = root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = temp;</span><br><span class="line">        </span><br><span class="line">        invertTree(root.left);</span><br><span class="line">        invertTree(root.right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="235-二叉搜索树的最近公共祖先"><a href="#235-二叉搜索树的最近公共祖先" class="headerlink" title="235.二叉搜索树的最近公共祖先"></a>235.<a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">二叉搜索树的最近公共祖先</a></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">题目描述：给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</span><br><span class="line">百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">题解：</span><br><span class="line">    <span class="comment">/*我们从根节点开始遍历；</span></span><br><span class="line"><span class="comment">    如果当前节点的值大于 pp 和 qq 的值，说明 pp 和 qq 应该在当前节点的左子树，因此将当前节点移动到它的左子节点；</span></span><br><span class="line"><span class="comment">    如果当前节点的值小于 pp 和 qq 的值，说明 pp 和 qq 应该在当前节点的右子树，因此将当前节点移动到它的右子节点；</span></span><br><span class="line"><span class="comment">    如果当前节点的值不满足上述两条要求，那么说明当前节点就是「分岔点」。此时，pp 和 qq 要么在当前节点的不同的子树中，要么其中一个就是当前节点。</span></span><br><span class="line"><span class="comment">    可以发现，如果我们将这两个节点放在一起遍历，我们就省去了存储路径需要的空间。*/</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        TreeNode ancient = root;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ancient.val &gt; p.val &amp;&amp; ancient.val &gt; q.val)&#123;</span><br><span class="line">                ancient = ancient.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ancient.val &lt; p.val &amp;&amp; ancient.val &lt; q.val)&#123;</span><br><span class="line">                ancient = ancient.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ancient;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="404-左叶子之和"><a href="#404-左叶子之和" class="headerlink" title="404.左叶子之和"></a>404.<a href="https://leetcode-cn.com/problems/sum-of-left-leaves/">左叶子之和</a></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">题目描述：</span><br><span class="line">    计算给定二叉树的所有左叶子之和。</span><br><span class="line">    <span class="number">3</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">9</span>  <span class="number">20</span></span><br><span class="line">    /  \</span><br><span class="line">   <span class="number">15</span>   <span class="number">7</span></span><br><span class="line"></span><br><span class="line">在这个二叉树中，有两个左叶子，分别是 <span class="number">9</span> 和 <span class="number">15</span>，所以返回 <span class="number">24</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">题解：</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    一个节点为「左叶子」节点，当且仅当它是某个节点的左子节点，并且它是一个叶子结点。因此我们可以考虑对整棵树进行遍历，当我们遍历到节点 \textit&#123;node&#125;node 时，如果它的左子节点是一个叶子结点，那么就将它的左子节点的值累加计入答案。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root != <span class="keyword">null</span> ? dfs(root) : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            res += isLeafNode(node.left) ? node.left.val : dfs(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.right != <span class="keyword">null</span> &amp;&amp; !isLeafNode(node.right))&#123;</span><br><span class="line">            res += dfs(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLeafNode</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> node.left == <span class="keyword">null</span> &amp;&amp; node.right == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis 学习（一）</title>
    <url>/2021/09/04/mybatis%E7%AC%94%E8%AE%B0(%E4%B8%80)/</url>
    <content><![CDATA[<h3 id="1-Mybatis简介"><a href="#1-Mybatis简介" class="headerlink" title="1.Mybatis简介"></a>1.Mybatis简介</h3><h4 id="1-1原始jdbc操作（查询数据）"><a href="#1-1原始jdbc操作（查询数据）" class="headerlink" title="1.1原始jdbc操作（查询数据）"></a>1.1原始jdbc操作（查询数据）</h4><p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/%E5%9B%BE%E7%89%871.png"></p>
<h4 id="1-2原始jdbc操作（插入数据）"><a href="#1-2原始jdbc操作（插入数据）" class="headerlink" title="1.2原始jdbc操作（插入数据）"></a>1.2原始jdbc操作（插入数据）</h4><span id="more"></span>

<p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/%E5%9B%BE%E7%89%872.png"></p>
<h4 id="1-3-原始jdbc操作的分析"><a href="#1-3-原始jdbc操作的分析" class="headerlink" title="1.3 原始jdbc操作的分析"></a>1.3 原始jdbc操作的分析</h4><p>原始jdbc开发存在的问题如下：</p>
<p>①数据库连接创建、释放频繁造成系统资源浪费从而影响系统性能</p>
<p>②sql 语句在代码中硬编码，造成代码不易维护，实际应用 sql 变化的可能较大，sql 变动需要改变java代码。</p>
<p>③查询操作时，需要手动将结果集中的数据手动封装到实体中。插入操作时，需要手动将实体的数据设置到sql语句的占位符位置</p>
<p>应对上述问题给出的解决方案：</p>
<p>①使用数据库连接池初始化连接资源</p>
<p>②将sql语句抽取到xml配置文件中</p>
<p>③使用反射、内省等底层技术，自动将实体与表进行属性与字段的自动映射</p>
<h4 id="1-4-什么是Mybatis"><a href="#1-4-什么是Mybatis" class="headerlink" title="1.4 什么是Mybatis"></a>1.4 什么是Mybatis</h4><p>mybatis 是一个优秀的基于java的持久层框架，它内部封装了jdbc，使开发者只需要关注sql语句本身，而不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。</p>
<p>mybatis通过xml或注解的方式将要执行的各种 statement配置起来，并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句。</p>
<p>最后mybatis框架执行sql并将结果映射为java对象并返回。采用<strong>ORM思想</strong>(对象关系映射（Object Relational Mapping))解决了实体和数据库映射的问题，对jdbc 进行了封装，屏蔽了jdbc API 底层访问细节，使我们不用与jdbc API 打交道，就可以完成对数据库的持久化操作。</p>
<h5 id="ORM思想"><a href="#ORM思想" class="headerlink" title="ORM思想"></a>ORM思想</h5><p>**O(对象模型)**：实体对象，即我们在程序中根据数据库表结构建立的一个个实体Entity。</p>
<p>**R(关系型数据库的数据结构)**：即我们建立的数据库表。</p>
<p>**M(映射)**：从 R(数据库) 到 O(对象模型) 的映射，可通过XML文件映射。</p>
<p><strong>为什么使用ORM？</strong>提高开发效率：ORM框架自动实现Entity实体的属性与关系型数据库字段的映射。CRUD的工作则可以交给ORM来自动生成代码方式实现。隐藏了数据访问细节，“封闭”的通用数据库交互，他使得我们的通用数据库交互变得简单易行，并且完全不用考虑SQL语句。大大提高我们开发效率， 这样一来也减少我们维护一个复杂 缺乏灵活性数据访问层的成本。</p>
<p>ORM作为是一种思想，帮助我们开发人员跟踪实体的变化,并将实体的变化翻译成sql脚本,执行到数据库中去,也就是将实体的变化映射到了表的变化。这样会给我们带来非常大的便利。但有得必有失，便利的同时也无可避免的带来了一些其他的问题：比如性能降低，复杂的查询ORM仍然力不从心等。</p>
<h3 id="2-Mybatis的快速入门"><a href="#2-Mybatis的快速入门" class="headerlink" title="2.Mybatis的快速入门"></a>2.Mybatis的快速入门</h3><h4 id="2-1-MyBatis开发步骤"><a href="#2-1-MyBatis开发步骤" class="headerlink" title="2.1 MyBatis开发步骤"></a>2.1 MyBatis开发步骤</h4><p>MyBatis官网地址：<a href="http://www.mybatis.org/mybatis-3/">http://www.mybatis.org/mybatis-3/</a> </p>
<p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/%E5%9B%BE%E7%89%873.png"></p>
<p><strong>MyBatis开发步骤：</strong></p>
<p>①添加MyBatis的坐标</p>
<p>②创建user数据表</p>
<p>③编写User实体类 </p>
<p>④编写映射文件UserMapper.xml</p>
<p>⑤编写核心文件SqlMapConfig.xml</p>
<p>⑥编写测试类</p>
<h4 id="2-2-环境搭建"><a href="#2-2-环境搭建" class="headerlink" title="2.2 环境搭建"></a>2.2 环境搭建</h4><p>1)导入 MyBatis 的坐标和其他相关坐标</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--mybatis坐标--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--compile：默认值 他表示被依赖项目需要参与当前项目的编译，还有后续的测试，运行周期也参与                  其中，是一个比较强的依赖。打包的时候通常需要包含进去--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--mysql驱动坐标--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--runtime：表示被依赖项目无需参与项目的编译，不过后期的测试和运行周期需要其参与。与                      compile相比，跳过了编译而已。例如JDBC驱动，适用运行和测试阶段--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--单元测试坐标--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--test：依赖项目仅仅参与测试相关的工作，包括测试代码的编译和执行，不会被打包，例如：                   junit--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--日志坐标--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li> 创建user数据表</li>
</ol>
<p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/%E5%9B%BE%E7%89%875.png"></p>
<ol start="3">
<li>编写User实体</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;    </span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> id;    </span><br><span class="line">	<span class="keyword">private</span> String username;    </span><br><span class="line">	<span class="keyword">private</span> String password;</span><br><span class="line">    <span class="comment">//省略get和set方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4)编写UserMapper映射文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span>        </span></span><br><span class="line"><span class="meta">	<span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span>        </span></span><br><span class="line"><span class="meta">	<span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- mapper 为根元素节点， 一个 namespace 对应一个 dao --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;userMapper&quot;</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- 1. id （必须配置）</span></span><br><span class="line"><span class="comment">        id是命名空间中的唯一标识符，可被用来代表这条语句。 </span></span><br><span class="line"><span class="comment">        一个命名空间（namespace） 对应一个 dao 接口, </span></span><br><span class="line"><span class="comment">        这个 id 也应该对应 dao 里面的某个方法（相当于方法的实现），</span></span><br><span class="line"><span class="comment">        因此 id 应该与方法名一致--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 2.resultType  </span></span><br><span class="line"><span class="comment">        指定 resultType 返回值类型是 User 类型的，</span></span><br><span class="line"><span class="comment">        只需要指定 resultType 的类型，MyBatis 会自动将查询的结果</span></span><br><span class="line"><span class="comment">        映射成 JavaBean 中的属性。</span></span><br><span class="line"><span class="comment">        对于resultType=&quot;string&quot;</span></span><br><span class="line"><span class="comment">        string 在这里是一个别名，代表的是 java.lang.String </span></span><br><span class="line"><span class="comment">        对于引用数据类型，都是将大写字母转小写，</span></span><br><span class="line"><span class="comment">        比如 HashMap 对应的别名是 &#x27;hashmap&#x27;</span></span><br><span class="line"><span class="comment">        基本数据类型考虑到重复的问题，</span></span><br><span class="line"><span class="comment">        会在其前面加上 &#x27;_&#x27;，比如 byte 对应的别名是 &#x27;_byte&#x27;</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.itheima.domain.User&quot;</span>&gt;</span>        </span><br><span class="line">		select * from User    </span><br><span class="line">	<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>编写MyBatis核心文件</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN“ &quot;</span>http://mybatis.org/dtd/mybatis-3-config.dtd<span class="meta-string">&quot;&gt;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&lt;configuration&gt;    </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	&lt;environments default=&quot;</span>development<span class="meta-string">&quot;&gt;        </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		&lt;environment id=&quot;</span>development<span class="meta-string">&quot;&gt;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        &lt;!--事务管理器 transactionManager</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">           在 MyBatis 中有两种类型的事务管理器</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">          （也就是 type=”[JDBC|MANAGED]”）：</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">           1.JDBC -- 这个配置就是直接使用了 JDBC 的提交和回滚设置，</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">           它依赖于从数据源得到的连接来管理事务作用域。</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">           2.MANAGED – 这个配置几乎没做什么。</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">           它从来不提交或回滚一个连接，</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">           而是让容器来管理事务的整个生命周期（比如 JEE 应用服务器的上下文）。 </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">           默认情况下它会关闭连接，然而一些容器并不希望这样，</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">           因此需要将 closeConnection 属性设置为 false 来阻止它默认的关闭行为。</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">           提示：如果使用 Spring + MyBatis，则没有必要配置事务管理器， </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">           因为 Spring 模块会使用自带的管理器来覆盖前面的配置。</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        --&gt;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			&lt;transactionManager type=&quot;</span>JDBC<span class="meta-string">&quot;/&gt;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        &lt;!--  数据源 dataSource 元素使用标准的 JDBC 数据源接口</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">              来配置 JDBC 连接对象的资源。</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">              许多 MyBatis 的应用程序会按示例中的例子来配置数据源。</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">              虽然这是可选的，但为了使用延迟加载，数据源是必须配置的。</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">              有三种内建的数据源类型（也就是 type=”[UNPOOLED|POOLED|JNDI]”）：</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">              POOLED– 这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来，</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">              避免了创建新的连接实例时所必需的初始化和认证时间。 </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">              这是一种使得并发 Web 应用快速响应请求的流行处理方式。</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">              POOLED 属性：</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">              driver – 这是 JDBC 驱动的 Java 类的完全限定名（并不是 JDBC 驱动中可能包含的                        数据源类）。</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">              url – 这是数据库的 JDBC URL 地址。</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">              username – 登录数据库的用户名。</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">              password – 登录数据库的密码。</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">              defaultTransactionIsolationLevel – 默认的连接事务隔离级别。</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">              poolMaximumActiveConnections – 在任意时间可以存在的活动（也就是正在使用）                                              连接数量，默认值：10</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">              poolMaximumIdleConnections – 任意时间可能存在的空闲连接数。</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">              poolMaximumCheckoutTime – 在被强制返回之前，池中连接被检出（checked out）                                         时间，默认值：20000 毫秒（即 20 秒）</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">              poolTimeToWait – 这是一个底层设置，如果获取连接花费了相当长的时间，连接池会打                                印状态日志并重新尝试获取一个连接（避免在误配置的情况下一直安                                静的失败），默认值：20000 毫秒（即 20 秒）。</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">              poolMaximumLocalBadConnectionTolerance – 这是一个关于坏连接容忍度的底层                                设置， 作用于每一个尝试从缓存池获取连接的线程. 如果这个线程                                获取到的是一个坏的连接，那么这个数据源允许这个线程尝试重新获                                取一个新的连接，默认值：3 (新增于 3.4.5)</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">              poolPingQuery – 发送到数据库的侦测查询，用来检验连接是否正常工作并准备接受请                               求。默认是“NO PING QUERY SET”，这会导致多数数据库驱动失败                               时带有一个恰当的错误消息。</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">              poolPingEnabled – 是否启用侦测查询。若开启，需要设置 poolPingQuery 属性为                                 一个可执行的 SQL 语句（最好是一个速度非常快的 SQL 语                                     句），默认值：false。</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">              poolPingConnectionsNotUsedFor – 配置 poolPingQuery 的频率。可以被设置                               为和数据库连接超时时间一样，来避免不必要的侦测，默认值：0</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">              （即所有连接每一时刻都被侦测 — 当然仅当 poolPingEnabled 为 true 时适用）。</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">        --&gt;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			&lt;dataSource type=&quot;</span>POOLED<span class="meta-string">&quot;&gt;                </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">				&lt;property name=&quot;</span>driver<span class="meta-string">&quot; value=&quot;</span>com.mysql.jdbc.Driver<span class="meta-string">&quot;/&gt;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">				&lt;property name=&quot;</span>url<span class="meta-string">&quot; value=&quot;</span>jdbc:mysql:///test<span class="meta-string">&quot;/&gt;                </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">				&lt;property name=&quot;</span>username<span class="meta-string">&quot; value=&quot;</span>root<span class="meta-string">&quot;/&gt;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">				&lt;property name=&quot;</span>password<span class="meta-string">&quot; value=&quot;</span>root<span class="meta-string">&quot;/&gt;            </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">			&lt;/dataSource&gt;        </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		&lt;/environment&gt;    </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	&lt;/environments&gt;    </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	&lt;mappers&gt; </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">		&lt;mapper resource=&quot;</span>com/itheima/mapper/UserMapper.xml<span class="meta-string">&quot;/&gt; </span></span></span><br><span class="line"><span class="meta-string"><span class="meta">	&lt;/mappers&gt;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">&lt;/configuration&gt;</span></span></span><br><span class="line"><span class="meta-string"><span class="meta"></span></span></span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li><font color ='red'>默认的环境 ID（比如:default=”development”）</font>。</li>
<li><font color ='red'>每个 environment 元素定义的环境 ID（比如:id=”development”）</font>。</li>
<li><font color ='red'>事务管理器的配置（比如:type=”JDBC”）</font>。</li>
<li><font color ='red'>数据源的配置（比如:type=”POOLED”）</font>。</li>
</ul>
<p>默认的环境和环境 ID 是自解释的，因此一目了然。可以对环境随意命名，<font color ='red'>但一定要保证默认的环境 ID 要匹配其中一个环境 ID</font>。</p>
<h4 id="2-3-编写测试代码"><a href="#2-3-编写测试代码" class="headerlink" title="2.3 编写测试代码"></a>2.3 编写测试代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加载核心配置文件</span></span><br><span class="line">InputStream resourceAsStream = Resources.getResourceAsStream(<span class="string">&quot;SqlMapConfig.xml&quot;</span>);</span><br><span class="line"><span class="comment">//获得 sqlSession 工厂对象</span></span><br><span class="line">SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span>            </span><br><span class="line">                           SqlSessionFactoryBuilder().build(resourceAsStream);</span><br><span class="line"><span class="comment">//获得 sqlSession 对象</span></span><br><span class="line">SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line"><span class="comment">//执行 sql 语句</span></span><br><span class="line">List&lt;User&gt; userList = sqlSession.selectList(<span class="string">&quot;userMapper.findAll&quot;</span>);</span><br><span class="line"><span class="comment">//打印结果</span></span><br><span class="line">System.out.println(userList);</span><br><span class="line"><span class="comment">//释放资源</span></span><br><span class="line">sqlSession.close();</span><br></pre></td></tr></table></figure>

<h4 id="2-4-小结"><a href="#2-4-小结" class="headerlink" title="2.4 小结"></a>2.4 小结</h4><p><strong>MyBatis开发步骤：</strong></p>
<p>①添加MyBatis的坐标</p>
<p>②创建user数据表</p>
<p>③编写User实体类 </p>
<p>④编写映射文件UserMapper.xml</p>
<p>⑤编写核心文件SqlMapConfig.xml</p>
<p>⑥编写测试类</p>
<h3 id="3-MyBatis的映射文件概述"><a href="#3-MyBatis的映射文件概述" class="headerlink" title="3. MyBatis的映射文件概述"></a>3. MyBatis的映射文件概述</h3><p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/%E5%9B%BE%E7%89%876.png"></p>
<h3 id="4-MyBatis的增删改查操作"><a href="#4-MyBatis的增删改查操作" class="headerlink" title="4. MyBatis的增删改查操作"></a>4. MyBatis的增删改查操作</h3><h4 id="4-1-MyBatis的插入数据操作"><a href="#4-1-MyBatis的插入数据操作" class="headerlink" title="4.1 MyBatis的插入数据操作"></a>4.1 MyBatis的插入数据操作</h4><p><strong>1)编写UserMapper映射文件</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;userMapper&quot;</span>&gt;</span>    </span><br><span class="line">	<span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;add&quot;</span> <span class="attr">parameterType</span> = <span class="string">&quot; com.itheima.domain.User &quot;</span>&gt;</span>        </span><br><span class="line">		insert into user values(#&#123;id&#125;,#&#123;username&#125;,#&#123;password&#125;)    </span><br><span class="line">	<span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>2)编写插入实体User的代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStream resourceAsStream = Resources.getResourceAsStream(<span class="string">&quot;SqlMapConfig.xml&quot;</span>);</span><br><span class="line">SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> </span><br><span class="line">                        SqlSessionFactoryBuilder().build(resourceAsStream);</span><br><span class="line">SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line"><span class="keyword">int</span> insert = sqlSession.insert(<span class="string">&quot;userMapper.add&quot;</span>, user);</span><br><span class="line">System.out.println(insert);</span><br><span class="line"><span class="comment">//提交事务</span></span><br><span class="line">sqlSession.commit();</span><br><span class="line">sqlSession.close();</span><br></pre></td></tr></table></figure>

<p><strong>3)插入操作注意问题</strong></p>
<p>• 插入语句使用insert标签</p>
<p>• 在映射文件中使用 parameterType 属性指定要插入的数据类型</p>
<p>• Sql 语句中使用#{实体属性名}方式引用实体中的属性值</p>
<p>• 插入操作使用的 API 是 sqlSession.insert(“命名空间.id”,实体对象);</p>
<p>• 插入操作涉及数据库数据变化，所以要使用 sqlSession 对象显示的提交事务，即 sqlSession.commit() </p>
<h4 id="4-2-MyBatis的修改数据操作"><a href="#4-2-MyBatis的修改数据操作" class="headerlink" title="4.2 MyBatis的修改数据操作"></a>4.2 MyBatis的修改数据操作</h4><p><strong>1)编写UserMapper映射文件</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;userMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;update&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.itheima.domain.User&quot;</span>&gt;</span></span><br><span class="line">        update user set username=#&#123;username&#125;,password=#&#123;password&#125; where id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>2)编写修改实体User的代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStream resourceAsStream =                                                                          Resources.getResourceAsStream(<span class="string">&quot;SqlMapConfig.xml&quot;</span>);</span><br><span class="line">SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span>                                                              SqlSessionFactoryBuilder().build(resourceAsStream);</span><br><span class="line">SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line"><span class="keyword">int</span> update = sqlSession.update(<span class="string">&quot;userMapper.update&quot;</span>, user);</span><br><span class="line">System.out.println(update);</span><br><span class="line">sqlSession.commit();</span><br><span class="line">sqlSession.close();</span><br></pre></td></tr></table></figure>

<p><strong>3)修改操作注意问题</strong></p>
<p>• 修改语句使用 update 标签</p>
<p>• 修改操作使用的API是sqlSession.update(“命名空间.id”,实体对象);</p>
<h4 id="4-3-MyBatis的删除数据操作"><a href="#4-3-MyBatis的删除数据操作" class="headerlink" title="4.3 MyBatis的删除数据操作"></a>4.3 MyBatis的删除数据操作</h4><p><strong>1)编写UserMapper映射文件</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;userMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;delete&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.lang.Integer&quot;</span>&gt;</span></span><br><span class="line">        delete from user where id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>2)编写删除数据的代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStream resourceAsStream = Resources.getResourceAsStream(<span class="string">&quot;SqlMapConfig.xml&quot;</span>);</span><br><span class="line">SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(resourceAsStream);</span><br><span class="line">SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line"><span class="keyword">int</span> delete = sqlSession.delete(<span class="string">&quot;userMapper.delete&quot;</span>,<span class="number">3</span>);</span><br><span class="line">System.out.println(delete);</span><br><span class="line">sqlSession.commit();</span><br><span class="line">sqlSession.close();</span><br></pre></td></tr></table></figure>

<p><strong>3)删除操作注意问题</strong></p>
<p>• 删除语句使用delete标签</p>
<p>•Sql语句中使用#{任意字符串}方式引用传递的单个参数</p>
<p>•删除操作使用的API是sqlSession.delete(“命名空间.id”,Object);</p>
<h4 id="4-4-知识小结"><a href="#4-4-知识小结" class="headerlink" title="4.4 知识小结"></a>4.4 知识小结</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">增删改查映射配置与API：</span><br><span class="line">查询数据： List&lt;User&gt; userList = sqlSession.selectList(<span class="string">&quot;userMapper.findAll&quot;</span>);</span><br><span class="line">         &lt;select id=<span class="string">&quot;findAll&quot;</span> resultType=<span class="string">&quot;com.itheima.domain.User&quot;</span>&gt;</span><br><span class="line">                select * from User</span><br><span class="line">         &lt;/select&gt;</span><br><span class="line">添加数据： sqlSession.insert(<span class="string">&quot;userMapper.add&quot;</span>, user);</span><br><span class="line">         &lt;insert id=<span class="string">&quot;add&quot;</span> parameterType=<span class="string">&quot;com.itheima.domain.User&quot;</span>&gt;</span><br><span class="line">             <span class="function">insert into user <span class="title">values</span><span class="params">(#&#123;id&#125;,#&#123;username&#125;,#&#123;password&#125;)</span></span></span><br><span class="line"><span class="function">         &lt;/insert&gt;</span></span><br><span class="line"><span class="function">修改数据： sqlSession.<span class="title">update</span><span class="params">(<span class="string">&quot;userMapper.update&quot;</span>, user)</span></span>;</span><br><span class="line">         &lt;update id=<span class="string">&quot;update&quot;</span> parameterType=<span class="string">&quot;com.itheima.domain.User&quot;</span>&gt;</span><br><span class="line">               update user set username=#&#123;username&#125;,password=#&#123;password&#125; where                                           id=#&#123;id&#125;</span><br><span class="line">         &lt;/update&gt;</span><br><span class="line">删除数据：sqlSession.delete(<span class="string">&quot;userMapper.delete&quot;</span>,<span class="number">3</span>);</span><br><span class="line">        &lt;delete id=<span class="string">&quot;delete&quot;</span> parameterType=<span class="string">&quot;java.lang.Integer&quot;</span>&gt;</span><br><span class="line">             delete from user where id=#&#123;id&#125;</span><br><span class="line">        &lt;/delete&gt;</span><br></pre></td></tr></table></figure>

<h3 id="5-MyBatis核心配置文件概述"><a href="#5-MyBatis核心配置文件概述" class="headerlink" title="5. MyBatis核心配置文件概述"></a>5. MyBatis核心配置文件概述</h3><h4 id="5-1-MyBatis核心配置文件层级关系"><a href="#5-1-MyBatis核心配置文件层级关系" class="headerlink" title="5.1 MyBatis核心配置文件层级关系"></a>5.1 MyBatis核心配置文件层级关系</h4><p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/%E5%9B%BE%E7%89%877.png"></p>
<h4 id="5-2-MyBatis常用配置解析"><a href="#5-2-MyBatis常用配置解析" class="headerlink" title="5.2 MyBatis常用配置解析"></a>5.2 MyBatis常用配置解析</h4><p><strong>1)environments标签</strong></p>
<p>数据库环境的配置，支持多环境配置</p>
<p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/%E5%9B%BE%E7%89%878.png"></p>
<p>其中，事务管理器（transactionManager）类型有两种：</p>
<p>•JDBC：这个配置就是直接使用了JDBC 的提交和回滚设置，它依赖于从数据源得到的连接来管理事务作用域。</p>
<p>•MANAGED：这个配置几乎没做什么。它从来不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（比如 JEE 应用服务器的上下文）。 默认情况下它会关闭连接，然而一些容器并不希望这样，因此需要将 closeConnection 属性设置为 false 来阻止它默认的关闭行为。</p>
<p>其中，数据源（dataSource）类型有三种：</p>
<p>• UNPOOLED：这个数据源的实现只是每次被请求时打开和关闭连接。</p>
<p>• POOLED：这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来。</p>
<p>• JNDI：这个数据源的实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的引用。</p>
<p><strong>2)mapper标签</strong></p>
<p>该标签的作用是加载映射的，加载方式有如下几种：</p>
<p>• 使用相对于类路径的资源引用，例如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/mybatis/builder/AuthorMapper.xml&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>• 使用完全限定资源定位符（URL），例如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">url</span>=<span class="string">&quot;file:///var/mappers/AuthorMapper.xml&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>• 使用映射器接口实现类的完全限定类名，例如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.builder.AuthorMapper&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>• 将包内的映射器接口实现全部注册为映射器，例如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;org.mybatis.builder&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>3)Properties标签</strong></p>
<p>实际开发中，习惯将数据源的配置信息单独抽取成一个properties文件，该标签可以加载额外配置的properties文件。</p>
<p>  <img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/%E5%9B%BE%E7%89%879.png"></p>
<p><strong>4)typeAliases标签</strong></p>
<p>类型别名是为Java 类型设置一个短的名字。原来的类型名称配置如下</p>
<p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/%E5%9B%BE%E7%89%8710.png"></p>
<p>配置typeAliases，为com.itheima.domain.User定义别名为user</p>
<p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/%E5%9B%BE%E7%89%8711.png"></p>
<p>上面我们是自定义的别名，mybatis框架已经为我们设置好的一些常用的类型的别名</p>
<p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/%E5%9B%BE%E7%89%8712.png"></p>
<h4 id="5-3-知识小结"><a href="#5-3-知识小结" class="headerlink" title="5.3 知识小结"></a>5.3 知识小结</h4><p><strong>核心配置文件常用配置：</strong></p>
<p>properties标签：该标签可以加载外部的properties文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;jdbc.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>typeAliases标签：设置类型别名</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">type</span>=<span class="string">&quot;com.itheima.domain.User&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;user&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">typeAlias</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>mappers标签：加载映射配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/itheima/mapper/UserMapping.xml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>environments标签：数据源环境配置标签</p>
<p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/%E5%9B%BE%E7%89%8713.png"></p>
<h3 id="6-MyBatis相应API"><a href="#6-MyBatis相应API" class="headerlink" title="6.MyBatis相应API"></a>6.MyBatis相应API</h3><h4 id="6-1-SqlSession工厂构建器SqlSessionFactoryBuilder"><a href="#6-1-SqlSession工厂构建器SqlSessionFactoryBuilder" class="headerlink" title="6.1 SqlSession工厂构建器SqlSessionFactoryBuilder"></a>6.1 SqlSession工厂构建器SqlSessionFactoryBuilder</h4><p>常用API：SqlSessionFactory  build(InputStream inputStream)</p>
<p>通过加载mybatis的核心文件的输入流的形式构建一个 SqlSessionFactory 对象</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String resource = <span class="string">&quot;org/mybatis/builder/mybatis-config.xml&quot;</span>; </span><br><span class="line">InputStream inputStream = Resources.getResourceAsStream(resource); </span><br><span class="line">SqlSessionFactoryBuilder builder = <span class="keyword">new</span> SqlSessionFactoryBuilder(); </span><br><span class="line">SqlSessionFactory factory = builder.build(inputStream);</span><br></pre></td></tr></table></figure>

<p>其中， Resources 工具类，这个类在 org.apache.ibatis.io 包中。Resources 类帮助你从类路径下、文件系统或一个 web URL 中加载资源文件。</p>
<h4 id="6-2-SqlSession工厂对象SqlSessionFactory"><a href="#6-2-SqlSession工厂对象SqlSessionFactory" class="headerlink" title="6.2 SqlSession工厂对象SqlSessionFactory"></a>6.2 SqlSession工厂对象SqlSessionFactory</h4><p>SqlSessionFactory 有多个个方法创建SqlSession 实例。常用的有如下两个：</p>
<p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/%E5%9B%BE%E7%89%8714.png" alt="1552653723002"></p>
<h4 id="6-3-SqlSession会话对象"><a href="#6-3-SqlSession会话对象" class="headerlink" title="6.3 SqlSession会话对象"></a>6.3 SqlSession会话对象</h4><p>SqlSession 实例在 MyBatis 中是非常强大的一个类。在这里你会看到所有执行语句、提交或回滚事务和获取映射器实例的方法。</p>
<p>执行语句的方法主要有：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">T <span class="title">selectOne</span><span class="params">(String statement, Object parameter)</span> </span></span><br><span class="line"><span class="function">&lt;E&gt; List&lt;E&gt; <span class="title">selectList</span><span class="params">(String statement, Object parameter)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(String statement, Object parameter)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(String statement, Object parameter)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">delete</span><span class="params">(String statement, Object parameter)</span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<p>操作事务的方法主要有：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span> </span></span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven 学习</title>
    <url>/2021/09/04/Maven%E5%9B%9E%E9%A1%BE/</url>
    <content><![CDATA[<h2 id="Maven高级"><a href="#Maven高级" class="headerlink" title="Maven高级"></a>Maven高级</h2><h2 id="1-maven基础知识回顾"><a href="#1-maven基础知识回顾" class="headerlink" title="1.maven基础知识回顾"></a>1.maven基础知识回顾</h2><h3 id="1-1-maven介绍"><a href="#1-1-maven介绍" class="headerlink" title="1.1 maven介绍"></a>1.1 maven介绍</h3><p>maven 是一个项目管理工具，主要作用是在项目开发阶段对Java项目进行依赖管理和项目构建。</p>
<p>Maven使用项目对象模型（POM-project Object Model）概念，可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工具，在Maven中每个项目都相当于是一个对象，对象（项目）和对象（项目）之间是有关系的。关系包含了：依赖、继承、聚合，实现Maven项目可以更加方便的实现导入jar包、拆包项目等结果。</p>
<span id="more"></span>

<p>依赖管理：就是对jar包的管理。通过导入maven坐标，就相当于将仓库中的jar包导入了当前项目中。</p>
<p>项目构建：通过maven的一个命令就可以完成项目从清理、编译、测试、报告、打包，部署整个过程。</p>
<p>   <img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/2as.png" alt="2as"></p>
<h3 id="1-2-maven的仓库类型"><a href="#1-2-maven的仓库类型" class="headerlink" title="1.2 maven的仓库类型"></a>1.2 maven的仓库类型</h3><p>1.本地仓库 </p>
<p>2.远程仓库</p>
<p>①maven中央仓库（地址：<a href="http://repo2.maven.org/maven2/%EF%BC%89">http://repo2.maven.org/maven2/）</a></p>
<p>②maven私服（公司局域网内的仓库，需要自己搭建）</p>
<p>③其他公共远程仓库（例如apache提供的远程仓库，地址：<a href="http://repo.maven.apache.org/maven2/%EF%BC%89">http://repo.maven.apache.org/maven2/）</a></p>
<h3 id="1-3-maven常用命令"><a href="#1-3-maven常用命令" class="headerlink" title="1.3 maven常用命令"></a>1.3 maven常用命令</h3><p>clean：     清理</p>
<p>compile：编译</p>
<p>test：        测试</p>
<p>package：打包</p>
<p>install：    安装</p>
<h3 id="1-4-maven坐标书写规范"><a href="#1-4-maven坐标书写规范" class="headerlink" title="1.4 maven坐标书写规范"></a>1.4 maven坐标书写规范</h3><p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/33.png" alt="33"></p>
<h3 id="1-5-maven的依赖范围"><a href="#1-5-maven的依赖范围" class="headerlink" title="1.5 maven的依赖范围"></a>1.5 maven的依赖范围</h3><table>
<thead>
<tr>
<th>依赖范围</th>
<th>对于编译classpath有效</th>
<th>对于测试classpath有效</th>
<th>对于运行时classpath有效</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>compile</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>spring-core</td>
</tr>
<tr>
<td>test</td>
<td>-</td>
<td>Y</td>
<td>-</td>
<td>Junit</td>
</tr>
<tr>
<td>provided</td>
<td>Y</td>
<td>Y</td>
<td>-</td>
<td>servlet-api</td>
</tr>
<tr>
<td>runtime</td>
<td>-</td>
<td>Y</td>
<td>Y</td>
<td>JDBC驱动</td>
</tr>
<tr>
<td>system</td>
<td>Y</td>
<td>Y</td>
<td>-</td>
<td>本地的，maven仓库之外的类库</td>
</tr>
</tbody></table>
<h3 id="1-6-Maven工程类型"><a href="#1-6-Maven工程类型" class="headerlink" title="1.6 Maven工程类型"></a>1.6 Maven工程类型</h3><h4 id="1-6-1-POM工程"><a href="#1-6-1-POM工程" class="headerlink" title="1.6.1 POM工程"></a>1.6.1 POM工程</h4><p>POM工程是逻辑工程，用在父级工程或者聚合工程中。用来做jar包的版本控制。（<strong>不会写逻辑业务代码，更多的是起到管理工程的作用，子工程继承了父工程以后，可以直接用通用的jar包</strong>）</p>
<h4 id="1-6-2-JAR工程"><a href="#1-6-2-JAR工程" class="headerlink" title="1.6.2 JAR工程"></a>1.6.2 JAR工程</h4><p>将会打包成jar，用作jar包使用。即常见的本地工程—-&gt;Java Project。</p>
<h4 id="1-6-3-WAR工程"><a href="#1-6-3-WAR工程" class="headerlink" title="1.6.3 WAR工程"></a>1.6.3 WAR工程</h4><p>将会打包成war，发布在服务器上的工程。</p>
<h2 id="2-maven的依赖传递"><a href="#2-maven的依赖传递" class="headerlink" title="2. maven的依赖传递"></a>2. maven的依赖传递</h2><h3 id="2-1-什么是依赖传递"><a href="#2-1-什么是依赖传递" class="headerlink" title="2.1 什么是依赖传递"></a>2.1 什么是依赖传递</h3><p>在maven中，依赖是可以传递的，假设存在三个项目，分别是项目A，项目B以及项目C。假设C依赖B，B依赖A，那么我们可以根据maven项目依赖的特征不难推出项目C也依赖A。</p>
<p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/44.png" alt="44"></p>
<p>​                         <img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/55.png" alt="55"></p>
<p>通过上面的图可以看到，我们的web项目直接依赖了spring-webmvc，而spring-webmvc依赖了sping-aop、spring-beans等。最终的结果就是在我们的web项目中间接依赖了spring-aop、spring-beans等。</p>
<h3 id="2-2-什么是依赖冲突"><a href="#2-2-什么是依赖冲突" class="headerlink" title="2.2 什么是依赖冲突"></a>2.2 什么是依赖冲突</h3><p>由于依赖传递现象的存在， spring-webmvc 依赖 spirng-beans-4.2.4，spring-aop 依赖 spring-beans-5.0.2，但是发现 spirng-beans-4.2.4 加入到了工程中，而我们希望 spring-beans-5.0.2 加入工程。这就造成了依赖冲突。</p>
<p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/66.png" alt="66"></p>
<h3 id="2-3-如何解决依赖冲突"><a href="#2-3-如何解决依赖冲突" class="headerlink" title="2.3 如何解决依赖冲突"></a>2.3 如何解决依赖冲突</h3><p>1.使用maven提供的依赖调解原则 </p>
<pre><code>    第一声明者优先原则
</code></pre>
<p>​     路径近者优先原则</p>
<p>2.排除依赖</p>
<p>3.锁定版本 </p>
<h3 id="2-4-依赖调节原则——第一声明者优先原则"><a href="#2-4-依赖调节原则——第一声明者优先原则" class="headerlink" title="2.4 依赖调节原则——第一声明者优先原则"></a>2.4 依赖调节原则——第一声明者优先原则</h3><p>在 pom 文件中定义依赖，以先声明的依赖为准。其实就是根据坐标导入的顺序来确定最终使用哪个传递过来的依赖。</p>
<p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/77.png" alt="77"></p>
<p>结论：通过上图可以看到，spring-aop和spring-webmvc都传递过来了spring-beans，但是因为spring-aop在前面，所以最终使用的spring-beans是由spring-aop传递过来的，而spring-webmvc传递过来的spring-beans则被忽略了。</p>
<h3 id="2-5-排除依赖"><a href="#2-5-排除依赖" class="headerlink" title="2.5 排除依赖"></a>2.5 排除依赖</h3><p>可以使用exclusions标签将传递过来的依赖排除出去。</p>
<p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/88.png" alt="88"></p>
<h3 id="2-6-版本锁定"><a href="#2-6-版本锁定" class="headerlink" title="2.6 版本锁定"></a>2.6 版本锁定</h3><p>采用直接锁定版本的方法确定依赖jar包的版本，版本锁定后则不考虑依赖的声明顺序或依赖的路径，以锁定的版本为准添加到工程中，此方法在企业开发中经常使用。</p>
<p>版本锁定的使用方式：</p>
<p>第一步：在dependencyManagement标签中锁定依赖的版本</p>
<p>第二步：在dependencies标签中声明需要导入的maven坐标</p>
<p>①在dependencyManagement标签中锁定依赖的版本</p>
<p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/99.png" alt="99"></p>
<p>②在dependencies标签中声明需要导入的maven坐标</p>
<p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/111.png" alt="111"></p>
<h2 id="3-基于maven构建SSM工程案例"><a href="#3-基于maven构建SSM工程案例" class="headerlink" title="3.基于maven构建SSM工程案例"></a>3.基于maven构建SSM工程案例</h2><h3 id="3-1-需求描述"><a href="#3-1-需求描述" class="headerlink" title="3.1 需求描述"></a>3.1 需求描述</h3><p>本案例基于maven构建 SSM（Spring+SpringMVC+Mybatis）工程，通过maven坐标进行依赖管理。最终实现根据 id 查询商品信息的功能。</p>
<h3 id="3-2-构建maven工程"><a href="#3-2-构建maven工程" class="headerlink" title="3.2 构建maven工程"></a>3.2 构建maven工程</h3><p>1.数据库环境搭建 </p>
<p>​    ①创建数据库ssmtest</p>
<p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/222.png" alt="222"></p>
<p>​    ②创建商品表item</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `item` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> auto_increment,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">default</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `price` <span class="type">float</span> <span class="keyword">default</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `createtime` datetime <span class="keyword">default</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `detail` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">default</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY  (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8</span><br></pre></td></tr></table></figure>

<p>2.maven项目构建 </p>
<p>①创建maven web项目</p>
<p>②配置pom.xml文件</p>
<p>③实现spring+mybatis整合</p>
<p>创建POJO类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Integer id;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> Float price;</span><br><span class="line"><span class="keyword">private</span> Date createtime;</span><br><span class="line"><span class="keyword">private</span> String detail;</span><br><span class="line"><span class="comment">//省略setter、getter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>持久层DAO接口编写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ItemMapper</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> Item <span class="title">findById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Mapper映射文件编写</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.itheima.ssm.dao.ItemMapper&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span><br><span class="line">         select * from item where id=#&#123;id&#125;<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>业务层Service编写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.ssm.service;</span><br><span class="line"><span class="keyword">import</span> com.itheima.ssm.pojo.Item;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ItemService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Items <span class="title">findById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ItemServiceImpl</span> <span class="keyword">implements</span> <span class="title">ItemService</span> </span>&#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ItemMapper itemMapper;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Item <span class="title">findById</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> itemMapper.findById(id);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>spring配置文件applicationContext-dao.xml编写</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span>      <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span>   <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span>       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span>       <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span>       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/bean       http://www.springframework.org/schema/beans/spring-beans-4.0.xsd       http://www.springframework.org/schema/context      http://www.springframework.org/schema/context/spring-context-4.0.xsd      http://www.springframework.org/schema/aop   http://www.springframework.org/schema/aop/spring-aop-4.0.xsd     http://www.springframework.org/schema/tx  http://www.springframework.org/schema/tx/spring-tx-4.0.xsd      http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 数据库连接池 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 驱动 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- url --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/ssmtest&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 用户名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 密码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- mapper配置 --&gt;</span> <span class="comment">&lt;!-- 让spring管理sqlsessionfactory 使用mybatis和spring整合包中的 --&gt;</span>    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span>        <span class="comment">&lt;!-- 数据库连接池 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--为指定包下的所有实体类创建别名--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;typeAliasesPackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.itheima.ssm.pojo&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- mapper扫描器 ：用来产生代理对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.itheima.ssm.dao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>spring配置文件applicationContext-service.xml编写</p>
<p>④加入springmvc相关配置</p>
<p>表现层Controller编写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/item&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ItemController</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> ItemService itemService;</span><br><span class="line">  <span class="meta">@RequestMapping(&quot;/showItem/&#123;id&#125;&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">showItem</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="keyword">int</span> id, Model model)</span></span>&#123;</span><br><span class="line">        Item item = itemService.findById(id);</span><br><span class="line">        model.addAttribute(<span class="string">&quot;item&quot;</span>,item);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;item&quot;</span>;   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>springmvc.xml文件编写</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span>       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span>       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>      <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans-4.0.xsd       http://www.springframework.org/schema/context      http://www.springframework.org/schema/context/spring-context-4.0.xsd&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.itheima.ssm.controller&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  配置视图解析器的前缀和后缀 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span>           <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix“ value=&quot;</span>/<span class="attr">WEB-INF</span>/<span class="attr">jsp</span>/&quot;&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>jsp页面编写</p>
<p>配置web.xml文件</p>
<p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/333.png" alt="333"></p>
<h2 id="4-分模块构建maven工程"><a href="#4-分模块构建maven工程" class="headerlink" title="4.分模块构建maven工程"></a>4.分模块构建maven工程</h2><h3 id="4-1-分模块构建maven工程分析"><a href="#4-1-分模块构建maven工程分析" class="headerlink" title="4.1 分模块构建maven工程分析"></a>4.1 分模块构建maven工程分析</h3><p>在现实生活中，汽车厂家进行汽车生产时，由于整个生产过程非常复杂和繁琐，工作量非常大，所以车场都会将整个汽车的部件分开生产，最终再将生产好的部件进行组装，形成一台完整的汽车。</p>
<p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/444.png" alt="444"></p>
<p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/555.png" alt="555"></p>
<h3 id="4-2-maven工程的继承"><a href="#4-2-maven工程的继承" class="headerlink" title="4.2 maven工程的继承"></a>4.2 maven工程的继承</h3><p>在Java语言中，类之间是可以继承的，通过继承，子类就可以引用父类中非private的属性和方法。同样，在maven工程之间也可以继承，子工程继承父工程后，就可以使用在父工程中引入的依赖。继承的目的是为了消除重复代码。</p>
<p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/666.png" alt="666"></p>
<h3 id="4-3-maven工程的聚合"><a href="#4-3-maven工程的聚合" class="headerlink" title="4.3 maven工程的聚合"></a>4.3 maven工程的聚合</h3><p>在maven工程的pom.xml文件中可以使用<modules>标签将其他maven工程聚合到一起，聚合的目的是为了进行统一操作。</p>
<p>例如拆分后的maven工程有多个，如果要进行打包，就需要针对每个工程分别执行打包命令，操作起来非常繁琐。这时就可以使用<modules>标签将这些工程统一聚合到maven工程中，需要打包的时候，只需要在此工程中执行一次打包命令，其下被聚合的工程就都会被打包了。</p>
<p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/777.png" alt="777"></p>
<h3 id="4-4-分模块构建maven工程具体实现"><a href="#4-4-分模块构建maven工程具体实现" class="headerlink" title="4.4 分模块构建maven工程具体实现"></a>4.4 分模块构建maven工程具体实现</h3><p>①父工程maven_parent构建</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>5.0.5.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">springmvc.version</span>&gt;</span>5.0.5.RELEASE<span class="tag">&lt;/<span class="name">springmvc.version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">mybatis.version</span>&gt;</span>3.4.5<span class="tag">&lt;/<span class="name">mybatis.version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--锁定jar版本--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">           <span class="comment">&lt;!-- Mybatis --&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mybatis.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="comment">&lt;!-- springMVC --&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;springmvc.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="comment">&lt;!-- spring --&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-expression<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aspects<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context-support<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>②子工程maven_pojo构建</p>
<p>pom.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>③3.1子工程maven_dao构建</p>
<p>​    3.2 配置maven_dao工程的pom.xml文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itheima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven_pojo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- Mybatis和mybatis与spring的整合 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- MySql驱动 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.32<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- druid数据库连接池 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- spring相关 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-expression<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aspects<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context-support<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- junit测试 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​    3.3 创建DAO接口和Mapper映射文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.ssm.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.ssm.pojo.Item;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ItemMapper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Item <span class="title">findById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.itheima.ssm.dao.ItemMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Item&quot;</span>&gt;</span></span><br><span class="line">        select * from item where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​    3.4 在resources目录下创建spring配置文件applicationContext-dao.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">						   http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">						   http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">						   http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">						   http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">						   http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">						   http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="string"><span class="tag">						   http://www.springframework.org/schema/tx/spring-tx.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置数据源信息，使用druid连接池--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/ssmtest&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置spring整合mybatis框架的SQLSessionFactoryBean--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--扫描pojo包，为实体类创建别名--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;typeAliasesPackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.itheima.ssm.pojo&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--mapper扫描器，用于产生代理对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.itheima.ssm.dao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">&lt;/bean</span><br></pre></td></tr></table></figure>

<p>④子工程maven_service构建</p>
<p>​    第一步：创建maven_service工程</p>
<p>​    第二步：配置maven_service工程的pom.xml文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itheima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven_dao<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>​    第三步：创建Service接口和实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.ssm.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.ssm.pojo.Item;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ItemService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Item <span class="title">findById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.ssm.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.ssm.dao.ItemMapper;</span><br><span class="line"><span class="keyword">import</span> com.itheima.ssm.pojo.Item;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ItemServiceImpl</span> <span class="keyword">implements</span> <span class="title">ItemService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ItemMapper itemMapper;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Item <span class="title">findById</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> itemMapper.findById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 第四步：创建spring配置文件applicationContext-service.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">						   http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">						   http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">						   http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">						   http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">						   http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">						   http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="string"><span class="tag">						   http://www.springframework.org/schema/tx/spring-tx.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置扫描器，扫描Service--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.itheima.ssm.service&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--事务管理器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--事物注解驱动--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>⑤子工程maven_web构建</p>
<p>​    第一步：创建maven_web工程，注意打包方式为war</p>
<p>​    第二步：配置maven_web工程的pom.xml文件</p>
 <properties>
​        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
​        <maven.compiler.source>1.8</maven.compiler.source>
​        <maven.compiler.target>1.8</maven.compiler.target>
​    </properties>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itheima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven_service<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>maven_web<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span><span class="comment">&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-clean-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-resources-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.22.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-war-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-install-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-deploy-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>​    </p>
<p>​    第三步：创建Controller</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.ssm.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.ssm.pojo.Item;</span><br><span class="line"><span class="keyword">import</span> com.itheima.ssm.service.ItemService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.ui.Model;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/item&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ItemController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ItemService itemService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/showItem/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">findById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="keyword">int</span> id, Model model)</span></span>&#123;</span><br><span class="line">        Item item = itemService.findById(id);</span><br><span class="line">        model.addAttribute(<span class="string">&quot;item&quot;</span>,item);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;item&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    第四步：创建jsp页面</p>
<p>​    第五步：配置web.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--指定Spring配置文件位置--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath*:applicationContext*.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">&lt;!--配置Spring框架启动时使用的监听器--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--配置SpringMVC的前端控制器--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.do<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​    第六步：创建springmvc配置文件springmvc.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">						   http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">						   http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">						   http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">						   http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">						   http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">						   http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="string"><span class="tag">						   http://www.springframework.org/schema/tx/spring-tx.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置扫描器，扫描Controller--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.itheima.ssm.controller&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--视图解析器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/jsp/&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>项目整体结构如下：</p>
<p>1）maven_parent为父工程，其余工程为子工程，都继承父工程maven_parent</p>
<p>2）maven_parent工程将其子工程都进行了聚合 </p>
<p>3）子工程之间存在依赖关系，比如maven_dao依赖， maven_pojo、maven_service依赖maven_dao、 maven_web依赖maven_service</p>
<h2 id="5-maven私服"><a href="#5-maven私服" class="headerlink" title="5. maven私服"></a>5. maven私服</h2><h3 id="5-1-私服说明"><a href="#5-1-私服说明" class="headerlink" title="5.1 私服说明"></a>5.1 私服说明</h3><p>maven仓库分为本地仓库和远程仓库，而远程仓库又分为maven中央仓库、其他远程仓库和私服（私有服务器）。其中，中央仓库是由maven官方提供的，而私服就需要我们自己搭建了。</p>
<p>maven私服就是公司局域网内的maven远程仓库，每个员工的电脑上安装maven软件并且连接maven私服，程序员可以将自己开发的项目打成jar并发布到私服，其它项目组成员就可以从私服下载所依赖的jar。私服还充当一个代理服务器的角色，当私服上没有jar包时会从maven中央仓库自动下载。</p>
<p>nexus 是一个maven仓库管理器（其实就是一个软件），nexus可以充当maven私服，同时nexus还提供强大的仓库管理、构件搜索等功能。</p>
<h3 id="5-2-搭建maven私服"><a href="#5-2-搭建maven私服" class="headerlink" title="5.2 搭建maven私服"></a>5.2 搭建maven私服</h3><p>①下载nexus</p>
<p><a href="https://help.sonatype.com/repomanager2/download/download-archives---repository-manager-oss">https://help.sonatype.com/repomanager2/download/download-archives---repository-manager-oss</a></p>
<p>②安装nexus</p>
<p>将下载的压缩包进行解压，进入bin目录</p>
<p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/888.png" alt="888"></p>
<p>打开cmd窗口并进入上面bin目录下，执行nexus.bat install命令安装服务（注意需要以管理员身份运行cmd命令）</p>
<p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/999.png" alt="999"></p>
<p>③启动nexus</p>
<p>经过前面命令已经完成nexus的安装，可以通过如下两种方式启动nexus服务：</p>
<p>在Windows系统服务中启动nexus</p>
<p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/1111.png" alt="1111"></p>
<p>在命令行执行nexus.bat start命令启动nexus</p>
<p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/2222.png" alt="2222"></p>
<p>④访问nexus</p>
<p>启动nexus服务后，访问<a href="http://localhost:8081/nexus">http://localhost:8081/nexus</a></p>
<p>点击右上角LogIn按钮，进行登录。使用默认用户名admin和密码admin123登录系统</p>
<p>登录成功后点击左侧菜单Repositories可以看到nexus内置的仓库列表（如下图）</p>
<p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/3333.png" alt="3333"></p>
<p>nexus仓库类型</p>
<p>通过前面的仓库列表可以看到，nexus默认内置了很多仓库，这些仓库可以划分为4种类型，每种类型的仓库用于存放特定的jar包，具体说明如下：</p>
<p>①hosted，宿主仓库，部署自己的jar到这个类型的仓库，包括Releases和Snapshots两部分，Releases为公司内部发布版本仓库、 Snapshots为公司内部测试版本仓库 </p>
<p>②proxy，代理仓库，用于代理远程的公共仓库，如maven中央仓库，用户连接私服，私服自动去中央仓库下载jar包或者插件</p>
<p>③group，仓库组，用来合并多个hosted/proxy仓库，通常我们配置自己的maven连接仓库组</p>
<p>④virtual(虚拟)：兼容Maven1版本的jar或者插件</p>
<p><img src="D:\blog\source_posts\img\4444.png" alt="4444"> </p>
<p>nexus仓库类型与安装目录对应关系</p>
<p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/5555.png" alt="5555"></p>
<h3 id="5-3-将项目发布到maven私服"><a href="#5-3-将项目发布到maven私服" class="headerlink" title="5.3 将项目发布到maven私服"></a>5.3 将项目发布到maven私服</h3><p>maven私服是搭建在公司局域网内的maven仓库，公司内的所有开发团队都可以使用。例如技术研发团队开发了一个基础组件，就可以将这个基础组件打成jar包发布到私服，其他团队成员就可以从私服下载这个jar包到本地仓库并在项目中使用。</p>
<p>将项目发布到maven私服操作步骤如下：</p>
<ol>
<li>配置maven的settings.xml文件</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span>releases<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">password</span>&gt;</span>admin123<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span>snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">password</span>&gt;</span>admin123<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​      注意：一定要在idea工具中引入的maven的settings.xml文件中配置 </p>
<ol start="2">
<li>配置项目的pom.xml文件</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">id</span>&gt;</span>releases<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://localhost:8081/nexus/content/repositories/releases/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">id</span>&gt;</span>snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span>               <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://localhost:8081/nexus/content/repositories/snapshots/<span class="tag">&lt;/<span class="name">url</span>&gt;</span>    <span class="tag">&lt;/<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>执行mvn deploy命令</li>
</ol>
<p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/6666.png" alt="6666"></p>
<h3 id="5-4-从私服下载jar到本地仓库"><a href="#5-4-从私服下载jar到本地仓库" class="headerlink" title="5.4 从私服下载jar到本地仓库"></a>5.4 从私服下载jar到本地仓库</h3><p>前面我们已经完成了将本地项目打成jar包发布到maven私服，下面我们就需要从maven私服下载jar包到本地仓库。</p>
<p>具体操作步骤如下：</p>
<p>在maven的settings.xml文件中配置下载模板</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">id</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!--仓库地址，即nexus仓库组的地址--&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">url</span>&gt;</span></span><br><span class="line">			http://localhost:8081/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!--是否下载releases构件--&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!--是否下载snapshots构件--&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 插件仓库，maven的运行依赖插件，也需要从私服下载插件 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">id</span>&gt;</span>public<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>Public Repositories<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">url</span>&gt;</span></span><br><span class="line">		http://localhost:8081/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在maven的settings.xml文件中配置激活下载模板</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activeProfiles</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">activeProfile</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">activeProfile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activeProfiles</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="6-将第三方jar安装到本地仓库和maven私服"><a href="#6-将第三方jar安装到本地仓库和maven私服" class="headerlink" title="6. 将第三方jar安装到本地仓库和maven私服"></a>6. 将第三方jar安装到本地仓库和maven私服</h2><p>在maven工程的pom.xml文件中配置某个jar包的坐标后，如果本地的maven仓库不存在这个jar包，maven工具会自动到配置的maven私服下载，如果私服中也不存在，maven私服就会从maven中央仓库进行下载。</p>
<p>但是并不是所有的jar包都可以从中央仓库下载到，比如常用的Oracle数据库驱动的jar包在中央仓库就不存在。此时需要到Oracle的官网下载驱动jar包，然后将此jar包通过maven命令安装到我们本地的maven仓库或者maven私服中，这样在maven项目中就可以使用maven坐标引用到此jar包了。</p>
<h3 id="6-1-将第三方jar安装到本地仓库"><a href="#6-1-将第三方jar安装到本地仓库" class="headerlink" title="6.1 将第三方jar安装到本地仓库"></a>6.1 将第三方jar安装到本地仓库</h3><p>①下载Oracle的jar包（略）</p>
<p>②mvn install命令进行安装</p>
<p>​      mvn install:install-file -Dfile=ojdbc14-10.2.0.4.0.jar -DgroupId=com.oracle -DartifactId=ojdbc14 – </p>
<p>​      Dversion=10.2.0.4.0 -Dpackaging=jar</p>
<p>③查看本地maven仓库，确认安装是否成功</p>
<p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/7777.png" alt="7777"></p>
<h3 id="6-2-将第三方jar安装到maven私服"><a href="#6-2-将第三方jar安装到maven私服" class="headerlink" title="6.2 将第三方jar安装到maven私服"></a>6.2 将第三方jar安装到maven私服</h3><p>①下载Oracle的jar包（略）</p>
<p>②在maven的settings.xml配置文件中配置第三方仓库的server信息</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>thirdparty<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">password</span>&gt;</span>admin123<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>③执行mvn deploy命令进行安装</p>
<p>​      mvn deploy:deploy-file -Dfile=ojdbc14-10.2.0.4.0.jar -DgroupId=com.oracle -DartifactId=ojdbc14 –</p>
<p>​      Dversion=10.2.0.4.0 -Dpackaging=jar –</p>
<p>​      Durl=<a href="http://localhost:8081/nexus/content/repositories/thirdparty/">http://localhost:8081/nexus/content/repositories/thirdparty/</a> -DrepositoryId=thirdparty</p>
]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Servlet，我还是爱你的</title>
    <url>/2021/09/04/Servlet%EF%BC%8C%E6%88%91%E8%BF%98%E6%98%AF%E7%88%B1%E4%BD%A0%E7%9A%84/</url>
    <content><![CDATA[<h1 id="Ⅰ-为什么需要Servlet"><a href="#Ⅰ-为什么需要Servlet" class="headerlink" title="Ⅰ. 为什么需要Servlet"></a>Ⅰ. 为什么需要Servlet</h1><h2 id="1-1-Tomcat"><a href="#1-1-Tomcat" class="headerlink" title="1.1 Tomcat"></a>1.1 Tomcat</h2><span id="more"></span>

<p>Tomcat是一个Web服务器（同时也是Servlet容器），通过它我们可以很方便地<strong>接收和返回</strong>到请求（如果不用Tomcat，那我们需要自己写Socket来接收和返回请求）。</p>
<h3 id="Tomcat的目录层次结构"><a href="#Tomcat的目录层次结构" class="headerlink" title="Tomcat的目录层次结构"></a>Tomcat的目录层次结构</h3><p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/image-20210410173843721.png" alt="image-20210410173843721"></p>
<h2 id="1-2-什么是Servlet？"><a href="#1-2-什么是Servlet？" class="headerlink" title="1.2 什么是Servlet？"></a>1.2 什么是Servlet？</h2><p>Servlet其实就是一个<strong>遵循Servlet开发的java类</strong>。Serlvet是<strong>由服务器调用的</strong>，<strong>运行在服务器端</strong>。我们编写java程序想要在网上实现聊天、发帖、这样的一些交互功能，<strong>普通的java技术是非常难完成的</strong>。于是sun公司就提供了Serlvet这种技术供我们使用。</p>
<h2 id="1-3-HTTP协议"><a href="#1-3-HTTP协议" class="headerlink" title="1.3 HTTP协议"></a>1.3 HTTP协议</h2><blockquote>
<p>超文本（HTML，css，JavaScript和图片等）传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。它是TCP/IP协议的一个<strong>应用层协议</strong></p>
</blockquote>
<p>直白的说，HTTP协议就是浏览器和服务器之间通讯的一种协议，就比如我们在点击网站链接打开一个网站的时候，浏览器会给服务器发送一段文本，告诉服务器自己打开的是哪一个网页，服务器收到请求以后，会返回给浏览器一段文本，浏览器解析后将其显示给用户。</p>
<h2 id="1-4-HTTP-请求"><a href="#1-4-HTTP-请求" class="headerlink" title="1.4 HTTP 请求"></a>1.4 HTTP 请求</h2><p><strong>浏览器向服务器请求某个web资源时，称之为浏览器向服务器发送了一个http请求。</strong></p>
<p>一个完整http请求应该包含三个部分：</p>
<ol>
<li>请求行【描述客户端的<strong>请求方式</strong>、<strong>请求的资源名称</strong>，以及使用的<strong>HTTP协议版本号</strong>（1.0和1.1）】</li>
<li>多个消息头【描述客户端请求哪台主机，以及<strong>客户端的一些环境信息</strong>等】</li>
<li>一个空行</li>
</ol>
<h3 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h3><p>请求行：GET /java.html HTTP/1.1</p>
<p><strong>请求行中的GET称之为请求方式</strong>，请求方式有：POST,GET,HEAD,OPTIONS,DELETE,TRACE,PUT。</p>
<p><strong>常用的有：POST,GET</strong></p>
<p>一般来说，当我们<strong>点击超链接，通过地址栏访问都是get请求方式</strong>。通过<strong>表单提交的数据一般是post方式</strong>。</p>
<p>可以简单理解<strong>GET方式用来查询数据</strong>,<strong>POST方式用来提交数据</strong>，<strong>get的提交速度比post快</strong></p>
<p>GET方式：在URL地址后<strong>附带的参数是有限制的</strong>，其<strong>数据容量通常不能超过1K</strong>。</p>
<p>POST方式：可以在<strong>请求的实体内容中向服务器发送数据</strong>，<strong>传送的数据量无限制</strong>。</p>
<h3 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h3><ul>
<li>Accept: text/html,image/* 【浏览器告诉服务器，它支持的数据类型】</li>
<li>Accept-Charset: ISO-8859-1 【浏览器告诉服务器，它支持哪种<strong>字符集</strong>】</li>
<li>Accept-Encoding: gzip,compress 【浏览器告诉服务器，它支持的<strong>压缩格式</strong>】</li>
<li>Accept-Language: en-us,zh-cn 【浏览器告诉服务器，它的语言环境】</li>
<li>Host: <a href="http://www.it315.org:80【浏览器告诉服务器，它的想访问哪台主机】">www.it315.org:80【浏览器告诉服务器，它的想访问哪台主机】</a></li>
<li>If-Modified-Since: Tue, 11 Jul 2000 18:23:51 GMT【浏览器告诉服务器，缓存数据的时间】</li>
<li>Referer: <a href="http://www.it315.org/index.jsp%E3%80%90%E6%B5%8F%E8%A7%88%E5%99%A8%E5%91%8A%E8%AF%89%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E5%AE%A2%E6%88%B7%E6%9C%BA%E6%98%AF%E4%BB%8E%E9%82%A3%E4%B8%AA%E9%A1%B5%E9%9D%A2%E6%9D%A5%E7%9A%84---**%E5%8F%8D%E7%9B%97%E9%93%BE**%E3%80%91">http://www.it315.org/index.jsp【浏览器告诉服务器，客户机是从那个页面来的---**反盗链**】</a></li>
<li>8.User-Agent: Mozilla/4.0 (compatible; MSIE 5.5; Windows NT 5.0)【浏览器告诉服务器，浏览器的内核是什么】</li>
<li>Cookie【浏览器告诉服务器，<strong>带来的Cookie是什么</strong>】</li>
<li>Connection: close/Keep-Alive 【浏览器告诉服务器，请求完后是断开链接还是保持链接】</li>
<li>Date: Tue, 11 Jul 2000 18:23:51 GMT【浏览器告诉服务器，请求的时间】</li>
</ul>
<h2 id="1-5-HTTP响应"><a href="#1-5-HTTP响应" class="headerlink" title="1.5 HTTP响应"></a>1.5 HTTP响应</h2><p>一个HTTP响应代表着<strong>服务器向浏览器回送数据</strong></p>
<p>一个完整的HTTP响应应该包含四个部分:</p>
<ol>
<li>一个状态行【用于描述<strong>服务器对请求的处理结果。</strong>】</li>
<li>多个消息头【用于描述<strong>服务器的基本信息</strong>，以及<strong>数据的描述</strong>，<strong>服务器通过这些数据的描述信息，可以通知客户端如何处理等一会儿它回送的数据</strong>】</li>
<li>一个空行</li>
<li>实体内容【<strong>服务器向客户端回送的数据</strong>】</li>
</ol>
<h3 id="状态行"><a href="#状态行" class="headerlink" title="状态行"></a>状态行</h3><p>格式： HTTP版本号　状态码　原因叙述</p>
<p>状态行：HTTP/1.1 200 OK</p>
<p>状态码用于表示<strong>服务器对请求的处理结果</strong>，它是一个<strong>三位的十进制数</strong>。响应状态码分为5类</p>
<p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/image-20210411005345135.png" alt="image-20210411005345135"></p>
<h1 id="Ⅱ-Servlet的作用"><a href="#Ⅱ-Servlet的作用" class="headerlink" title="Ⅱ. Servlet的作用"></a>Ⅱ. Servlet的作用</h1><p>Servlet带给我们最大的作用就是能够<strong>处理浏览器带来HTTP请求，并返回一个响应给浏览器，从而实现浏览器和服务器的交互</strong>。</p>
<p>简单来说，Servlet 就是运行在服务器上的一个 java 小程序，<strong>它可以接收客户端发送过来的请求，并响应数据给客户端。</strong></p>
<h2 id="实现Servlet"><a href="#实现Servlet" class="headerlink" title="实现Servlet"></a>实现Servlet</h2><p>1、编写一个类去实现 Servlet 接口  </p>
<p>2、实现 service 方法，处理请求，并响应数据 </p>
<p>3、到 web.xml 中去配置 servlet 程序的访问地址。</p>
<p>首先实现 Servlet 接口，我们发现有5个方法需要重写，</p>
<ul>
<li><p>init【初始化】，</p>
</li>
<li><p>destroy【销毁】,</p>
</li>
<li><p>service【服务】,</p>
</li>
<li><p>ServletConfig【Servlet配置】,</p>
</li>
<li><p>getServletInfo【Serlvet信息】</p>
</li>
</ul>
<p>发现service()方法是最有可能是写逻辑代码的地方。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServlet</span> <span class="keyword">implements</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* service 方法是专门用来处理请求和响应的</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> servletRequest</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> servletResponse</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> ServletException</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest servletRequest, ServletResponse                                servletResponse)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Hello Servlet 被访问了&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>web.xml 中的配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- servlet标签给Tomcat配置Servlet程序 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--servlet-name标签 Servlet程序起一个别名（一般是类名） --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--servlet-class是Servlet程序的全类名--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.atguigu.servlet.HelloServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--init-param是初始化参数--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--是参数名--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>username<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--是参数值--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>root<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--init-param是初始化参数--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--是参数名--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>url<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--是参数值--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>jdbc:mysql://localhost:3306/test<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--servlet-mapping标签给servlet程序配置访问地址--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--servlet-name标签的作用是告诉服务器，我当前配置的地址给哪个Servlet程序使用--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            url-pattern标签配置访问地址                                     &lt;br/&gt;</span></span><br><span class="line"><span class="comment">               / 斜杠在服务器解析的时候，表示地址为：http://ip:port/工程路径          &lt;br/&gt;</span></span><br><span class="line"><span class="comment">               /hello 表示地址为：http://ip:port/工程路径/hello              &lt;br/&gt;</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="URL到-Servlet-程序的访问"><a href="#URL到-Servlet-程序的访问" class="headerlink" title="URL到 Servlet 程序的访问"></a>URL到 Servlet 程序的访问</h2><p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/image-20210412111221442.png" alt="image-20210412111221442"></p>
<h2 id="Servlet-的生命周期"><a href="#Servlet-的生命周期" class="headerlink" title="Servlet 的生命周期"></a>Servlet 的生命周期</h2><p>1、执行 Servlet 构造器方法 </p>
<p>2、执行 init 初始化方法  </p>
<ul>
<li>第一、二步，是在第一次访问的时候创建 Servlet 程序会调用。 </li>
</ul>
<p>3、执行 service 方法  第三步，每次访问都会调用。 </p>
<p>4、执行 destroy 销毁方法  第四步，在 web 工程停止的时候调用</p>
<h2 id="GET-和-POST-请求的分发处理"><a href="#GET-和-POST-请求的分发处理" class="headerlink" title="GET 和 POST 请求的分发处理"></a>GET 和 POST 请求的分发处理</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServlet</span> <span class="keyword">implements</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloServlet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;1 构造器方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * service方法是专门用来处理请求和响应的</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> servletRequest</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> servletResponse</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ServletException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;3 service === Hello Servlet 被访问了&quot;</span>);</span><br><span class="line">        <span class="comment">// 类型转换（因为它有getMethod()方法）</span></span><br><span class="line">        HttpServletRequest httpServletRequest = (HttpServletRequest) servletRequest;</span><br><span class="line">        <span class="comment">// 获取请求的方式</span></span><br><span class="line">        String method = httpServletRequest.getMethod();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;GET&quot;</span>.equals(method)) &#123;</span><br><span class="line">            doGet();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;POST&quot;</span>.equals(method)) &#123;</span><br><span class="line">           doPost();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 做get请求的操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;get请求&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;get请求&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 做post请求的操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;post请求&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;post请求&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="通过继承-HttpServlet-实现-Servlet-程序"><a href="#通过继承-HttpServlet-实现-Servlet-程序" class="headerlink" title="通过继承 HttpServlet 实现 Servlet 程序"></a>通过继承 HttpServlet 实现 Servlet 程序</h2><p>一般在实际项目开发中，都是使用继承 HttpServlet 类的方式去实现 Servlet 程序。 </p>
<p>1、编写一个类去继承 HttpServlet 类 </p>
<p>2、根据业务需要重写 doGet 或 doPost 方法 </p>
<p>3、到 web.xml 中的配置 Servlet 程序的访问地址</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServlet2</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.init(config);</span><br><span class="line">        System.out.println(<span class="string">&quot;重写了init初始化方法,做了一些工作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * doGet（）在get请求的时候调用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> req</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resp</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ServletException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i =  <span class="number">12</span> / <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;HelloServlet2 的doGet方法&quot;</span>);</span><br><span class="line">        <span class="comment">// 也可以使用.</span></span><br><span class="line">        ServletConfig servletConfig = getServletConfig();</span><br><span class="line">        System.out.println(servletConfig);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  2、获取初始化参数init-param</span></span><br><span class="line">        System.out.println(<span class="string">&quot;初始化参数username的值是;&quot;</span> + servletConfig.getInitParameter(<span class="string">&quot;username&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;初始化参数url的值是;&quot;</span> + servletConfig.getInitParameter(<span class="string">&quot;url&quot;</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * doPost（）在post请求的时候调用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> req</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resp</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ServletException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;HelloServlet2 的doPost方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Servlet类的继承体系"><a href="#Servlet类的继承体系" class="headerlink" title="Servlet类的继承体系"></a>Servlet类的继承体系</h2><p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/image-20210412113852585.png" alt="image-20210412113852585"></p>
<h1 id="Ⅲ-HttpServletRequest-类"><a href="#Ⅲ-HttpServletRequest-类" class="headerlink" title="Ⅲ.HttpServletRequest 类"></a>Ⅲ.HttpServletRequest 类</h1><h2 id="HttpServletRequest-类有什么作用"><a href="#HttpServletRequest-类有什么作用" class="headerlink" title="HttpServletRequest 类有什么作用"></a>HttpServletRequest 类有什么作用</h2><p>每次只要有请求进入 Tomcat 服务器，Tomcat 服务器就会把请求过来的 HTTP 协议信息解析好封装到 Request 对象中。 然后传递到 service 方法（doGet 和 doPost）中给我们使用。我们可以用HttpServletRequest 对象，获取到所有请求的 信息。</p>
<h2 id="HttpServletRequest"><a href="#HttpServletRequest" class="headerlink" title="HttpServletRequest"></a>HttpServletRequest</h2><p>i. getRequestURI()                 获取请求的资源路径 </p>
<p>ii. getRequestURL()               获取请求的统一资源定位符（绝对路径） </p>
<p>iii. getRemoteHost()               获取客户端的 ip 地址 </p>
<p>iv. getHeader()                       获取请求头 </p>
<p>v. getParameter()                   获取请求的参数 </p>
<p>vi. getParameterValues()       获取请求的参数（多个值的时候使用） </p>
<p>vii. getMethod()                      获取请求的<strong>方式</strong> GET 或 POST </p>
<p>viii. setAttribute(key, value);   设置域数据 </p>
<p>ix. getAttribute(key);              获取域数据 </p>
<p>x. getRequestDispatcher()     获取请求转发对象</p>
<h2 id="请求的转发"><a href="#请求的转发" class="headerlink" title="请求的转发"></a>请求的转发</h2><p>请求转发是指，服务器收到请求后，从一次资源跳转到另一个资源的操作叫请求转发。</p>
<p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/image-20210412153202697.png" alt="image-20210412153202697"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Servlet1</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取请求的参数（办事的材料）查看</span></span><br><span class="line">        String username = req.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;在Servlet1（柜台1）中查看参数（材料）：&quot;</span> + username);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 给材料 盖一个章，并传递到Servlet2（柜台 2）去查看</span></span><br><span class="line">        req.setAttribute(<span class="string">&quot;key1&quot;</span>,<span class="string">&quot;柜台1的章&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 问路：Servlet2（柜台 2）怎么走</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 请求转发必须要以斜杠打头，/ 斜杠表示地址为：http://ip:port/工程名/ , 映射到IDEA代码的web目录&lt;br/&gt;</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        RequestDispatcher requestDispatcher = req.getRequestDispatcher(<span class="string">&quot;/servlet2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 走向Sevlet2（柜台 2）</span></span><br><span class="line">        requestDispatcher.forward(req,resp);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Servlet2</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取请求的参数（办事的材料）查看</span></span><br><span class="line">        String username = req.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;在Servlet2（柜台2）中查看参数（材料）：&quot;</span> + username);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查看 柜台1 是否有盖章</span></span><br><span class="line">        Object key1 = req.getAttribute(<span class="string">&quot;key1&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;柜台1是否有章：&quot;</span> + key1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理自己的业务</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Servlet2 处理自己的业务 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Ⅳ-HttpServletResponse-类"><a href="#Ⅳ-HttpServletResponse-类" class="headerlink" title="Ⅳ.HttpServletResponse 类"></a>Ⅳ.HttpServletResponse 类</h1><h2 id="HttpServletResponse-类的作用"><a href="#HttpServletResponse-类的作用" class="headerlink" title="HttpServletResponse 类的作用"></a>HttpServletResponse 类的作用</h2><p>HttpServletResponse 类和 HttpServletRequest 类一样。每次请求进来，Tomcat 服务器都会创建一个 Response 对象传 递给 Servlet 程序去使用。HttpServletRequest 表示请求过来的信息，HttpServletResponse 表示所有响应的信息， 我们如果需要设置返回给客户端的信息，都可以通过 HttpServletResponse 对象来进行设置。</p>
<h2 id="两个输出流的说明"><a href="#两个输出流的说明" class="headerlink" title="两个输出流的说明"></a>两个输出流的说明</h2><p>字节流 getOutputStream();   常用于下载（传递二进制数据） </p>
<p>字符流 getWriter();                常用于回传字符串（常用）</p>
<p>两个流同时只能使用一个。 使用了字节流，就不能再使用字符流，反之亦然，否则就会报错。</p>
<p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/image-20210412160221386.png" alt="image-20210412160221386"></p>
<h2 id="如何往客户端回传数据"><a href="#如何往客户端回传数据" class="headerlink" title="如何往客户端回传数据"></a>如何往客户端回传数据</h2><p>要求 ： 往客户端回传 字符串 数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResponseIOServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span>                       ServletException,IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 要求 ： 往客户端回传 字符串 数据。</span></span><br><span class="line">        PrintWriter writer = resp.getWriter();</span><br><span class="line">        writer.write(<span class="string">&quot;response&#x27;s content!!!&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="响应的乱码解决"><a href="#响应的乱码解决" class="headerlink" title="响应的乱码解决"></a>响应的乱码解决</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 它会同时设置服务器和客户端都使用 UTF-8 字符集，还设置了响应头</span></span><br><span class="line"><span class="comment">// 此方法一定要在获取流对象之前调用才有效</span></span><br><span class="line">resp.setContentType(<span class="string">&quot;text/html;  charset=UTF-8&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="请求重定向"><a href="#请求重定向" class="headerlink" title="请求重定向"></a>请求重定向</h2><p>请求重定向，是指客户端给服务器发请求，然后服务器告诉客户端说。我给你一些地址。你去新地址访问。叫请求 重定向（因为之前的地址可能已经被废弃）。</p>
<p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/image-20210412160730423.png" alt="image-20210412160730423"></p>
<p>注意转发与重定向的区别，转发访问的是同一个资源，最明显的特征是浏览器地址栏的地址不会发生变化，重定向访问的是新的资源，浏览器地址栏里的地址会发生变化。</p>
<p>请求重定向的第二种方案（推荐使用）： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">resp.sendRedirect(<span class="string">&quot;http://localhost:8080&quot;</span>);</span><br></pre></td></tr></table></figure>

<h1 id="Ⅴ-Servlet的一些细节"><a href="#Ⅴ-Servlet的一些细节" class="headerlink" title="Ⅴ.Servlet的一些细节"></a>Ⅴ.Servlet的一些细节</h1><h2 id="1-一个已经注册的Servlet可以被多次映射"><a href="#1-一个已经注册的Servlet可以被多次映射" class="headerlink" title="1.一个已经注册的Servlet可以被多次映射"></a>1.一个已经注册的Servlet可以被多次映射</h2><p><strong>同一个Servlet可以被映射到多个URL上。</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>Demo1<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span>			            </span><br><span class="line">		   <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>zhongfucheng.web.Demo1<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span>       </span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span>           </span><br><span class="line">		   <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>Demo1<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span>            </span><br><span class="line">		   <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/Demo1<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span>        </span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span>           </span><br><span class="line">		   <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>Demo1<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span>            </span><br><span class="line">		   <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/ouzicheng<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span>        </span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>无论访问的是<a href="http://localhost:8080/Demo1%E8%BF%98%E6%98%AFhttp://localhost:8080/ouzicheng%E3%80%82%E8%AE%BF%E9%97%AE%E7%9A%84%E9%83%BD%E6%98%AFDemo1%E3%80%82">http://localhost:8080/Demo1还是http://localhost:8080/ouzicheng。访问的都是Demo1。</a></p>
<h2 id="2-Servlet是单例的"><a href="#2-Servlet是单例的" class="headerlink" title="2.Servlet是单例的"></a>2.Servlet是单例的</h2><h3 id="为什么Servlet是单例的"><a href="#为什么Servlet是单例的" class="headerlink" title="为什么Servlet是单例的"></a>为什么Servlet是单例的</h3><p><strong>浏览器多次对Servlet的请求</strong>，一般情况下，<strong>服务器只创建一个Servlet对象</strong>，也就是说，Servlet对象<strong>一旦创建了</strong>，就会<strong>驻留在内存中，为后续的请求做服务，直到服务器关闭</strong>。</p>
<h3 id="每次访问请求对象和响应对象都是新的"><a href="#每次访问请求对象和响应对象都是新的" class="headerlink" title="每次访问请求对象和响应对象都是新的"></a>每次访问请求对象和响应对象都是新的</h3><p>对于<strong>每次访问请求</strong>，Servlet引擎都会<strong>创建一个新的HttpServletRequest请求对象和一个新的HttpServletResponse响应对象</strong>，然后将这两<strong>个对象作为参数传递给它调用的Servlet的service()方法</strong>，<strong>service方法再根据请求方式分别调用doXXX方法</strong>。</p>
<h2 id="3-线程安全问题"><a href="#3-线程安全问题" class="headerlink" title="3.线程安全问题"></a>3.线程安全问题</h2><p>当多个用户访问Servlet的时候，<strong>服务器会为每个用户创建一个线程</strong>。<strong>当多个用户并发访问Servlet共享资源的时候就会出现线程安全问题</strong>。</p>
<p>原则：</p>
<ol>
<li>如果一个<strong>变量需要多个用户共享</strong>，则应当在访问该变量的时候，<strong>加同步机制synchronized (对象){}</strong></li>
<li>如果一个变量<strong>不需要共享</strong>，则<strong>直接在 doGet() 或者 doPost()定义</strong>.这样不会存在线程安全问题。</li>
</ol>
<h1 id="Ⅵ-ServletContext对象"><a href="#Ⅵ-ServletContext对象" class="headerlink" title="Ⅵ. ServletContext对象"></a>Ⅵ. ServletContext对象</h1><h2 id="什么是-ServletContext"><a href="#什么是-ServletContext" class="headerlink" title="什么是 ServletContext?"></a>什么是 ServletContext?</h2><p>1、ServletContext 是一个接口，它表示 Servlet 上下文对象 </p>
<p>2、一个 web 工程，只有一个 ServletContext 对象实例。 </p>
<p>3、ServletContext 对象是一个域对象。 </p>
<p>4、ServletContext 是在 web 工程部署启动的时候创建。在 web 工程停止的时候销毁。 </p>
<p>域对象，是可以像 Map 一样存取数据的对象，叫域对象。 这里的域指的是存取数据的操作范围，整个 web 工程。</p>
<p>​                   存数据                   取数据                        删除 数据 </p>
<p>Map             put()                       get()                         remove() </p>
<p>域对象    setAttribute()          getAttribute()          removeAttribute();</p>
<h2 id="ServletContext有什么用？"><a href="#ServletContext有什么用？" class="headerlink" title="ServletContext有什么用？"></a>ServletContext有什么用？</h2><ol>
<li>ServletContext既然代表着当前web站点，那么<strong>所有Servlet都共享着一个ServletContext对象</strong>，所以<strong>Servlet之间可以通过ServletContext实现通讯</strong>。</li>
<li>ServletConfig获取的是配置的是单个Servlet的参数信息，<strong>ServletContext可以获取的是配置整个web站点的参数信息</strong></li>
<li><strong>利用ServletContext读取web站点的资源文件</strong></li>
<li>实现Servlet的转发【用ServletContext转发不多，主要用request转发】</li>
</ol>
<h1 id="Ⅶ-会话技术-Cookie-和-Session"><a href="#Ⅶ-会话技术-Cookie-和-Session" class="headerlink" title="Ⅶ. 会话技术 Cookie 和 Session"></a>Ⅶ. 会话技术 Cookie 和 Session</h1><h2 id="1-为什么需要会话技术？"><a href="#1-为什么需要会话技术？" class="headerlink" title="1.为什么需要会话技术？"></a>1.为什么需要会话技术？</h2><blockquote>
<p><strong>会话是浏览器和服务器之间的多次请求和响应</strong></p>
<p>也就是说，从浏览器<strong>访问服务器开始</strong>，到<strong>访问服务器结束</strong>，<strong>浏览器关闭为止</strong>的这段时间内容产生的<strong>多次请求和响应</strong>，合起来叫做浏览器和服务器之间的一次会话</p>
</blockquote>
<p>实际上会话问题解决的还是客户端与服务器之间的通信问题，通过一些会话技术，可以将每个用户的数据以例如cookie/session的形式存储，方便以后用户访问web资源的时候使用。</p>
<blockquote>
<p>假定场景：A和B两人在某个网上购物商场登陆账号后，A买了一个HHKB的键盘，而B则购买了一把民谣吉他，这些信息都会被保存下来</p>
<p>用途是：保存账户信息，登录时询问日后是否自动登录，或者根据之前浏览，购买过的商品，分析用户喜欢什么类型的商品，做出精准推送</p>
</blockquote>
<h2 id="2-会话技术分类"><a href="#2-会话技术分类" class="headerlink" title="2. 会话技术分类"></a>2. 会话技术分类</h2><p>客户端会话技术 —— Cookie</p>
<p>服务器会话技术 —— Session</p>
<h2 id="3-Cookie"><a href="#3-Cookie" class="headerlink" title="3. Cookie"></a>3. Cookie</h2><blockquote>
<p>Cookie是由W3C组织提出，最早由netscape社区发展的一种机制</p>
</blockquote>
<ul>
<li>网页之间的<strong>交互是通过HTTP协议传输数据的，</strong>而Http协议是<strong>无状态的协议</strong>。无状态的协议是什么意思呢？<strong>一旦数据提交完后，浏览器和服务器的连接就会关闭，再次交互的时候需要重新建立新的连接</strong>。</li>
<li>服务器无法确认用户的信息，于是乎，W3C就提出了：<strong>给每一个用户都发一个通行证，无论谁访问的时候都需要携带通行证，这样服务器就可以从通行证上确认用户的信息</strong>。通行证就是Cookie.</li>
</ul>
<h3 id="如何创建Cookie"><a href="#如何创建Cookie" class="headerlink" title="如何创建Cookie"></a>如何创建Cookie</h3><p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/image-20210412165223986.png" alt="image-20210412165223986"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">createCookie</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">//1 创建Cookie对象</span></span><br><span class="line">    Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">&quot;key4&quot;</span>, <span class="string">&quot;value4&quot;</span>);</span><br><span class="line">    <span class="comment">//2 通知客户端保存Cookie</span></span><br><span class="line">    resp.addCookie(cookie);</span><br><span class="line">    <span class="comment">//1 创建Cookie对象</span></span><br><span class="line">    Cookie cookie1 = <span class="keyword">new</span> Cookie(<span class="string">&quot;key5&quot;</span>, <span class="string">&quot;value5&quot;</span>);</span><br><span class="line">    <span class="comment">//2 通知客户端保存Cookie</span></span><br><span class="line">    resp.addCookie(cookie1);</span><br><span class="line"></span><br><span class="line">    resp.getWriter().write(<span class="string">&quot;Cookie创建成功&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="服务器如何获取-Cookie"><a href="#服务器如何获取-Cookie" class="headerlink" title="服务器如何获取 Cookie"></a>服务器如何获取 Cookie</h3><p>服务器获取客户端的 Cookie 只需要一行代码：req.getCookies():Cookie[]</p>
<p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/image-20210412170344538.png" alt="image-20210412170344538"></p>
<p>Cookie 的工具类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CookieUtils</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找指定名称的Cookie对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cookies</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Cookie <span class="title">findCookie</span><span class="params">(String name , Cookie[] cookies)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (name == <span class="keyword">null</span> || cookies == <span class="keyword">null</span> || cookies.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Cookie cookie : cookies) &#123;</span><br><span class="line">            <span class="keyword">if</span> (name.equals(cookie.getName())) &#123;</span><br><span class="line">                <span class="keyword">return</span> cookie;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Servlet 程序中的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">getCookie</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Cookie[] cookies = req.getCookies();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Cookie cookie : cookies) &#123;</span><br><span class="line">            <span class="comment">// getName方法返回Cookie的key（名）</span></span><br><span class="line">            <span class="comment">// getValue方法返回Cookie的value值</span></span><br><span class="line">            resp.getWriter().write(<span class="string">&quot;Cookie[&quot;</span> + cookie.getName() + <span class="string">&quot;=&quot;</span> + cookie.getValue() + <span class="string">&quot;] &lt;br/&gt;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Cookie iWantCookie = CookieUtils.findCookie(<span class="string">&quot;key1&quot;</span>, cookies);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果不等于null，说明赋过值，也就是找到了需要的Cookie</span></span><br><span class="line">        <span class="keyword">if</span> (iWantCookie != <span class="keyword">null</span>) &#123;</span><br><span class="line">            resp.getWriter().write(<span class="string">&quot;找到了需要的Cookie&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Cookie值的修改"><a href="#Cookie值的修改" class="headerlink" title="Cookie值的修改"></a>Cookie值的修改</h3><p>1、先查找到需要修改的 Cookie 对象 </p>
<p>2、调用 setValue()方法赋于新的 Cookie 值。 </p>
<p>3、调用 response.addCookie()通知客户端保存修改</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">updateCookie</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//        方案一：</span></span><br><span class="line"><span class="comment">//        1、先创建一个要修改的同名的Cookie对象</span></span><br><span class="line"><span class="comment">//        2、在构造器，同时赋于新的Cookie值。</span></span><br><span class="line"><span class="comment">//        Cookie cookie = new Cookie(&quot;key1&quot;,&quot;newValue1&quot;);</span></span><br><span class="line"><span class="comment">//        3、调用response.addCookie( Cookie ); 通知 客户端 保存修改</span></span><br><span class="line"><span class="comment">//        resp.addCookie(cookie);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        方案二：</span></span><br><span class="line"><span class="comment">//        1、先查找到需要修改的Cookie对象</span></span><br><span class="line">        Cookie cookie = CookieUtils.findCookie(<span class="string">&quot;key2&quot;</span>, req.getCookies());</span><br><span class="line">        <span class="keyword">if</span> (cookie != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//          2、调用setValue()方法赋于新的Cookie值。</span></span><br><span class="line">            cookie.setValue(<span class="string">&quot;newValue2&quot;</span>);</span><br><span class="line"><span class="comment">//          3、调用response.addCookie()通知客户端保存修改</span></span><br><span class="line">            resp.addCookie(cookie);</span><br><span class="line">        &#125;</span><br><span class="line">        resp.getWriter().write(<span class="string">&quot;key1的Cookie已经修改好&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="浏览器查看-Cookie："><a href="#浏览器查看-Cookie：" class="headerlink" title="浏览器查看 Cookie："></a>浏览器查看 Cookie：</h3><p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/image-20210412171712463.png" alt="image-20210412171712463"></p>
<h3 id="Cookie-生命控制"><a href="#Cookie-生命控制" class="headerlink" title="Cookie 生命控制"></a>Cookie 生命控制</h3><p>Cookie 的生命控制指的是如何管理  Cookie 什么时候被销毁（删除） </p>
<p>setMaxAge() 正数      表示在指定的秒数后过期 </p>
<p>负数                            表示浏览器一关，Cookie 就会被删除（默认值是-1） </p>
<p>零                                表示马上删除 Cookie</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">life3600</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">&quot;life3600&quot;</span>, <span class="string">&quot;life3600&quot;</span>);</span><br><span class="line">    cookie.setMaxAge(<span class="number">60</span> * <span class="number">60</span>); <span class="comment">// 设置Cookie一小时之后被删除。无效</span></span><br><span class="line">    resp.addCookie(cookie);</span><br><span class="line">    resp.getWriter().write(<span class="string">&quot;已经创建了一个存活一小时的Cookie&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 马上删除一个Cookie</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> req</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> resp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ServletException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">deleteNow</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 先找到你要删除的Cookie对象</span></span><br><span class="line">    Cookie cookie = CookieUtils.findCookie(<span class="string">&quot;key4&quot;</span>, req.getCookies());</span><br><span class="line">    <span class="keyword">if</span> (cookie != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 调用setMaxAge(0);</span></span><br><span class="line">        cookie.setMaxAge(<span class="number">0</span>); <span class="comment">// 表示马上删除，都不需要等待浏览器关闭</span></span><br><span class="line">        <span class="comment">// 调用response.addCookie(cookie);</span></span><br><span class="line">        resp.addCookie(cookie);</span><br><span class="line"></span><br><span class="line">        resp.getWriter().write(<span class="string">&quot;key4的Cookie已经被删除&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认的会话级别的Cookie</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> req</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> resp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ServletException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">defaultLife</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">&quot;defalutLife&quot;</span>,<span class="string">&quot;defaultLife&quot;</span>);</span><br><span class="line">    cookie.setMaxAge(-<span class="number">1</span>);<span class="comment">//设置存活时间</span></span><br><span class="line">    resp.addCookie(cookie);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-Session"><a href="#4-Session" class="headerlink" title="4.Session"></a>4.Session</h2><h3 id="什么是-Session-会话"><a href="#什么是-Session-会话" class="headerlink" title="什么是 Session 会话?"></a>什么是 Session 会话?</h3><p>1、Session 就一个接口（HttpSession）。 </p>
<p>2、Session 就是会话。它是用来维护一个客户端和服务器之间关联的一种技术。 </p>
<p>3、每个客户端都有自己的一个 Session 会话。 </p>
<p>4、Session 会话中，我们经常用来保存<strong>用户登录之后</strong>的信息。</p>
<blockquote>
<p>Session 是另一种记录浏览器状态的机制。不同的是Cookie保存在浏览器中，Session保存在服务器中。用户使用浏览器访问服务器的时候，服务器把用户的信息以某种的形式记录在服务器，这就是Session</p>
</blockquote>
<h3 id="为什么要使用Session技术？"><a href="#为什么要使用Session技术？" class="headerlink" title="为什么要使用Session技术？"></a>为什么要使用Session技术？</h3><p><strong>Session比Cookie使用方便，Session可以解决Cookie解决不了的事情【Session可以存储对象，而Cookie只能存储字符串】。</strong></p>
<h3 id="如何创建-Session-和获取-id-号-是否为新）"><a href="#如何创建-Session-和获取-id-号-是否为新）" class="headerlink" title="如何创建 Session 和获取(id 号,是否为新）"></a>如何创建 Session 和获取(id 号,是否为新）</h3><p>如何创建和获取 Session。它们的 API 是一样的。 </p>
<p>request.getSession()    第一次调用是：创建 Session 会话之后调用都是：获取前面创建好的 Session 会话对象。 </p>
<p>isNew();                         判断到底是不是刚创建出来的（新的） true 表示刚创建 false 表示获取之前创建 </p>
<p>​     每个会话都有一个身份证号。也就是 ID 值。而且这个 ID 是唯一的。 </p>
<p>getId()                            得到 Session 的会话 id 值。</p>
<h3 id="Session-域数据的存取"><a href="#Session-域数据的存取" class="headerlink" title="Session 域数据的存取"></a>Session 域数据的存取</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setAttribute</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span>                           <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    req.getSession().setAttribute(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">    resp.getWriter().write(<span class="string">&quot;已经往Session中保存了数据&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">getAttribute</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> 							<span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        Object attribute = req.getSession().getAttribute(<span class="string">&quot;key1&quot;</span>);</span><br><span class="line">        resp.getWriter().write(<span class="string">&quot;从Session中获取出key1的数据是：&quot;</span> + attribute);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Session-生命周期控制"><a href="#Session-生命周期控制" class="headerlink" title="Session 生命周期控制"></a>Session 生命周期控制</h3><p>public void setMaxInactiveInterval(int interval) 设置 Session 的超时时间（以秒为单位），超过指定的时长，Session 就会被销毁。 </p>
<p>值为正数的时候，设定 Session 的超时时长。 </p>
<p>负数表示永不超时（极少使用） </p>
<p>public int getMaxInactiveInterval()    获取 Session 的超时时间 </p>
<p>public void invalidate()                      让当前 Session 会话马上超时无效。 </p>
<p>Session 默认的超时时间长为 30 分钟。 因为在 Tomcat 服务器的配置文件 web.xml中默认有以下的配置，它就表示配置了当前 Tomcat 服务器下所有的 Session 超时配置默认时长为：30 分钟。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>30<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果说。你希望你的 web 工程，默认的 Session 的超时时长为其他时长。你可以在你自己的 web.xml 配置文件中做 以上相同的配置。就可以修改你的 web 工程所有 Seession 的默认超时时长。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>20<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/image-20210412174417990.png" alt="image-20210412174417990"></p>
<h3 id="浏览器和-Session-之间关联的技术内幕"><a href="#浏览器和-Session-之间关联的技术内幕" class="headerlink" title="浏览器和 Session 之间关联的技术内幕"></a>浏览器和 Session 之间关联的技术内幕</h3><p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/image-20210412174537456.png" alt="image-20210412174537456"></p>
<p>问题来了：<strong>服务器是如何实现一个session为一个用户浏览器服务的？换个说法：为什么服务器能够为不同的用户浏览器提供不同session？</strong></p>
<p>HTTP协议是无状态的，<strong>Session不能依据HTTP连接来判断是否为同一个用户</strong>。于是乎：<strong>服务器向用户浏览器发送了一个名为JESSIONID的Cookie，它的值是Session的id值</strong>。其实Session依据Cookie来识别是否是同一个用户。</p>
<p>简单来说：Session <strong>之所以可以识别不同的用户，依靠的就是Cookie</strong></p>
<p>该Cookie是<strong>服务器自动颁发给浏览器的</strong>，不用我们手工创建的。<strong>该Cookie的maxAge值默认是-1，也就是说仅当前浏览器使用，不将该Cookie存在硬盘中</strong></p>
<h1 id="Ⅷ-常见面试题"><a href="#Ⅷ-常见面试题" class="headerlink" title="Ⅷ. 常见面试题"></a>Ⅷ. 常见面试题</h1><h2 id="1-Tomcat-有哪几种Connector-运行模式-优化-？"><a href="#1-Tomcat-有哪几种Connector-运行模式-优化-？" class="headerlink" title="1.Tomcat 有哪几种Connector 运行模式(优化)？"></a>1.Tomcat 有哪几种Connector 运行模式(优化)？</h2><ol>
<li>bio(blocking I/O)： <strong>传统的Java I/O操作，同步且阻塞IO。</strong></li>
<li>nio(non-blocking I/O)：<strong>JDK1.4开始支持，同步阻塞或同步非阻塞IO</strong></li>
<li>apr(Apache Portable Runtime/Apache可移植运行库)：Tomcat将以JNI的形式调用Apache HTTP服务器的核心动态链接库来处理文件读取或网络传输操作，从而大大地<strong>提高Tomcat对静态文件的处理性能</strong></li>
<li>aio（nio.2）<strong>JDK7开始支持，异步非阻塞IO</strong></li>
</ol>
<h2 id="2-Servlet生命周期"><a href="#2-Servlet生命周期" class="headerlink" title="2.Servlet生命周期"></a>2.Servlet生命周期</h2><p>Servlet生命周期可分为5个步骤</p>
<ol>
<li><strong>加载Servlet</strong>。当Tomcat第一次访问Servlet的时候，<strong>Tomcat会负责创建Servlet的实例</strong></li>
<li><strong>初始化</strong>。当Servlet被实例化后，Tomcat会<strong>调用init()方法初始化这个对象</strong></li>
<li><strong>处理服务</strong>。当浏览器<strong>访问Servlet</strong>的时候，Servlet <strong>会调用service()方法处理请求</strong></li>
<li><strong>销毁</strong>。当Tomcat关闭时或者检测到Servlet要从Tomcat删除的时候会自动调用destroy()方法，<strong>让该实例释放掉所占的资源</strong>。一个Servlet如果长时间不被使用的话，也会被Tomcat自动销毁</li>
<li><strong>卸载</strong>。当Servlet调用完destroy()方法后，等待垃圾回收。如果<strong>有需要再次使用这个Servlet，会重新调用init()方法进行初始化操作</strong>。</li>
</ol>
<p>简单总结：<strong>只要访问Servlet，service()就会被调用。init()只有第一次访问Servlet的时候才会被调用。destroy()只有在Tomcat关闭的时候才会被调用。</strong></p>
<h2 id="3-get方式和post方式有何区别"><a href="#3-get方式和post方式有何区别" class="headerlink" title="3.get方式和post方式有何区别"></a>3.get方式和post方式有何区别</h2><p>数据携带上:</p>
<ul>
<li>GET方式：在URL地址后附带的参数是有限制的，其数据容量通常不能超过1K。</li>
<li>POST方式：可以在请求的实体内容中向服务器发送数据，传送的数据量无限制。</li>
</ul>
<p>请求参数的位置上:</p>
<ul>
<li>GET方式：请求参数放在URL地址后面，以?的方式来进行拼接</li>
<li>POST方式:请求参数放在HTTP请求包中</li>
</ul>
<p>用途上:</p>
<ul>
<li><p>GET方式一般用来获取数据</p>
</li>
<li><p>POST方式一般用来提交数据</p>
</li>
<li><ul>
<li>首先是因为GET方式携带的数据量比较小，无法带过去很大的数量</li>
<li>POST方式提交的参数后台更加容易解析(使用POST方式提交的中文数据，后台也更加容易解决)</li>
<li>GET方式比POST方式要快。具体原因：<a href="https://www.cnblogs.com/strayling/p/3580048.html">为什么GET方式比POST方式要快 ？</a></li>
</ul>
</li>
</ul>
<h2 id="4-forward和redirect的区别"><a href="#4-forward和redirect的区别" class="headerlink" title="4.forward和redirect的区别"></a>4.forward和redirect的区别</h2><ul>
<li><p><strong>实际发生位置不同，地址栏不同</strong></p>
</li>
<li><ul>
<li>转发是发生在服务器的</li>
<li><strong>转发是由服务器进行跳转的</strong>，也就是说<strong>浏览器是不知道该跳转的动作，转发是对浏览器透明的</strong>。<strong>实现转发只是一次的http请求</strong>，<strong>一次转发中request和response对象都是同一个</strong>。这也解释了为什么可以使用<strong>request作为域对象进行Servlet之间的通讯。</strong></li>
</ul>
</li>
<li><p>重定向是发生在浏览器的 - <strong>重定向是由浏览器进行跳转的</strong>，进行重定向跳转的时候，<strong>浏览器的地址会发生变化的</strong>。实现重定向的原理是由response的状态码和Location头组合而实现的。<strong>这是由浏览器进行的页面跳转</strong>实现重定向<strong>会发出两个http请求</strong>，<strong>request域对象是无效的，因为它不是同一个request对象</strong></p>
</li>
<li><p><strong>用法不同:</strong></p>
</li>
<li><p>很多人都搞不清楚转发和重定向的时候，<strong>资源地址究竟怎么写</strong>。有的时候要把应用名写上，有的时候不用把应用名写上。很容易把人搞晕。记住一个原则： <strong>给服务器用的直接从资源名开始写，给浏览器用的要把应用名写上</strong></p>
</li>
<li><ul>
<li>request.getRequestDispatcher(“/资源名 URI”).forward(request,response)</li>
<li><strong>转发时”/“代表的是本应用程序的根目录【zhongfucheng】</strong> - response.send(“/web应用/资源名 URI”); - <strong>重定向时”/“代表的是webapps目录</strong></li>
</ul>
</li>
<li><p><strong>能够去往的URL的范围不一样:</strong></p>
</li>
<li><ul>
<li><strong>转发是服务器跳转只能去往当前web应用的资源</strong></li>
<li><strong>重定向是服务器跳转，可以去往任何的资源</strong></li>
</ul>
</li>
<li><p><strong>传递数据的类型不同</strong></p>
</li>
<li><ul>
<li><strong>转发的request对象可以传递各种类型的数据，包括对象</strong></li>
<li><strong>重定向只能传递字符串</strong></li>
</ul>
</li>
<li><p><strong>跳转的时间不同</strong></p>
</li>
<li><ul>
<li><strong>转发时：执行到跳转语句时就会立刻跳转</strong></li>
<li><strong>重定向：整个页面执行完之后才执行跳转</strong></li>
</ul>
</li>
</ul>
<p>那么转发(forward)和重定向(redirect)使用哪一个？</p>
<ul>
<li>根据上面说明了转发和重定向的区别也可以很容易概括出来<strong>。转发是带着转发前的请求的参数的。重定向是新的请求</strong>。</li>
</ul>
<p>典型的应用场景：</p>
<ol>
<li>转发: 访问 Servlet 处理业务逻辑，然后 forward 到 jsp 显示处理结果，浏览器里 URL 不变</li>
<li>重定向: 提交表单，处理成功后 redirect 到另一个 jsp，防止表单重复提交，浏览器里 URL 变了</li>
</ol>
<h2 id="5-tomcat容器是如何创建servlet类实例？用到了什么原理？"><a href="#5-tomcat容器是如何创建servlet类实例？用到了什么原理？" class="headerlink" title="5.tomcat容器是如何创建servlet类实例？用到了什么原理？"></a>5.tomcat容器是如何创建servlet类实例？用到了什么原理？</h2><ol>
<li>当容器启动时，会读取在webapps目录下所有的web应用中的web.xml文件，然后对 <strong>xml文件进行解析，并读取servlet注册信息</strong>。然后，将每个应用中注册的servlet类都进行加载，并通过 <strong>反射的方式实例化</strong>。（有时候也是在第一次请求时实例化）</li>
<li>在servlet注册时加上1如果为正数，则在一开始就实例化，如果不写或为负数，则第一次请求实例化。</li>
</ol>
<h2 id="6-什么是cookie？Session和cookie有什么区别？"><a href="#6-什么是cookie？Session和cookie有什么区别？" class="headerlink" title="6.什么是cookie？Session和cookie有什么区别？"></a>6.什么是cookie？Session和cookie有什么区别？</h2><ul>
<li>网页之间的<strong>交互是通过HTTP协议传输数据的，</strong>而Http协议是<strong>无状态的协议</strong>。无状态的协议是什么意思呢？<strong>一旦数据提交完后，浏览器和服务器的连接就会关闭，再次交互的时候需要重新建立新的连接</strong>。</li>
<li>服务器无法确认用户的信息，于是乎，W3C就提出了：<strong>给每一个用户都发一个通行证，无论谁访问的时候都需要携带通行证，这样服务器就可以从通行证上确认用户的信息</strong>。通行证就是Cookie</li>
</ul>
<p>​       <strong>1. 从存储方式上比较</strong></p>
<ul>
<li><ul>
<li>Cookie只能存储字符串，如果要存储非ASCII字符串还要对其编码。</li>
<li>Session可以存储任何类型的数据，可以把Session看成是一个容器</li>
</ul>
</li>
<li><p><strong>2.从有效期上比较</strong></p>
</li>
<li><ul>
<li>Cookie保存在硬盘中，只需要设置maxAge属性为比较大的正整数，即使关闭浏览器，Cookie还是存在的</li>
<li><strong>Session的保存在服务器中，设置maxInactiveInterval属性值来确定Session的有效期。并且Session依赖于名为JSESSIONID的Cookie，该Cookie默认的maxAge属性为-1。如果关闭了浏览器，该Session虽然没有从服务器中消亡，但也就失效了。</strong></li>
</ul>
</li>
<li><p><strong>3. 从对服务器的负担比较</strong></p>
</li>
<li><ul>
<li>Session是保存在服务器的，每个用户都会产生一个Session，如果是并发访问的用户非常多，是不能使用Session的，Session会消耗大量的内存。</li>
<li>Cookie是保存在客户端的。不占用服务器的资源。像baidu、Sina这样的大型网站，一般都是使用Cookie来进行会话跟踪。</li>
</ul>
</li>
<li><p><strong>4. 从浏览器的支持上比较</strong></p>
</li>
<li><ul>
<li>如果浏览器禁用了Cookie，那么Cookie是无用的了！</li>
<li>如果浏览器禁用了Cookie，Session可以通过URL地址重写来进行会话跟踪。</li>
</ul>
</li>
<li><p><strong>5. 从跨域名上比较</strong></p>
</li>
<li><ul>
<li>Cookie可以设置domain属性来实现跨域名</li>
<li>Session只在当前的域名内有效，不可夸域名</li>
</ul>
</li>
</ul>
<p><strong>6.从隐私安全上比较</strong></p>
<ul>
<li><strong>Cookie存储在浏览器中，对客户端是可见的</strong>。信息容易泄露出去。如果使用Cookie，最好将Cookie加密</li>
<li><strong>Session存储在服务器上，对客户端是透明的</strong>。不存在敏感信息泄露问题。</li>
</ul>
<h2 id="7-Servlet安全性问题"><a href="#7-Servlet安全性问题" class="headerlink" title="7.Servlet安全性问题"></a>7.Servlet安全性问题</h2><p>由于Servlet是单例的，当多个用户访问Servlet的时候，<strong>服务器会为每个用户创建一个线程</strong>。<strong>当多个用户并发访问Servlet共享资源的时候就会出现线程安全问题</strong>。</p>
<p>原则：</p>
<ol>
<li>如果一个<strong>变量需要多个用户共享</strong>，则应当在访问该变量的时候，<strong>加同步机制synchronized (对象){}</strong></li>
<li>如果一个变量<strong>不需要共享</strong>，则<strong>直接在 doGet() 或者 doPost()定义</strong>.这样不会存在线程安全问题</li>
</ol>
]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring5框架学习系列（一）</title>
    <url>/2021/09/04/spring5%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0(%E4%B8%80)/</url>
    <content><![CDATA[<h1 id="spring5框架概述"><a href="#spring5框架概述" class="headerlink" title="spring5框架概述"></a>spring5框架概述</h1><p>1.Spring 是轻量级的开源的 JavaEE 框架。</p>
<p>2.Spring 可以解决企业应用开发的复杂性。</p>
<p>3.Spring 有两个核心部分：IOC 和 Aop </p>
<ul>
<li><p>IOC：控制反转，把创建对象过程交给 Spring 进行管理 </p>
</li>
<li><p>Aop：面向切面，不修改源代码进行功能增强</p>
<span id="more"></span>

</li>
</ul>
<p>4.Spring 特点 </p>
<pre><code>    * 方便解耦，简化开发 
    * Aop 编程支持 
    * 方便程序测试 
    * 方便和其他框架进行整合 
    * 方便进行事务操作 
    * 降低 API 开发难度
</code></pre>
<h2 id="spring入门"><a href="#spring入门" class="headerlink" title="spring入门"></a>spring入门</h2><h3 id="1-下载Spring5"><a href="#1-下载Spring5" class="headerlink" title="1.下载Spring5"></a>1.下载Spring5</h3><p>下载地址：<a href="https://repo.spring.io/release/org/springframework/spring/">https://repo.spring.io/release/org/springframework/spring/</a></p>
<h3 id="2-创建一个普通的Java项目"><a href="#2-创建一个普通的Java项目" class="headerlink" title="2.创建一个普通的Java项目"></a>2.创建一个普通的Java项目</h3><p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/12.png"></p>
<h3 id="3-导入Spring5相关的jar包"><a href="#3-导入Spring5相关的jar包" class="headerlink" title="3.导入Spring5相关的jar包"></a>3.导入Spring5相关的jar包</h3><p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/13.png"></p>
<h3 id="4-用Spring的方式来创建对象"><a href="#4-用Spring的方式来创建对象" class="headerlink" title="4.用Spring的方式来创建对象"></a>4.用Spring的方式来创建对象</h3><p>首先创建一个普通类，然后在这个类里面创建一个普通的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user的add方法........&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5-创建-Spring-配置文件，在配置文件配置创建的对象"><a href="#5-创建-Spring-配置文件，在配置文件配置创建的对象" class="headerlink" title="5.创建 Spring 配置文件，在配置文件配置创建的对象"></a>5.创建 Spring 配置文件，在配置文件配置创建的对象</h3><p>Spring里创建对象有多种方式，可以使用配置文件，还可以使用注解方式，这里先简单的使用配置文件的方式来创建对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--配置User对象创建--&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;user&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.atguigu.Spring5.User&quot;</span>&gt;&lt;/bean&gt;</span><br><span class="line">        <span class="comment">//注意这里的id是自己起的名字，对应后面的getBean方法中的var1</span></span><br><span class="line">        <span class="comment">//getBean(String var1, Class&lt;T&gt; var2) throws BeansException;</span></span><br></pre></td></tr></table></figure>

<h3 id="6-进行测试代码编写"><a href="#6-进行测试代码编写" class="headerlink" title="6.进行测试代码编写"></a>6.进行测试代码编写</h3><p>本代码只完成测试功能，在后续的工作中不会用到。建立一个测试类专门用来做测试。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testSpring5</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAdd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//具体的测试代码，代码只用在测试中</span></span><br><span class="line">        <span class="comment">//1.加载Spring的配置文件</span></span><br><span class="line">        <span class="comment">//注意：由于类名有ClassPath即类路径，也就是src下所以可以直接写配置文件的名字，</span></span><br><span class="line">        <span class="comment">// 如果不在src下，则需要写下相对路径或者绝对路径（类名是FileSystemXmlApplication）</span></span><br><span class="line">        BeanFactory context =</span><br><span class="line">                <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;bean1.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.获取创建的对象</span></span><br><span class="line">        User user = context.getBean(<span class="string">&quot;user&quot;</span>, User.class);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        user.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果为：</span><br><span class="line">    com.atguigu.Spring5.User@7c729a55</span><br><span class="line">    user的add方法........</span><br></pre></td></tr></table></figure>

<p>程序主要是通过Spring容器来访问容器中的Bean，==ApplicationContext是Spring容器最常用的接口，该接口有如下两个实现类==：</p>
<ul>
<li>ClassPathXmlApplicationContext: 从类加载路径下搜索配置文件，并根据配置文件来创建Spring容器。</li>
<li>FileSystemXmlApplicationContext: 从文件系统的相对路径或绝对路径下去搜索配置文件，并根据配置文件来创建Spring容器。</li>
</ul>
<h2 id="IOC容器"><a href="#IOC容器" class="headerlink" title="IOC容器"></a>IOC容器</h2><h3 id="Ⅰ-IOC底层的原理"><a href="#Ⅰ-IOC底层的原理" class="headerlink" title="Ⅰ.IOC底层的原理"></a>Ⅰ.IOC底层的原理</h3><h4 id="什么是IOC"><a href="#什么是IOC" class="headerlink" title="什么是IOC"></a>什么是IOC</h4><ul>
<li>控制反转，把对象创建和对象之间的调用过程，交给Spring进行管理。</li>
<li>使用Ioc的目的：为了降低耦合度</li>
<li>上文中的入门案例就是IOC实现</li>
</ul>
<p>先来看spring官网的关于IOC容器的解释：</p>
<blockquote>
<p>The org.springframework.context.ApplicationContext interface represents the Spring IoC container and is responsible for instantiating, configuring, and assembling the beans.</p>
</blockquote>
<p>大意就是：</p>
<ul>
<li>Spring IOC容器就是一个 <strong>org.springframework.context.ApplicationContext</strong> 的实例化对象。</li>
<li>容器负责实例化，配置以及装配一个bean。</li>
</ul>
<p><strong>从代码层面上看：spring容器就是一个实现了ApplicationContext接口的对象。</strong></p>
<p><strong>从功能层面来看：Spring 容器是 Spring 框架的核心，是用来管理对象的。容器将创建对象，把它们连接在一起，配置它们，并管理他们的整个生命周期从创建到销毁。</strong></p>
<h4 id="IOC底层原理"><a href="#IOC底层原理" class="headerlink" title="IOC底层原理"></a>IOC底层原理</h4><ul>
<li>xml注解、工厂模式、反射（得到class文件，操作类中的内容）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//工厂模式：</span></span><br><span class="line"><span class="comment">//使用工厂模式的目的是将耦合度降低到最低限度,例如在下面的例子中，当有很多service调用dao层时，dao层包发生改变所有的service都需要改，而有了工厂类以后只需要改变工厂类就可以，从而降低了代码的耦合度。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line">    excute()&#123;</span><br><span class="line">        UserDao dao = UserFactory.getDao();</span><br><span class="line">        dao.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserDao</span></span>&#123;</span><br><span class="line">    add()&#123;</span><br><span class="line">        .........;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserFactory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">UserDao</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UserDao();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>==IOC过程分析：==</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一步：xml配置文件，配置创建的对象</span></span><br><span class="line">&lt;bean id=<span class="string">&quot;user&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.atguigu.Spring5.User&quot;</span>&gt;&lt;/bean&gt;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//第二步：有service类和dao类，创建工厂类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">UserFactory</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> userDao <span class="title">getDao</span><span class="params">()</span></span>&#123;</span><br><span class="line">            String classValue = <span class="class"><span class="keyword">class</span>属性值</span>;<span class="comment">//xml解析</span></span><br><span class="line">            <span class="comment">//通过反射创建对象</span></span><br><span class="line">            Class clazz = Class.forName(classValue);</span><br><span class="line">            <span class="keyword">return</span> (UserDao)calzz.newInstance();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br></pre></td></tr></table></figure>

<h4 id="IOC接口"><a href="#IOC接口" class="headerlink" title="IOC接口"></a>IOC接口</h4><ul>
<li><p>IOC思想基于IOC容器完成，IOC容器底层就是对象工厂</p>
</li>
<li><p>Spring提供了IOC容器实现的两种方式：（即两个接口）</p>
<p>（1）BeanFactory：IOC容器基本实现方式，时Spring内部的使用接口，不提供开发人员进行使用。</p>
<ul>
<li>加载配置文件的时候不会创建对象，获取对象的时候才去创建对象</li>
</ul>
<p>（2）ApplicationContext：BeanFactory接口的子接口，提供更多更强大的功能，一般由开发人员进行使用。</p>
<ul>
<li>加载配置文件的时候就会把在配置文件的对象进行创建。</li>
</ul>
</li>
<li><p>ApplicationContext接口有实现类</p>
<p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/16.png"></p>
</li>
</ul>
<ul>
<li>ClassPathXmlApplicationContext: 从类加载路径下搜索配置文件，并根据配置文件来创建Spring容器。</li>
<li>FileSystemXmlApplicationContext: 从文件系统的相对路径或绝对路径下去搜索配置文件，并根据配置文件来创建Spring容器。</li>
</ul>
<h3 id="Ⅱ-IOC操作Bean管理（概念）"><a href="#Ⅱ-IOC操作Bean管理（概念）" class="headerlink" title="Ⅱ.IOC操作Bean管理（概念）"></a>Ⅱ.IOC操作Bean管理（概念）</h3><h4 id="1-什么是Bean管理"><a href="#1-什么是Bean管理" class="headerlink" title="1.什么是Bean管理"></a>1.什么是Bean管理</h4><h5 id="（0）Bean管理指的是两个操作（1）（2）"><a href="#（0）Bean管理指的是两个操作（1）（2）" class="headerlink" title="（0）Bean管理指的是两个操作（1）（2）"></a>（0）Bean管理指的是两个操作（1）（2）</h5><h5 id="（1）Spring创建对象"><a href="#（1）Spring创建对象" class="headerlink" title="（1）Spring创建对象"></a>（1）Spring创建对象</h5><h5 id="（2）Spring注入属性"><a href="#（2）Spring注入属性" class="headerlink" title="（2）Spring注入属性"></a>（2）Spring注入属性</h5><h4 id="2-Bean管理操作有两种方式"><a href="#2-Bean管理操作有两种方式" class="headerlink" title="2.Bean管理操作有两种方式"></a>2.Bean管理操作有两种方式</h4><h5 id="（1）基于xml配置文件方式实现"><a href="#（1）基于xml配置文件方式实现" class="headerlink" title="（1）基于xml配置文件方式实现"></a>（1）基于xml配置文件方式实现</h5><h5 id="（2）基于注解方式实现"><a href="#（2）基于注解方式实现" class="headerlink" title="（2）基于注解方式实现"></a>（2）基于注解方式实现</h5><h3 id="Ⅲ-IOC操作Bean管理（基于xml方式）"><a href="#Ⅲ-IOC操作Bean管理（基于xml方式）" class="headerlink" title="Ⅲ.IOC操作Bean管理（基于xml方式）"></a>Ⅲ.IOC操作Bean管理（基于xml方式）</h3><h4 id="1-基于xml方式创建对象"><a href="#1-基于xml方式创建对象" class="headerlink" title="1.基于xml方式创建对象"></a>1.基于xml方式创建对象</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;user&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.atguigu.Spring5.User&quot;</span>&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>（1）在 spring 配置文件中，使用 bean 标签，标签里面添加对应属性，就可以实现对象的创建。</p>
<p>（2）在 bean 标签有很多属性，介绍常用的属性。</p>
<ul>
<li>id 属性：唯一标识 user</li>
<li>class 属性：类全路径（包类路径）com.atguigu.Spring5.User</li>
<li>name属性：功能与id属性类似，区别在于name属性总可以加入特殊符号，但id属性不可以。用的很少</li>
</ul>
<p>（3）创建对象时候，默认也是执行无参数构造方法完成对象的创建。</p>
<h4 id="2-基于xml方式注入属性"><a href="#2-基于xml方式注入属性" class="headerlink" title="2.基于xml方式注入属性"></a>2.基于xml方式注入属性</h4><p>DI：依赖注入，就是注入属性。是IOC中的一种具体实现。注入属性需要在创建对象的基础之上完成。</p>
<p>==第一种注入方式：使用set方法进行注入。（bean标签+property标签加属性的值就可以完成注入）==</p>
<p>（1）创建类，定义属性和对应的set方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示使用set方法进行注入属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建属性</span></span><br><span class="line">    <span class="keyword">private</span> String bname;</span><br><span class="line">    <span class="keyword">private</span> String bauthor;</span><br><span class="line">    <span class="comment">//创建属性对应的set方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBname</span><span class="params">(String bname)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bname = bname;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBauthor</span><span class="params">(String bauthor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bauthor = bauthor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）在Spring配置文件配置对象创建，配置属性注入。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--<span class="number">2</span> set方法注入属性--&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;book&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.atguigu.Spring5.Book&quot;</span>&gt;</span><br><span class="line">        &lt;!--使用property完成属性注入</span><br><span class="line">         name：类里面属性名称</span><br><span class="line">            value：向属性注入的值--&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;bname&quot;</span> value=<span class="string">&quot;易筋经&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;bauthor&quot;</span> value=<span class="string">&quot;达摩老祖&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br></pre></td></tr></table></figure>



<p>==第二种注入方式：使用有参数构造进行注入==</p>
<p>（1）创建类，定义属性，创建属性对应有参数构造方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用有参数构造注入</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Orders</span> </span>&#123;</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="keyword">private</span> String oname;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="comment">//有参数构造</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Orders</span><span class="params">(String oname,String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.oname = oname;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ordersTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(oname+<span class="string">&quot;::&quot;</span>+address);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）在 spring 配置文件中进行配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--<span class="number">3</span> 有参数构造注入属性--&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;orders&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.atguigu.Spring5.Orders&quot;</span>&gt;</span><br><span class="line">        &lt;constructor-arg name=<span class="string">&quot;oname&quot;</span> value=<span class="string">&quot;电脑&quot;</span>&gt;&lt;/constructor-arg&gt;</span><br><span class="line">        &lt;constructor-arg name=<span class="string">&quot;address&quot;</span> value=<span class="string">&quot;China&quot;</span>&gt;&lt;/constructor-arg&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">        注：&lt;constructor-arg&gt;&lt;/constructor-arg&gt;标签的作用：如果不加该标签则默认使用的是无参构造创建对象，而不是有参构造创建对象。</span><br></pre></td></tr></table></figure>

<h4 id="3-p名称空间注入（本质还是set方法注入属性）"><a href="#3-p名称空间注入（本质还是set方法注入属性）" class="headerlink" title="3.p名称空间注入（本质还是set方法注入属性）"></a>3.p名称空间注入（本质还是set方法注入属性）</h4><p>（1）使用p名称空间注入，可以简化基于xml配置方式。</p>
<p>第一步：在配置文件中添加p名称空间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="line">       xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">        <span class="comment">//在配置文件里加入p名称空间</span></span><br><span class="line">       xmlns:p=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<p>第二步 进行属性注入，在 bean 标签里面进行操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--<span class="number">2</span> set方法注入属性--&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;book&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.atguigu.Spring5.Book&quot;</span> p:bname=<span class="string">&quot;九阳神功&quot;</span> p:bauthor=<span class="string">&quot;无名氏&quot;</span>&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">        底层还是使用set方法注入属性，但是对set方法注入进行了一定的简化。</span><br></pre></td></tr></table></figure>

<h3 id="Ⅳ-IOC操作Bean管理（xml注入其他类型属性）"><a href="#Ⅳ-IOC操作Bean管理（xml注入其他类型属性）" class="headerlink" title="Ⅳ.IOC操作Bean管理（xml注入其他类型属性）"></a>Ⅳ.IOC操作Bean管理（xml注入其他类型属性）</h3><h4 id="1-字面量"><a href="#1-字面量" class="headerlink" title="1.字面量"></a>1.字面量</h4><p>字面量就是为属性设置一个固定值，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> String bname = <span class="string">&quot;&quot;</span>;也可以使用&lt;property&gt;&lt;/property&gt;标签来设置字面量。</span><br></pre></td></tr></table></figure>

<p>（1）设置属性值时设置为空值null。使用null标签（只是说明可以设置为null值，实际上引用类型默认为null）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--设置<span class="keyword">null</span>值--&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;address&quot;</span> &gt;</span><br><span class="line">            &lt;<span class="keyword">null</span>&gt;&lt;/<span class="keyword">null</span>&gt;</span><br><span class="line">        &lt;/property&gt;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">com.atguigu.Spring5.Book@<span class="number">4802796d</span></span><br><span class="line">易筋经::达摩老祖::<span class="keyword">null</span>             可见空值属性已经设置成功了。</span><br></pre></td></tr></table></figure>



<p>（2）属性值包含特殊符号。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--属性值包含特殊符号</span><br><span class="line">            <span class="number">1</span> 把&lt;&gt;进行转义 &amp;lt; &amp;gt;</span><br><span class="line">            <span class="number">2</span> 把带特殊符号内容写到CDATA</span><br><span class="line">        --&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;address&quot;</span>&gt;</span><br><span class="line">            &lt;value&gt;&lt;![CDATA[&lt;&lt;南京&gt;&gt;]]&gt;&lt;/value&gt;</span><br><span class="line">        &lt;/property&gt;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">com.atguigu.Spring5.Book@65fb9ffc</span><br><span class="line">易筋经::达摩老祖::&lt;&lt;南京&gt;&gt;</span><br></pre></td></tr></table></figure>

<h4 id="2-注入属性-外部-bean"><a href="#2-注入属性-外部-bean" class="headerlink" title="2.注入属性-外部 bean"></a>2.注入属性-外部 bean</h4><p>（1）创建两个类 service 类和 dao 类 。</p>
<p>（2）在 service 调用 dao 里面的方法。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在Spring中做到</span></span><br><span class="line">    <span class="comment">//创建UserDao类属性,生成set方法</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserDao</span><span class="params">(UserDao userDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Service add...........&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//原始方式</span></span><br><span class="line">        <span class="comment">//创建userDao对象</span></span><br><span class="line">        UserDao userDao = <span class="keyword">new</span> UserDaoImpl();</span><br><span class="line">        userDao.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>（3）在 spring 配置文件中进行配置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--<span class="number">1</span> service和dao对象创建--&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;userService&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.atguigu.Spring5.service.UserService&quot;</span>&gt;</span><br><span class="line">        &lt;!--注入userDao对象</span><br><span class="line">            name属性：类里面属性名称</span><br><span class="line">            ref属性：创建userDao对象bean标签id值</span><br><span class="line">        --&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;userDao&quot;</span> ref=<span class="string">&quot;userDaoImpl&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">        &lt;!--注意接口不能<span class="keyword">new</span>对象，应该找他的实现类--&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;userDaoImpl&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.atguigu.Spring5.dao.UserDaoImpl&quot;</span>&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure>



<h4 id="3-注入属性-内部-bean"><a href="#3-注入属性-内部-bean" class="headerlink" title="3.注入属性-内部 bean"></a>3.注入属性-内部 bean</h4><p>（1）一对多关系：部门和员工</p>
<p>一个部门里有多个员工，一个员工属于一个部门。部门是一，员工是多。</p>
<p>（2）实体类之间便是一对多关系，员工表示所属部门，使用对象类型属性进行表示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//部门类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String dname;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDname</span><span class="params">(String dname)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dname = dname;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//员工类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Emp</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String ename;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//表示员工属于某一个部门，适用对象形式表示</span></span><br><span class="line">    <span class="keyword">private</span> Dept dept;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDept</span><span class="params">(Dept dept)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dept = dept;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEname</span><span class="params">(String ename)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ename = ename;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGender</span><span class="params">(String gender)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）在 spring 配置文件中进行配置.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--内部bean，即在一个bean里可以再嵌套另一个对象--&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;emp&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.atguigu.Spring5.bean.Emp&quot;</span>&gt;</span><br><span class="line">        &lt;!--设置两个普通属性--&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;ename&quot;</span> value=<span class="string">&quot;lucy&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;gender&quot;</span> value=<span class="string">&quot;女&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">        &lt;!--设置对象类型属性--&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;dept&quot;</span>&gt;</span><br><span class="line">            &lt;bean id=<span class="string">&quot;dept&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.atguigu.Spring5.bean.Dept&quot;</span>&gt;</span><br><span class="line">                &lt;property name=<span class="string">&quot;dname&quot;</span> value=<span class="string">&quot;安保部&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">            &lt;/bean&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h4 id="4-注入属性-级联赋值"><a href="#4-注入属性-级联赋值" class="headerlink" title="4.注入属性-级联赋值"></a>4.注入属性-级联赋值</h4><p>（1）第一种写法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--级联赋值--&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;emp&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.atguigu.Spring5.bean.Emp&quot;</span>&gt;</span><br><span class="line">        &lt;!--设置两个普通属性--&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;ename&quot;</span> value=<span class="string">&quot;lucy&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;gender&quot;</span> value=<span class="string">&quot;女&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">        &lt;!--级联赋值--&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;dept&quot;</span> ref=<span class="string">&quot;dept&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;dept&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.atguigu.Spring5.bean.Dept&quot;</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;dname&quot;</span> value=<span class="string">&quot;财务部&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>（2）第二种写法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--级联赋值--&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;emp&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.atguigu.Spring5.bean.Emp&quot;</span>&gt;</span><br><span class="line">        &lt;!--设置两个普通属性--&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;ename&quot;</span> value=<span class="string">&quot;lucy&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;gender&quot;</span> value=<span class="string">&quot;女&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">        &lt;!--级联赋值--&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;dept&quot;</span> ref=<span class="string">&quot;dept&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">        <span class="comment">//注意要使用dept.dname需要在Emp类中写get方法，否则会报错</span></span><br><span class="line">        &lt;property name=<span class="string">&quot;dept.dname&quot;</span> value=<span class="string">&quot;技术部&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;dept&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.atguigu.Spring5.bean.Dept&quot;</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;dname&quot;</span> value=<span class="string">&quot;财务部&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h3 id="Ⅴ-IOC-操作-Bean-管理（xml-注入集合属性）"><a href="#Ⅴ-IOC-操作-Bean-管理（xml-注入集合属性）" class="headerlink" title="Ⅴ.IOC 操作 Bean 管理（xml 注入集合属性）"></a>Ⅴ.IOC 操作 Bean 管理（xml 注入集合属性）</h3><h4 id="1、注入数组类型属性"><a href="#1、注入数组类型属性" class="headerlink" title="1、注入数组类型属性"></a>1、注入数组类型属性</h4><h4 id="2、注入-List-集合类型属性"><a href="#2、注入-List-集合类型属性" class="headerlink" title="2、注入 List 集合类型属性"></a>2、注入 List 集合类型属性</h4><h4 id="3、注入-Map-集合类型属性"><a href="#3、注入-Map-集合类型属性" class="headerlink" title="3、注入 Map 集合类型属性"></a>3、注入 Map 集合类型属性</h4><p>（1）创建类，定义数组、list、map、set 类型属性，生成对应 set 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stu</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1 数组类型属性</span></span><br><span class="line">    <span class="keyword">private</span> String[] courses;</span><br><span class="line">    <span class="comment">//2 list集合类型属性</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; list;</span><br><span class="line">    <span class="comment">//3 map集合类型属性</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,String&gt; maps;</span><br><span class="line">    <span class="comment">//4 set集合类型属性</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; sets;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//学生所学多门课程</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Course&gt; courseList;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCourseList</span><span class="params">(List&lt;Course&gt; courseList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.courseList = courseList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSets</span><span class="params">(Set&lt;String&gt; sets)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sets = sets;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCourses</span><span class="params">(String[] courses)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.courses = courses;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setList</span><span class="params">(List&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMaps</span><span class="params">(Map&lt;String, String&gt; maps)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maps = maps;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Arrays.toString(courses));</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        System.out.println(maps);</span><br><span class="line">        System.out.println(sets);</span><br><span class="line">        System.out.println(courseList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）在 spring 配置文件进行配置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--<span class="number">1</span> 集合类型属性注入--&gt;</span><br><span class="line">    &lt;!--首先用bean标签创建对象--&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;stu&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.atguigu.Spring5.collectionType.Stu&quot;</span>&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;!--数组类型属性注入--&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;courses&quot;</span>&gt;</span><br><span class="line">            &lt;array&gt;</span><br><span class="line">                &lt;value&gt;java课程&lt;/value&gt;</span><br><span class="line">                &lt;value&gt;数据库课程&lt;/value&gt;</span><br><span class="line">            &lt;/array&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;!--list类型属性注入--&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;list&quot;</span>&gt;</span><br><span class="line">            &lt;list&gt;</span><br><span class="line">                &lt;value&gt;张三&lt;/value&gt;</span><br><span class="line">                &lt;value&gt;小三&lt;/value&gt;</span><br><span class="line">            &lt;/list&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;!--map类型属性注入--&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;maps&quot;</span>&gt;</span><br><span class="line">            &lt;map&gt;</span><br><span class="line">                &lt;entry key=<span class="string">&quot;JAVA&quot;</span> value=<span class="string">&quot;java&quot;</span>&gt;&lt;/entry&gt;</span><br><span class="line">                &lt;entry key=<span class="string">&quot;PHP&quot;</span> value=<span class="string">&quot;php&quot;</span>&gt;&lt;/entry&gt;</span><br><span class="line">            &lt;/map&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;!--set类型属性注入--&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;sets&quot;</span>&gt;</span><br><span class="line">            &lt;set&gt;</span><br><span class="line">                &lt;value&gt;MySQL&lt;/value&gt;</span><br><span class="line">                &lt;value&gt;Redis&lt;/value&gt;</span><br><span class="line">            &lt;/set&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;!--注入list集合类型，值是对象--&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;courseList&quot;</span>&gt;</span><br><span class="line">            &lt;list&gt;</span><br><span class="line">                &lt;ref bean=<span class="string">&quot;course1&quot;</span>&gt;&lt;/ref&gt;</span><br><span class="line">                &lt;ref bean=<span class="string">&quot;course2&quot;</span>&gt;&lt;/ref&gt;</span><br><span class="line">            &lt;/list&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--创建多个course对象--&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;course1&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.atguigu.Spring5.collectionType.Course&quot;</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;cname&quot;</span> value=<span class="string">&quot;Spring5框架&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;course2&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.atguigu.Spring5.collectionType.Course&quot;</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;cname&quot;</span> value=<span class="string">&quot;MyBatis框架&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h4 id="4、在集合里面设置对象类型值"><a href="#4、在集合里面设置对象类型值" class="headerlink" title="4、在集合里面设置对象类型值"></a>4、在集合里面设置对象类型值</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--创建多个course对象--&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;course1&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.atguigu.Spring5.collectionType.Course&quot;</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;cname&quot;</span> value=<span class="string">&quot;Spring5框架&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;course2&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.atguigu.Spring5.collectionType.Course&quot;</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;cname&quot;</span> value=<span class="string">&quot;MyBatis框架&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--注入list集合类型，值是对象--&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;courseList&quot;</span>&gt;</span><br><span class="line">            &lt;list&gt;</span><br><span class="line">                &lt;ref bean=<span class="string">&quot;course1&quot;</span>&gt;&lt;/ref&gt;</span><br><span class="line">                &lt;ref bean=<span class="string">&quot;course2&quot;</span>&gt;&lt;/ref&gt;</span><br><span class="line">            &lt;/list&gt;</span><br><span class="line">        &lt;/property&gt;</span><br></pre></td></tr></table></figure>



<h4 id="5、把集合注入部分提取出来"><a href="#5、把集合注入部分提取出来" class="headerlink" title="5、把集合注入部分提取出来"></a>5、把集合注入部分提取出来</h4><p>(1）在 spring 配置文件中引入名称空间 util</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="line">       xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">       xmlns:p=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span><br><span class="line">       xmlns:util=<span class="string">&quot;http://www.springframework.org/schema/util&quot;</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="line"><span class="string">                           http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<p>（2）使用 util 标签完成 list 集合注入提取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--<span class="number">1</span> 提取list集合类型属性注入--&gt;</span><br><span class="line">    &lt;util:list id=<span class="string">&quot;bookList&quot;</span>&gt;</span><br><span class="line">        &lt;value&gt;易筋经&lt;/value&gt;</span><br><span class="line">        &lt;value&gt;九阴真经&lt;/value&gt;</span><br><span class="line">        &lt;value&gt;九阳神功&lt;/value&gt;</span><br><span class="line">    &lt;/util:list&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--<span class="number">2</span> 提取list集合类型属性注入使用--&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;book&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.atguigu.Spring5.collectionType.Book&quot;</span> scope=<span class="string">&quot;prototype&quot;</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;list&quot;</span> ref=<span class="string">&quot;bookList&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h3 id="Ⅵ-IOC-操作-Bean-管理（FactoryBean）"><a href="#Ⅵ-IOC-操作-Bean-管理（FactoryBean）" class="headerlink" title="Ⅵ.IOC 操作 Bean 管理（FactoryBean）"></a>Ⅵ.IOC 操作 Bean 管理（FactoryBean）</h3><h4 id="1、Spring-有两种类型-bean，一种普通-bean，另外一种工厂-bean（FactoryBean）"><a href="#1、Spring-有两种类型-bean，一种普通-bean，另外一种工厂-bean（FactoryBean）" class="headerlink" title="1、Spring 有两种类型 bean，一种普通 bean，另外一种工厂 bean（FactoryBean）"></a>1、Spring 有两种类型 bean，一种普通 bean，另外一种工厂 bean（FactoryBean）</h4><h4 id="2、普通-bean：在配置文件中定义-bean-类型就是返回类型"><a href="#2、普通-bean：在配置文件中定义-bean-类型就是返回类型" class="headerlink" title="2、普通 bean：在配置文件中定义 bean 类型就是返回类型"></a>2、普通 bean：在配置文件中定义 bean 类型就是返回类型</h4><h4 id="3、工厂-bean：在配置文件定义-bean-类型可以和返回类型不一样"><a href="#3、工厂-bean：在配置文件定义-bean-类型可以和返回类型不一样" class="headerlink" title="3、工厂 bean：在配置文件定义 bean 类型可以和返回类型不一样"></a>3、工厂 bean：在配置文件定义 bean 类型可以和返回类型不一样</h4><ul>
<li><p>第一步 创建类，让这个类作为工厂 bean，实现接口 FactoryBean</p>
</li>
<li><p>第二步 实现接口里面的方法，在实现的方法中定义返回的 bean 类型</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">Course</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义返回bean</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Course <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Course course = <span class="keyword">new</span> Course();</span><br><span class="line">        course.setCname(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> course;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ApplicationContext context =</span><br><span class="line">                <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;bean3.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//factoryBean体现：定义的是MyBean类型的对象，返回的是Course类型的对象</span></span><br><span class="line">        Course course = context.getBean(<span class="string">&quot;myBean&quot;</span>, Course.class);</span><br><span class="line">        System.out.println(course);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Ⅶ-IOC-操作-Bean-管理（bean-作用域）-重点"><a href="#Ⅶ-IOC-操作-Bean-管理（bean-作用域）-重点" class="headerlink" title="Ⅶ.IOC 操作 Bean 管理（bean 作用域）==重点=="></a>Ⅶ.IOC 操作 Bean 管理（bean 作用域）==重点==</h3><h4 id="1、在-Spring-里面，设置创建-bean-实例是单实例还是多实例"><a href="#1、在-Spring-里面，设置创建-bean-实例是单实例还是多实例" class="headerlink" title="1、在 Spring 里面，设置创建 bean 实例是单实例还是多实例"></a>1、在 Spring 里面，设置创建 bean 实例是单实例还是多实例</h4><h4 id="2、在-Spring-里面，默认情况下，bean-是单实例对象"><a href="#2、在-Spring-里面，默认情况下，bean-是单实例对象" class="headerlink" title="2、在 Spring 里面，默认情况下，bean 是单实例对象"></a>2、在 Spring 里面，默认情况下，bean 是单实例对象</h4><p>现在对其进行验证，创建两个不同的Book对象，输出他们的地址，若地址相同则说明是单实例，若地址不同说明是多实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCollection2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ApplicationContext context =</span><br><span class="line">                <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;bean2.xml&quot;</span>);</span><br><span class="line">        Book book1 = context.getBean(<span class="string">&quot;book&quot;</span>, Book.class);</span><br><span class="line">        Book book2 = context.getBean(<span class="string">&quot;book&quot;</span>, Book.class);</span><br><span class="line">       <span class="comment">// book.test();</span></span><br><span class="line">        System.out.println(book1);</span><br><span class="line">        System.out.println(book2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">com.atguigu.Spring5.collectionType.Book@6200f9cb</span><br><span class="line">com.atguigu.Spring5.collectionType.Book@6200f9cb</span><br></pre></td></tr></table></figure>

<p>可见两个对象的地址相同，说明默认bean是单实例对象。</p>
<h4 id="3、如何设置单实例还是多实例"><a href="#3、如何设置单实例还是多实例" class="headerlink" title="3、如何设置单实例还是多实例"></a>3、如何设置单实例还是多实例</h4><p>（1）在 spring 配置文件 bean 标签里面有属性（scope）用于设置单实例还是多实例 </p>
<p>（2）scope 属性值 </p>
<ul>
<li><p>第一个值 默认值，singleton，表示是单实例对象 </p>
</li>
<li><p>第二个值 prototype，表示是多实例对象</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--<span class="number">2</span> 提取list集合类型属性注入使用--&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;book&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.atguigu.Spring5.collectionType.Book&quot;</span> scope=<span class="string">&quot;prototype&quot;</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;list&quot;</span> ref=<span class="string">&quot;bookList&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>测试结果为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">com.atguigu.Spring5.collectionType.Book@6200f9cb</span><br><span class="line">com.atguigu.Spring5.collectionType.Book@2002fc1d</span><br></pre></td></tr></table></figure>

<p>（3）singleton 和 prototype 区别 </p>
<ul>
<li><p>第一 singleton 单实例，prototype 多实例 </p>
</li>
<li><p>==第二 当设置 scope 值是 singleton的时候，加载 spring 配置文件时候就会创建单实例对象，即==</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext context =</span><br><span class="line">                <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;bean2.xml&quot;</span>);</span><br></pre></td></tr></table></figure>



<ul>
<li>==而当设置 scope 值是 prototype的时候，不是在加载 spring 配置文件时候创建对象，在调用 getBean 方法时候创建多实例对象。==即</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Book book1 = context.getBean(<span class="string">&quot;book&quot;</span>, Book.class);</span><br><span class="line">        Book book2 = context.getBean(<span class="string">&quot;book&quot;</span>, Book.class);</span><br></pre></td></tr></table></figure>

<h3 id="Ⅷ-IOC-操作-Bean-管理（bean-生命周期）-重点"><a href="#Ⅷ-IOC-操作-Bean-管理（bean-生命周期）-重点" class="headerlink" title="Ⅷ.IOC 操作 Bean 管理（bean 生命周期）==重点=="></a>Ⅷ.IOC 操作 Bean 管理（bean 生命周期）==重点==</h3><h4 id="1、生命周期"><a href="#1、生命周期" class="headerlink" title="1、生命周期"></a>1、生命周期</h4><p>（1）从对象创建到对象销毁的过程</p>
<h4 id="2、bean-生命周期"><a href="#2、bean-生命周期" class="headerlink" title="2、bean 生命周期"></a>2、bean 生命周期</h4><p>（1）通过构造器创建 bean 实例（无参数构造） </p>
<p>（2）为 bean 的属性设置值和对其他 bean 引用（调用 set 方法） </p>
<p>（3）调用 bean 的初始化的方法（需要进行配置初始化的方法）</p>
<p>（4）bean 可以使用了（对象获取到了） </p>
<p>（5）当容器关闭时候，调用 bean 的销毁的方法（需要进行配置销毁的方法）</p>
<h4 id="3、演示-bean-生命周期"><a href="#3、演示-bean-生命周期" class="headerlink" title="3、演示 bean 生命周期"></a>3、演示 bean 生命周期</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Orders</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//无参数构造</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Orders</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;第一步 执行无参数构造创建bean实例&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String oname;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOname</span><span class="params">(String oname)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.oname = oname;</span><br><span class="line">        System.out.println(<span class="string">&quot;第二步 调用set方法设置属性值&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建执行的初始化的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;第三步 执行初始化的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建执行的销毁的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroyMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;第五步 执行销毁的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相关配置文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="line">       xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">       xmlns:p=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span><br><span class="line">       xmlns:util=<span class="string">&quot;http://www.springframework.org/schema/util&quot;</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="line"><span class="string">                           http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=<span class="string">&quot;orders&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.atguigu.Spring5.bean.Orders&quot;</span> init-method=<span class="string">&quot;initMethod&quot;</span> destroy-method=<span class="string">&quot;destroyMethod&quot;</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;oname&quot;</span> value=<span class="string">&quot;手机&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    </span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>

<h4 id="4、bean-的后置处理器，bean-生命周期有七步"><a href="#4、bean-的后置处理器，bean-生命周期有七步" class="headerlink" title="4、bean 的后置处理器，bean 生命周期有七步"></a>4、bean 的后置处理器，bean 生命周期有七步</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">（<span class="number">1</span>）通过构造器创建 bean 实例（无参数构造） </span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>）为 bean 的属性设置值和对其他 bean 引用（调用 set 方法） </span><br><span class="line"></span><br><span class="line">（<span class="number">3</span>）把 bean 实例传递 bean 后置处理器的方法 postProcessBeforeInitialization  </span><br><span class="line"></span><br><span class="line">（<span class="number">4</span>）调用 bean 的初始化的方法（需要进行配置初始化的方法）</span><br><span class="line"></span><br><span class="line">（<span class="number">5</span>）把 bean 实例传递 bean 后置处理器的方法 postProcessAfterInitialization </span><br><span class="line"></span><br><span class="line">（<span class="number">6</span>）bean 可以使用了（对象获取到了） </span><br><span class="line"></span><br><span class="line">（<span class="number">7</span>）当容器关闭时候，调用 bean 的销毁的方法（需要进行配置销毁的方法）</span><br></pre></td></tr></table></figure>



<h4 id="5、演示添加后置处理器效果"><a href="#5、演示添加后置处理器效果" class="headerlink" title="5、演示添加后置处理器效果"></a>5、演示添加后置处理器效果</h4><p>（1）创建类，实现接口 BeanPostProcessor，创建后置处理器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanPost</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;在初始化之前执行的方法&quot;</span>);</span><br><span class="line">        <span class="comment">//bean就是创建出来的实例对象</span></span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;在初始化之后执行的方法&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;!--配置后置处理器--&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;myBeanPost&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.atguigu.Spring5.bean.MyBeanPost&quot;</span>&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">第一步 执行无参数构造创建bean实例</span><br><span class="line">第二步 调用set方法设置属性值</span><br><span class="line">在初始化之前执行的方法</span><br><span class="line">第三步 执行初始化的方法</span><br><span class="line">在初始化之后执行的方法</span><br><span class="line">第四步 获取创建bean实例对象</span><br><span class="line">com.atguigu.Spring5.bean.Orders@<span class="number">28701274</span></span><br><span class="line">第五步 执行销毁的方法</span><br></pre></td></tr></table></figure>

<h3 id="Ⅸ-IOC-操作-Bean-管理（xml-自动装配）"><a href="#Ⅸ-IOC-操作-Bean-管理（xml-自动装配）" class="headerlink" title="Ⅸ.IOC 操作 Bean 管理（xml 自动装配）"></a>Ⅸ.IOC 操作 Bean 管理（xml 自动装配）</h3><h4 id="1、什么是自动装配"><a href="#1、什么是自动装配" class="headerlink" title="1、什么是自动装配"></a>1、什么是自动装配</h4><p>即根据指定装配规则（属性名称或者属性类型），Spring 自动将匹配的属性值进行注入</p>
<h4 id="2、演示自动装配过程"><a href="#2、演示自动装配过程" class="headerlink" title="2、演示自动装配过程"></a>2、演示自动装配过程</h4><p>（1）根据属性名称自动注入。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--实现自动装配</span><br><span class="line">        bean标签属性autowire，配置自动装配</span><br><span class="line">        autowire属性常用两个值：</span><br><span class="line">            byName根据属性名称注入 ，注入值bean的id值和类属性名称一样</span><br><span class="line">            byType根据属性类型注入</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;emp&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.atguigu.Spring5.autowire.Emp&quot;</span> autowire=<span class="string">&quot;byName&quot;</span>&gt;</span><br><span class="line">        &lt;!--&lt;property name=<span class="string">&quot;dept&quot;</span> ref=<span class="string">&quot;dept&quot;</span>&gt;&lt;/property&gt;--&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>（2）根据属性类型自动注入.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--实现自动装配</span><br><span class="line">        bean标签属性autowire，配置自动装配</span><br><span class="line">        autowire属性常用两个值：</span><br><span class="line">            byName根据属性名称注入 ，注入值bean的id值和类属性名称一样</span><br><span class="line">            byType根据属性类型注入,需要注意的是当相同类型的bean定义多个会报错，此时只能用               byName</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;emp&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.atguigu.Spring5.autowire.Emp&quot;</span> autowire=<span class="string">&quot;byType&quot;</span>&gt;</span><br><span class="line">        &lt;!--&lt;property name=<span class="string">&quot;dept&quot;</span> ref=<span class="string">&quot;dept&quot;</span>&gt;&lt;/property&gt;--&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h3 id="Ⅹ-IOC-操作-Bean-管理-外部属性文件"><a href="#Ⅹ-IOC-操作-Bean-管理-外部属性文件" class="headerlink" title="Ⅹ.IOC 操作 Bean 管理(外部属性文件)"></a>Ⅹ.IOC 操作 Bean 管理(外部属性文件)</h3><h4 id="1、直接配置数据库信息"><a href="#1、直接配置数据库信息" class="headerlink" title="1、直接配置数据库信息"></a>1、直接配置数据库信息</h4><p>（1）配置德鲁伊druid连接池 </p>
<p>（2）引入德鲁伊连接池依赖 jar 包</p>
<h4 id="2、引入外部属性文件配置数据库连接池"><a href="#2、引入外部属性文件配置数据库连接池" class="headerlink" title="2、引入外部属性文件配置数据库连接池"></a>2、引入外部属性文件配置数据库连接池</h4><p>（1）创建外部属性文件，properties 格式文件，写数据库信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">prop.driverClass=com.mysql.jdbc.Driver</span><br><span class="line">prop.url=jdbc:mysql:<span class="comment">//localhost:3306/userDb</span></span><br><span class="line">prop.userName=root</span><br><span class="line">prop.password=root</span><br></pre></td></tr></table></figure>

<p>（2）把外部 properties 属性文件引入到 spring 配置文件中</p>
<ul>
<li>引入 context 名称空间 </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="line">       xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">       xmlns:p=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span><br><span class="line">       xmlns:util=<span class="string">&quot;http://www.springframework.org/schema/util&quot;</span></span><br><span class="line">       xmlns:context=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="line"><span class="string">                           http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd</span></span><br><span class="line"><span class="string">                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>

<p>需要着重注意的配置： <font color=red>xmlns:context=”<a href="http://www.springframework.org/schema/context&quot;">http://www.springframework.org/schema/context&quot;</a></font></p>
<p><a href="http://www.springframework.org/schema/context">http://www.springframework.org/schema/context</a> <a href="http://www.springframework.org/schema/context/spring-context.xsd&quot;">http://www.springframework.org/schema/context/spring-context.xsd&quot;</a></p>
<ul>
<li>在 spring 配置文件使用标签引入外部属性文件</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--引入外部属性文件--&gt;</span><br><span class="line">   &lt;context:property-placeholder location=<span class="string">&quot;classpath:jdbc.properties&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">   &lt;!--配置连接池--&gt;</span><br><span class="line">   &lt;bean id=<span class="string">&quot;dataSource&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span><br><span class="line">       &lt;property name=<span class="string">&quot;driverClassName&quot;</span> value=<span class="string">&quot;$&#123;prop.driverClass&#125;&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">       &lt;property name=<span class="string">&quot;url&quot;</span> value=<span class="string">&quot;$&#123;prop.url&#125;&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">       &lt;property name=<span class="string">&quot;username&quot;</span> value=<span class="string">&quot;$&#123;prop.userName&#125;&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">       &lt;property name=<span class="string">&quot;password&quot;</span> value=<span class="string">&quot;$&#123;prop.password&#125;&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">   &lt;/bean&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Ⅺ-IOC-操作-Bean-管理-基于注解方式"><a href="#Ⅺ-IOC-操作-Bean-管理-基于注解方式" class="headerlink" title="Ⅺ.IOC 操作 Bean 管理(基于注解方式)"></a>Ⅺ.IOC 操作 Bean 管理(基于注解方式)</h3><h4 id="1、什么是注解"><a href="#1、什么是注解" class="headerlink" title="1、什么是注解"></a>1、什么是注解</h4><p> （1）注解是代码特殊标记，格式：@注解名称(属性名称=属性值, 属性名称=属性值..) </p>
<p>（2）使用注解，注解可以作用在类上面，方法上面，属性上面 </p>
<p>（3）使用注解目的：简化 xml 配置，使用更优雅的方式实现配置。</p>
<h4 id="2、Spring-针对-Bean-管理中创建对象提供注解"><a href="#2、Spring-针对-Bean-管理中创建对象提供注解" class="headerlink" title="2、Spring 针对 Bean 管理中创建对象提供注解"></a>2、Spring 针对 Bean 管理中创建对象提供注解</h4><p>（1）@Component </p>
<p>（2）@Service </p>
<p>（3）@Controller </p>
<p>（4）@Repository </p>
<p>上面四个注解功能是一样的，都可以用来创建 bean 实例</p>
<h4 id="3、基于注解方式实现对象创建"><a href="#3、基于注解方式实现对象创建" class="headerlink" title="3、基于注解方式实现对象创建"></a>3、基于注解方式实现对象创建</h4><p>第一步 引入依赖</p>
<p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/image-20210406163000273.png" alt="image-20210406163000273"></p>
<p>第二步 开启组件扫描：告诉Spring容器现在在哪个类里面加入注解，然后去扫描这个类。不开启的话Spring不知道要做什么事情，也不知道扫描哪个包中的哪个类。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                          http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开启组件扫描</span></span><br><span class="line"><span class="comment">        1 如果扫描多个包，多个包使用逗号隔开</span></span><br><span class="line"><span class="comment">        &lt;context:component-scan base-package=&quot;com.atguigu.Spring5,com.atguigu.Spring5.service&quot;&gt;&lt;/context:component-scan&gt;</span></span><br><span class="line"><span class="comment">        2 扫描包上层目录</span></span><br><span class="line"><span class="comment">        &lt;context:component-scan base-package=&quot;com.atguigu&quot;&gt;&lt;/context:component-scan&gt;</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.atguigu.Spring5,com.atguigu.Spring5.service&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>第三步 创建类，在类上面添加创建对象注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在注解里面value属性值可以省略不写，</span></span><br><span class="line"><span class="comment">//默认值是类名称，首字母小写  UserService -- userService</span></span><br><span class="line"><span class="comment">//@Component(value = &quot;userService&quot;)  //&lt;bean id=&quot;userService&quot; class=&quot;..&quot;/&gt;</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(value = &quot;abc&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;service add.......&quot;</span>+name);</span><br><span class="line">        userDao.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4、开启组件扫描细节配置"><a href="#4、开启组件扫描细节配置" class="headerlink" title="4、开启组件扫描细节配置"></a>4、开启组件扫描细节配置</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--示例1</span></span><br><span class="line"><span class="comment">    use-default-filters=&quot;false&quot; 表示现在不使用默认 filter，而使用自己配置的 filter</span></span><br><span class="line"><span class="comment">    context:include-filter ，设置扫描哪些内容</span></span><br><span class="line"><span class="comment">    Controller：表示在com.atguigu包下只扫描带@Controller注解的类</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.atguigu&quot;</span> <span class="attr">use-default-filters</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span></span></span><br><span class="line"><span class="tag">                            <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--示例 2</span></span><br><span class="line"><span class="comment">         下面配置扫描包所有内容</span></span><br><span class="line"><span class="comment">         context:exclude-filter： 设置哪些内容不进行扫描</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.atguigu&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="5、基于注解方式实现属性注入"><a href="#5、基于注解方式实现属性注入" class="headerlink" title="5、基于注解方式实现属性注入"></a>5、基于注解方式实现属性注入</h4><p>（1）@Autowired：根据属性类型进行自动装配 </p>
<ul>
<li><p>第一步 把 service 和 dao 对象创建，在 service 和 dao 类添加创建对象注解 </p>
</li>
<li><p>第二步 在 service 注入 dao 对象，在 service 类添加 dao 类型属性，在属性上面使用注解.</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"> 	<span class="comment">//定义 dao 类型属性</span></span><br><span class="line"> 	<span class="comment">//不需要添加 set 方法</span></span><br><span class="line"> 	<span class="comment">//添加注入属性注解</span></span><br><span class="line"> 	<span class="meta">@Autowired</span> </span><br><span class="line"> 	<span class="keyword">private</span> UserDao userDao;</span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 	System.out.println(<span class="string">&quot;service add.......&quot;</span>);</span><br><span class="line"> 	userDao.add();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>（2）@Qualifier：根据名称进行注入，这个 @Qualifier 注解要和上面 @Autowired 一起使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义 dao 类型属性</span></span><br><span class="line"><span class="comment">//不需要添加 set 方法</span></span><br><span class="line"><span class="comment">//添加注入属性注解</span></span><br><span class="line"><span class="meta">@Autowired</span> <span class="comment">//根据类型进行注入</span></span><br><span class="line"><span class="meta">@Qualifier(value = &quot;userDaoImpl1&quot;)</span> <span class="comment">//根据名称进行注入</span></span><br><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br></pre></td></tr></table></figure>



<p>（3）@Resource：可以根据类型注入，也可以根据名称注入。注意：Resourse注解是javax.annotation.Resource包中的，因此尽量使用前面的方法注入属性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource</span>  <span class="comment">//根据类型进行注入</span></span><br><span class="line"><span class="meta">@Resource(name = &quot;userDaoImpl1&quot;)</span>  <span class="comment">//根据名称进行注入</span></span><br><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br></pre></td></tr></table></figure>



<p>（4）@Value：注入普通类型属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Value(value = &quot;abc&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"><span class="comment">//输出为：</span></span><br><span class="line">service add.......abc</span><br><span class="line">dao add.....</span><br></pre></td></tr></table></figure>

<h4 id="6-完全注解开发"><a href="#6-完全注解开发" class="headerlink" title="6.完全注解开发"></a>6.完全注解开发</h4><p>（1）创建配置类，替代 xml 配置文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.Spring5.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span>  <span class="comment">//作为配置类，替代xml配置文件</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;com.atguigu&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）编写测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testService2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//加载配置类</span></span><br><span class="line">        ApplicationContext context</span><br><span class="line">                = <span class="keyword">new</span> AnnotationConfigApplicationContext(SpringConfig.class);</span><br><span class="line">        UserService userService = context.getBean(<span class="string">&quot;userService&quot;</span>, UserService.class);</span><br><span class="line">        System.out.println(userService);</span><br><span class="line">        userService.add();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP的四次挥手</title>
    <url>/2021/11/02/TCP%E7%9A%84%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
    <content><![CDATA[<h1 id="TCP-的四次挥手"><a href="#TCP-的四次挥手" class="headerlink" title="TCP 的四次挥手"></a>TCP 的四次挥手</h1><p><a href="https://blog.csdn.net/qzcsu/article/details/72861891">(45条消息) 两张动图-彻底明白TCP的三次握手与四次挥手_qzcsu的博客-CSDN博客_三次握手四次挥手详解</a></p>
<h2 id="TCP-四次挥手的过程"><a href="#TCP-四次挥手的过程" class="headerlink" title="TCP 四次挥手的过程"></a>TCP 四次挥手的过程</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A：老师，下课了。</span><br><span class="line">B：好，我知道了，我说完这点。</span><br><span class="line">B：好了，说完了，下课吧。</span><br><span class="line">A：谢谢老师，老师再见。</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/202110221718880.png" alt="TCP四次挥手"></p>
<p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/202110221719391.jpeg" alt="img"></p>
<ul>
<li>客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送</li>
<li>服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加 1 。和 SYN 一样，一个 FIN 将占用一个序号</li>
<li>服务器-关闭与客户端的连接，发送一个 FIN 给客户端</li>
<li>客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加 1</li>
</ul>
<p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 <code>TCP</code> 连接。</p>
<h2 id="为什么要四次挥手"><a href="#为什么要四次挥手" class="headerlink" title="为什么要四次挥手"></a>为什么要四次挥手</h2><p>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 <code>CLOSE-WAIT</code> 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 <code>FIN</code> 连接释放报文。</p>
<h2 id="TIME-WAIT-状态"><a href="#TIME-WAIT-状态" class="headerlink" title="TIME_WAIT 状态"></a>TIME_WAIT 状态</h2><p>客户端接收到服务器端的 <code>FIN</code> 报文后进入此状态，此时并不是直接进入 <code>CLOSED</code> 状态，还需要等待一个时间计时器设置的时间 <code>2MSL</code><strong>MSL是Maximum Segment Lifetime，报文最大生存时间</strong>。这么做有两个理由：</p>
<ul>
<li>确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。</li>
<li>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</li>
</ul>
<h2 id="为什么建立连接是三次握手，关闭连接确是四次挥手呢？"><a href="#为什么建立连接是三次握手，关闭连接确是四次挥手呢？" class="headerlink" title="为什么建立连接是三次握手，关闭连接确是四次挥手呢？"></a>为什么建立连接是三次握手，关闭连接确是四次挥手呢？</h2><p>建立连接的时候， 服务器在<code>LISTEN</code>状态下，收到建立连接请求的SYN报文后，把<code>ACK</code>和<code>SYN</code>放在一个报文里发送给客户端。<br>而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送<code>FIN</code>报文给对方来表示同意现在关闭连接，因此，己方<code>ACK</code>和<code>FIN</code>一般都会分开发送，从而导致多了一次。</p>
]]></content>
      <categories>
        <category>计算机网</category>
      </categories>
      <tags>
        <tag>计算机网</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP的三次握手</title>
    <url>/2021/11/02/TCP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/</url>
    <content><![CDATA[<h1 id="TCP的三次握手"><a href="#TCP的三次握手" class="headerlink" title="TCP的三次握手"></a>TCP的三次握手</h1><h2 id="1-IP协议"><a href="#1-IP协议" class="headerlink" title="1. IP协议"></a>1. IP协议</h2><ul>
<li><code>IP</code>协议是无连接的通信协议，他不会占用两个正在通信的计算机之间的通信线路，这样<code>IP</code>就降低了对网络线路的需求，每条线可以同时满足许多不同的计算机之间的通信需要。</li>
<li>通过<code>IP</code>消息或者其他数据会被分割为较小的独立的包，并通过因特网在计算机之间传送。</li>
<li><code>IP</code>负责将每个包路由至他的目的地，但<code>IP</code>协议没有确认数据包是否按顺序发送或者包是否损坏，所以<code>IP</code>数据包是不可靠的，需要由他的上层协议作出控制。</li>
</ul>
<span id="more"></span>

<h2 id="2-TCP-三次握手的过程"><a href="#2-TCP-三次握手的过程" class="headerlink" title="2. TCP 三次握手的过程"></a>2. TCP 三次握手的过程</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A：您好，我是 A。</span><br><span class="line">B：您好 A，我是 B。</span><br><span class="line">A：您好 B。</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/202110221650641.png" alt="TCP三次握手"></p>
<p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/202110221656279.png" alt="img"></p>
<ul>
<li>首先 B 处于 <code>LISTEN（监听）</code>状态，等待客户的连接请求。</li>
<li>A 向 B 发送连接请求报文，<code>SYN=1，ACK=0</code>，选择一个初始的序号 x。</li>
<li>B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，<code>SYN=1，ACK=1</code>，确认号为 <code>x+1</code>，同时也选择一个初始的序号 <code>y</code>。</li>
<li>A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 <code>y+1</code>，序号为 <code>x+1</code>。</li>
<li>B 收到 A 的确认后，连接建立。</li>
</ul>
<h2 id="3-为什么要三次握手"><a href="#3-为什么要三次握手" class="headerlink" title="3. 为什么要三次握手"></a>3. 为什么要三次握手</h2><p><strong>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</strong></p>
<p>第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</p>
<p>第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</p>
<p>第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</p>
<p>所以三次握手就能确认双发收发功能都正常，缺一不可。</p>
<p>当然 A 发给 B 的应答之应答也会丢，也会绕路，甚至 B 挂了。按理来说，还应该有个应答之应答之应答，这样下去就没底了。所以四次握手是可以的，四十次都可以，关键四百次也不能保证就真的可靠了。只要双方的消息都有去有回，就基本可以了。</p>
<p>其次，第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。</p>
<p>客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。</p>
<h3 id="3-1-第-2-次握手传回了-ACK，为什么还要传回-SYN？"><a href="#3-1-第-2-次握手传回了-ACK，为什么还要传回-SYN？" class="headerlink" title="3.1 第 2 次握手传回了 ACK，为什么还要传回 SYN？"></a>3.1 第 2 次握手传回了 ACK，为什么还要传回 SYN？</h3><p>接收端传回发送端所发送的 <code>ACK</code> 是为了告诉客户端，我接收到的信息确实就是你所发送的信号了，这表明从客户端到服务端的通信是正常的。而回传 <code>SYN</code> 则是为了建立并确认从服务端到客户端的通信。”</p>
<blockquote>
<p><code>SYN</code> 同步序列编号(Synchronize Sequence Numbers) 是 <code>TCP/IP</code> 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 <code>TCP</code> 网络连接时，客户机首先发出一个 <code>SYN</code> 消息，服务器使用 <code>SYN-ACK</code> 应答表示接收到了这个消息，最后客户机再以 <code>ACK(Acknowledgement）</code>消息响应。这样在客户机和服务器之间才能建立起可靠的 <code>TCP</code> 连接，数据才可以在客户机和服务器之间传递。</p>
</blockquote>
]]></content>
      <categories>
        <category>计算机网</category>
      </categories>
      <tags>
        <tag>计算机网</tag>
      </tags>
  </entry>
  <entry>
    <title>在浏览器中输入 url 地址，按下回车后发生了什么</title>
    <url>/2021/11/02/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5URL/</url>
    <content><![CDATA[<h1 id="在浏览器中输入-url-地址-gt-显示主页的过程"><a href="#在浏览器中输入-url-地址-gt-显示主页的过程" class="headerlink" title="在浏览器中输入 url 地址 -&gt; 显示主页的过程"></a>在浏览器中输入 url 地址 -&gt; 显示主页的过程</h1><h2 id="打开一个网页，整个过程会使用哪些协议？"><a href="#打开一个网页，整个过程会使用哪些协议？" class="headerlink" title="打开一个网页，整个过程会使用哪些协议？"></a>打开一个网页，整个过程会使用哪些协议？</h2><span id="more"></span>

<p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/202110251645623.jpeg" alt="img">总体来说分为以下几个过程:</p>
<ol>
<li><code>DNS</code> 解析</li>
<li><code>TCP</code> 连接(三次握手)</li>
<li>发送 <code>HTTP</code> 请求(通过<code>TCP</code>套接字发送)</li>
<li>服务器处理请求并返回 <code>HTTP</code> 报文</li>
<li>浏览器解析渲染页面</li>
<li>连接结束(四次挥手)</li>
</ol>
<h2 id="1-DNS-解析"><a href="#1-DNS-解析" class="headerlink" title="1.DNS 解析"></a>1.<code>DNS</code> 解析</h2><p>NS解析的过程就是寻找哪台机器上有你需要资源的过程。当你在浏览器中输入一个地址时，例如<code>www.baidu.com</code>，其实不是百度网站真正意义上的地址。互联网上每一台计算机的唯一标识是它的<code>IP</code>地址，但是<code>IP</code>地址并不方便记忆。用户更喜欢用方便记忆的网址去寻找互联网上的其它计算机，也就是上面提到的百度的网址。所以互联网设计者需要在用户的方便性与可用性方面做一个权衡，这个权衡就是一个网址到<code>IP</code>地址的转换，这个过程就是<code>DNS</code>解析。它实际上充当了一个翻译的角色，实现了网址到<code>IP</code>地址的转换。网址到<code>IP</code>地址转换的过程是如何进行的?</p>
<h3 id="1-1-解析过程"><a href="#1-1-解析过程" class="headerlink" title="1.1 解析过程"></a>1.1 解析过程</h3><p><code>DNS</code>解析是一个递归查询的过程。</p>
<p><img src="https://gitee.com/AD-Gai-Code/pic-go/raw/master/202110251638419.png" alt="DNS解析过程"></p>
<p>上述图片是查找<code>www.google.com</code>的<code>IP</code>地址过程。首先在本地域名服务器中查询<code>IP</code>地址，如果没有找到的情况下，本地域名服务器会向根域名服务器发送一个请求，如果根域名服务器也不存在该域名时，本地域名会向<code>com</code>顶级域名服务器发送一个请求，依次类推下去。直到最后本地域名服务器得到<code>google</code>的<code>IP</code>地址并把它缓存到本地，供下次查询使用。从上述过程中，可以看出网址的解析是一个从右向左的过程: <code>com -&gt; google.com -&gt; www.google.com</code>。但是你是否发现少了点什么，根域名服务器的解析过程呢？事实上，真正的网址是<code>www.google.com.</code>，并不是我多打了一个<code>.</code>，这个<code>.</code>对应的就是根域名服务器，默认情况下所有的网址的最后一位都是<code>.</code>，既然是默认情况下，为了方便用户，通常都会省略，浏览器在请求<code>DNS</code>的时候会自动加上，所有网址真正的解析过程为: <code>. -&gt; .com -&gt; google.com. -&gt; www.google.com.</code>。</p>
<h3 id="1-2-DNS-优化"><a href="#1-2-DNS-优化" class="headerlink" title="1.2 DNS 优化"></a>1.2 DNS 优化</h3><p>了解了<code>DNS</code>的过程，可以为我们带来哪些？上文中请求到<code>google</code>的<code>IP</code>地址时，经历了8个步骤，这个过程中存在多个请求(大多数情况下 <code>DNS</code> 使用 <code>UDP</code> 进行传输，这就要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。)。如果每次都经过这么多步骤，是否太耗时间？如何减少该过程的步骤呢？那就是<code>DNS</code>缓存。</p>
<h4 id="1-2-1-DNS-缓存"><a href="#1-2-1-DNS-缓存" class="headerlink" title="1.2.1 DNS 缓存"></a>1.2.1 DNS 缓存</h4><p><code>DNS</code>存在着多级缓存，从离浏览器的距离排序的话，有以下几种: 浏览器缓存，系统缓存，路由器缓存，<code>IPS</code>服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。</p>
<h4 id="1-2-2-DNS-负载均衡"><a href="#1-2-2-DNS-负载均衡" class="headerlink" title="1.2.2 DNS 负载均衡"></a>1.2.2 DNS 负载均衡</h4><p>首先思考一个问题：<code>DNS</code>返回的<code>IP</code>地址是否每次都一样？如果每次都一样是否说明你请求的资源都位于同一台机器上面，那么这台机器需要多高的性能和储存才能满足亿万请求呢？其实真实的互联网世界背后存在成千上百台服务器，大型的网站甚至更多。但是在用户的眼中，它需要的只是处理他的请求，哪台机器处理请求并不重要。<code>DNS</code>可以返回一个合适的机器的<code>IP</code>给用户，例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等，这种过程就是<code>DNS</code>负载均衡，又叫做<code>DNS</code>重定向。</p>
<h2 id="2-TCP-连接"><a href="#2-TCP-连接" class="headerlink" title="2. TCP 连接"></a>2. TCP 连接</h2><p>HTTP 是基于 TCP 协议传输的,客户端与服务器通过三次握手建立起 TCP 连接，具体过程可参考：<a href="">TCP的三次握手</a>。</p>
<h2 id="3-发送-HTTP-请求-前端-HTTP"><a href="#3-发送-HTTP-请求-前端-HTTP" class="headerlink" title="3. 发送 HTTP 请求(前端 HTTP)"></a>3. 发送 HTTP 请求(前端 HTTP)</h2><p>建立了TCP连接之后，发起一个<code>http</code>请求,发送<code>HTTP</code>请求的过程就是构建<code>HTTP</code>请求报文并通过TCP协议中发送到服务器指定端口(<code>HTTP</code>协议<code>80/8080</code>, <code>HTTPS</code>协议<code>443</code>)。<code>HTTP</code>请求报文是由三部分组成: <strong>请求行</strong>, <strong>请求报头</strong>和<strong>请求正文</strong>。</p>
<h3 id="3-1-请求行"><a href="#3-1-请求行" class="headerlink" title="3.1 请求行"></a>3.1 请求行</h3><p>格式如下:<br><code>Method Request-URL HTTP-Version CRLF</code></p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">eg</span><span class="punctuation">: </span>GET index.html HTTP/1.1</span><br></pre></td></tr></table></figure>

<p>常用的方法有: GET, POST, PUT, DELETE, OPTIONS, HEAD。</p>
<h4 id="3-1-1-Get-和-POST-有什么区别？"><a href="#3-1-1-Get-和-POST-有什么区别？" class="headerlink" title="3.1.1 Get 和 POST 有什么区别？"></a>3.1.1 Get 和 POST 有什么区别？</h4><ol>
<li><p><code>Http</code>报文层面：</p>
<ul>
<li><code>GET</code>请求信息放在<code>URL</code>，<code>POST</code>放在报文体中</li>
<li><code>GET</code>请求中一般浏览器对<code>URL</code>长度有限制；<code>POST</code>请求数据长度无限制</li>
</ul>
</li>
<li><p>数据库层面：</p>
<ul>
<li><code>GET</code>服务幂等性（对数据库的一次操作和多次操作上一致的）和安全性（没有改变数据库的数据）</li>
<li><code>POST</code>不符合幂等性和安全性</li>
</ul>
</li>
<li><p>其他层面：</p>
<ul>
<li><code>GET</code>可以被缓存，被存储，而<code>POST</code>不行</li>
<li><code>GET</code>请求的内容会被保存在浏览器中</li>
<li>超过90%的<code>GET</code>请求都被<code>CDN(Content Delivery Network)</code>缓存了，大大减少<code>web</code>服务起器的负担</li>
</ul>
</li>
</ol>
<h3 id="3-2-请求报头"><a href="#3-2-请求报头" class="headerlink" title="3.2 请求报头"></a>3.2 请求报头</h3><p>请求报头允许客户端向服务器传递请求的附加信息和客户端自身的信息。</p>
<blockquote>
<p> PS: 客户端不一定特指浏览器，有时候也可使用Linux下的CURL命令以及HTTP客户端测试工具等。</p>
</blockquote>
<p>常见的请求报头有: <code>Acce pt, Accept-Charset, Accept-Encoding, Accept-Language, Content-Type, Authorization, Cookie, User-Agent</code>等。</p>
<ul>
<li><code>Accept</code>用于指定客户端用于接受哪些类型的信息。</li>
<li><code>Accept-Encoding</code>与<code>Accept</code>类似，它用于指定接受的编码方式。</li>
<li><code>Connection</code>设置为<code>Keep-alive</code>用于告诉客户端本次<code>HTTP</code>请求结束之后并不需要关闭<code>TCP</code>连接，这样可以使下次<code>HTTP</code>请求使用相同的<code>TCP</code>通道，节省<code>TCP</code>连接建立的时间。</li>
</ul>
<h3 id="3-3-请求正文"><a href="#3-3-请求正文" class="headerlink" title="3.3 请求正文"></a>3.3 请求正文</h3><p>当使用<code>POST</code>, <code>PUT</code>等方法时，通常需要客户端向服务器传递数据。这些数据就储存在请求正文中。在请求包头中有一些与请求正文相关的信息，例如: 现在的<code>Web</code>应用通常采用<code>Rest</code>架构，请求的数据格式一般为<code>json</code>。这时就需要设置<code>Content-Type: application/json</code>。</p>
<h2 id="4-服务器处理请求并返回HTTP报文-后端-HTTP"><a href="#4-服务器处理请求并返回HTTP报文-后端-HTTP" class="headerlink" title="4. 服务器处理请求并返回HTTP报文(后端 HTTP)"></a>4. 服务器处理请求并返回HTTP报文(后端 HTTP)</h2><p>后端从在固定的端口接收到<code>TCP</code>报文开始，这一部分对应于编程语言中的<code>socket</code>。它会对<code>TCP</code>连接进行处理，对<code>HTTP</code>协议进行解析，并按照报文格式进一步封装成<code>HTTP Request</code>对象，供上层使用。这一部分工作一般是由<code>Web</code>服务器去进行，如<code>Tomcat</code>,<code> Jetty</code>和<code>Netty</code>等等。</p>
<p><code>HTTP</code>响应报文也是由三部分组成: <strong>状态码</strong>, <strong>响应报头</strong>和<strong>响应报文</strong>。</p>
<h3 id="4-1-状态码"><a href="#4-1-状态码" class="headerlink" title="4.1 状态码"></a>4.1 状态码</h3><p>状态码是由3位数组成，第一个数字定义了响应的类别，且有五种可能取值:</p>
<ul>
<li><code>1xx</code>：指示信息–表示请求已接收，继续处理。</li>
<li><code>2xx</code>：成功–表示请求已被成功接收、理解、接受。</li>
<li><code>3xx</code>：重定向–要完成请求必须进行更进一步的操作。</li>
<li><code>4xx</code>：客户端错误–请求有语法错误或请求无法实现。</li>
<li><code>5xx</code>：服务器端错误–服务器未能实现合法的请求。</li>
</ul>
<p>平时遇到比较常见的状态码有:</p>
<ul>
<li><code>200 OK</code> :正常返回信息。</li>
<li><code>400 Bad Rqquest</code>：客户端请求有语法错误，不能被服务器理解。</li>
<li><code>401 Unauthorized</code>：请求未经授权，这个状态代码和WWW-Authenticate报头域一起使用。</li>
<li><code>403 Forbidden</code>：服务器收到请求，但是拒绝提供服务。</li>
<li><code>404 Not Found</code>：请求资源不存在，比如输入了错误的URL。</li>
<li><code>500 Internal Server Error</code>：服务器发生了不可预期的错误。</li>
<li><code>503 Server Unavailable</code>：服务器当前不能处理客户端的请求，一段时间后可能恢复正常。</li>
</ul>
<h4 id="4-1-1-301-和-302-有什么区别？"><a href="#4-1-1-301-和-302-有什么区别？" class="headerlink" title="4.1.1  301 和 302 有什么区别？"></a>4.1.1  301 和 302 有什么区别？</h4><p><code>301</code>和<code>302</code>状态码都表示重定向，就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的<code>URL</code>地址，这个地址可以从响应的<code>Location</code>首部中获取（用户看到的效果就是他输入的地址A瞬间变成了另一个地址B）——这是它们的共同点。</p>
<p>他们的不同在于:</p>
<ul>
<li><code>301</code>表示旧地址<code>A</code>的资源已经被永久地移除了（这个资源不可访问了），搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址。</li>
<li><code>302</code>表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址<code>A</code>跳转到地址<code>B</code>，搜索引擎会抓取新的内容而保存旧的网址。</li>
</ul>
<h3 id="4-2-响应报头"><a href="#4-2-响应报头" class="headerlink" title="4.2 响应报头"></a>4.2 响应报头</h3><p>常见的响应报头字段有: <code>Server</code>,<code> Connection</code>。</p>
<h3 id="4-3-响应报文"><a href="#4-3-响应报文" class="headerlink" title="4.3 响应报文"></a>4.3 响应报文</h3><p>服务器返回给浏览器的文本信息，通常<code>HTML</code>,<code> CSS</code>,<code> JS</code>, 图片等文件就放在这一部分。</p>
<h2 id="5-浏览器解析渲染页面"><a href="#5-浏览器解析渲染页面" class="headerlink" title="5. 浏览器解析渲染页面"></a>5. 浏览器解析渲染页面</h2><p>客户端浏览器解析HTML内容，这部分暂时没有深入学习。</p>
<h2 id="6-连接结束-四次挥手"><a href="#6-连接结束-四次挥手" class="headerlink" title="6. 连接结束 (四次挥手)"></a>6. 连接结束 (四次挥手)</h2><p>具体过程可参考：<a href="">TCP 的四次挥手</a></p>
]]></content>
      <categories>
        <category>计算机网</category>
      </categories>
      <tags>
        <tag>计算机网</tag>
      </tags>
  </entry>
</search>
