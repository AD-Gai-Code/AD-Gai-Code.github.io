{"meta":{"title":"ADGai's Blog","subtitle":"","description":"","author":"AiLaodu","url":"http://example.com","root":"/"},"pages":[{"title":"赞赏","date":"2019-12-31T16:00:00.000Z","updated":"2021-06-01T02:59:37.648Z","comments":true,"path":"donate/index.html","permalink":"http://example.com/donate/index.html","excerpt":"","text":"如果喜欢我的博客，或者喜欢我的博客主题，可以考虑赞赏一下哦，非常感激！ 网站所需的服务器和 CDN 都是不小的开支，日常维护也需要大量精力。 你们的支持是我前进的最大动力！"},{"title":"留言板","date":"2019-12-31T16:00:00.000Z","updated":"2021-06-01T02:59:37.648Z","comments":true,"path":"comment/index.html","permalink":"http://example.com/comment/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2019-12-31T16:00:00.000Z","updated":"2021-06-01T02:59:37.648Z","comments":false,"path":"friend/index.html","permalink":"http://example.com/friend/index.html","excerpt":"","text":"欢迎各位朋友前来交换友链，本站友链接受以下类型的网站： 个人博客 公益组织等非盈利性网站 不接受广告、商业性网站，特殊情况除外 如果你的网站 一个月以上无法正常访问 将会被移除。"},{"title":"Tags","date":"2021-10-26T08:12:19.000Z","updated":"2021-10-26T09:02:36.610Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"Categories","date":"2021-10-26T08:11:39.000Z","updated":"2021-10-26T09:16:22.455Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"重读 HashMap 源码，值得一品","slug":"重读 HashMap 源码，值得一品","date":"2022-02-15T02:04:01.416Z","updated":"2022-02-15T03:50:59.161Z","comments":true,"path":"2022/02/15/重读 HashMap 源码，值得一品/","link":"","permalink":"http://example.com/2022/02/15/%E9%87%8D%E8%AF%BB%20HashMap%20%E6%BA%90%E7%A0%81%EF%BC%8C%E5%80%BC%E5%BE%97%E4%B8%80%E5%93%81/","excerpt":"重读 HashMap 源码，值得一品今天看面经的时候看到了 HashMap 的连环夺命问，故细致地重读一遍 HashMap 的源码，开始之前先把问题放在前面，带着问题去看更具有针对性： 1、table 的初始化时机是什么时候，初始化的 table.length 是多少、阀值（threshold）是多少，实际能容下多少元素 2、什么时候触发扩容，扩容之后的 table.length、阀值各是多少？ 3、table 的 length 为什么是 2 的 n 次幂 4、求索引的时候为什么是：h&amp;(length-1)，而不是 h&amp;length，更不是 h%length 5、 Map map = new HashMap(1000); 当我们存入多少个元素时会触发map的扩容； Map map1 = new HashMap(10000); 我们存入第 10001个元素时会触发 map1 扩容吗 6、为什么加载因子的默认值是 0.75，并且不推荐我们修改","text":"重读 HashMap 源码，值得一品今天看面经的时候看到了 HashMap 的连环夺命问，故细致地重读一遍 HashMap 的源码，开始之前先把问题放在前面，带着问题去看更具有针对性： 1、table 的初始化时机是什么时候，初始化的 table.length 是多少、阀值（threshold）是多少，实际能容下多少元素 2、什么时候触发扩容，扩容之后的 table.length、阀值各是多少？ 3、table 的 length 为什么是 2 的 n 次幂 4、求索引的时候为什么是：h&amp;(length-1)，而不是 h&amp;length，更不是 h%length 5、 Map map = new HashMap(1000); 当我们存入多少个元素时会触发map的扩容； Map map1 = new HashMap(10000); 我们存入第 10001个元素时会触发 map1 扩容吗 6、为什么加载因子的默认值是 0.75，并且不推荐我们修改 问题一：table 的初始化HashMap 的构造方法有如下 4 种： 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 构造方法 1 * * 通过 指定的 initialCapacity 和 loadFactor 实例化一个空的 HashMap 对象 */public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(&quot;Illegal load factor: &quot; + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity);&#125;/** * 构造方法 2 * * 通过指定的 initialCapacity 和 默认的 loadFactor(0.75) 实例化一个空的 HashMap 对象 */public HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR);&#125;/** * 构造方法 3 * * 通过默认的 initialCapacity 和 默认的 loadFactor(0.75) 实例化一个空的 HashMap 对象 */public HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted&#125;/** * * 构造方法 4 * 通过指定的 Map 对象实例化一个 HashMap 对象 */public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; putMapEntries(m, false);&#125; 使用方式 1 实例化 HashMap 的时候，table 并未进行初始化，那 table 是何时进行初始化的？ 平时我们是如何使用 HashMap 的? 先实例化、然后 put、然后进行其他操作，如下: 123Map&lt;String,Object&gt; map = new HashMap();map.put(&quot;name&quot;, &quot;zhangsan&quot;);map.put(&quot;age&quot;, 21); resize() 初始化 table 或对 table 进行双倍扩容，源码如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/** * Initializes or doubles table size. If null, allocates in * accord with initial capacity target held in field threshold. * Otherwise, because we are using power-of-two expansion, the * elements from each bin must either stay at same index, or move * with a power of two offset in the new table. * * @return the table */final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; // 第一次 put 的时候，table = null int oldCap = (oldTab == null) ? 0 : oldTab.length; // oldCap = 0 int oldThr = threshold; // threshold=0, oldThr = 0 int newCap, newThr = 0; if (oldCap &gt; 0) &#123; // 条件不满足，往下走 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else &#123; // zero initial threshold signifies using defaults 走到这里，进行默认初始化 newCap = DEFAULT_INITIAL_CAPACITY; // DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4 = 16, newCap = 16; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); // newThr = 0.75 * 16 = 12; &#125; if (newThr == 0) &#123; // 条件不满足 float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; // threshold = 12; 重置阀值为12 @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; // 初始化 newTab, length = 16; table = newTab; // table 初始化完成, length = 16; if (oldTab != null) &#123; // 此时条件不满足，后续扩容的时候，走此if分支 将数组元素复制到新数组 for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab; // 新数组&#125; 自此，问题 1 的答案就明了了: 1234567table 的初始化时机是什么时候 一般情况下，在第一次 put 的时候，调用 resize 方法进行 table 的初始化（懒初始化，懒加载思想在很多框架中都有应用！） 初始化的 table.length 是多少、阀值（threshold）是多少，实际能容下多少元素 默认情况下，table.length = 16; 指定了 initialCapacity 的情况放到问题 5 中分析 默认情况下，threshold = 12; 指定了 initialCapacity 的情况放到问题 5 中分析 默认情况下，能存放 12 个元素，当存放第 13 个元素后进行扩容 问题二：table 的扩容先来看看 putval() 的源码：a 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * Implements Map.put and related methods * * @param hash hash for key * @param key the key * @param value the value to put * @param onlyIfAbsent if true, don&#x27;t change existing value * @param evict if false, the table is in creation mode. * @return previous value, or null if none */final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; if (++size &gt; threshold) // 当size（已存放元素个数） &gt; thrshold（阀值），进行扩容 resize(); afterNodeInsertion(evict); return null;&#125; 还是调用 resize() 进行扩容，但与初始化时不同 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/** * Initializes or doubles table size. If null, allocates in * accord with initial capacity target held in field threshold. * Otherwise, because we are using power-of-two expansion, the * elements from each bin must either stay at same index, or move * with a power of two offset in the new table. * * @return the table */final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; // 此时的 table != null，oldTab 指向旧的 table int oldCap = (oldTab == null) ? 0 : oldTab.length; // oldCap = table.length; 第一次扩容时是 16 int oldThr = threshold; // threshold=12, oldThr = 12; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; // 条件满足，走此分支 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; // oldCap左移一位; newCap = 16 &lt;&lt; 1 = 32; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold // newThr = 12 &lt;&lt; 1 = 24; &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; // DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4 = 16, newCap = 16; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; if (newThr == 0) &#123; // 条件不满足 float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; // threshold = newThr = 24; 重置阀值为 24 @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; // 初始化 newTab, length = 32; table = newTab; // table 指向 newTab, length = 32; if (oldTab != null) &#123; // 扩容后，将 oldTab(旧table) 中的元素移到 newTab（新table）中 for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; // else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab;&#125; 自此，问题 2 的答案也就清晰了: 1234什么时候触发扩容，扩容之后的 table.length、阀值各是多少 当 size &gt; threshold 的时候进行扩容 扩容之后的 table.length = 旧 table.length * 2, 扩容之后的 threshold = 旧 threshold * 2 问题 三、四 ：2 的 n 次幂从 Key 映射到 HashMap 数组的对应位置，会用到一个Hash函数： index = Hash（“apple”） 如何实现一个尽量均匀分布的 Hash 函数呢？我们通过利用 Key 的 HashCode 值来做某种运算。如何进行位运算呢？有如下的公式（Length 是 HashMap 的长度）： index = HashCode（Key） &amp; （Length - 1） 下面我们以“book”的Key来演示整个过程： 1.计算 book 的 hashcode，结果为十进制的 3029737，二进制的 10 1110 0011 1010 1110 1001。 2.假定 HashMap 长度是默认的 16，计算 Length-1 的结果为十进制的 15，二进制的 1111。 3.把以上两个结果做与运算，101110001110101110 1001 &amp; 1111 = 1001，十进制是 9，所以 index=9。 可以说，Hash 算法最终得到的 index 结果，完全取决于 Key 的 Hashcode 值的最后几位。 假设 HashMap 的长度是10，重复刚才的运算步骤： 123hashcode 10 1110 0011 1010 1110 1001length - 1: 1001index: 1001 单独看这个结果，表面上并没有问题。我们再来尝试一个新的 HashCode 10 1110 0011 1010 1110 1011 ： 123hashcode 10 1110 0011 1010 1110 1011length - 1: 1001index: 1001 让我们再换一个HashCode 10 1110 0011 1010 1110 1111 试试 ： 123hashcode 10 1110 0011 1010 1110 1111length - 1: 1001index: 1001 是的，虽然HashCode的倒数第二第三位从0变成了1，但是运算的结果都是1001。也就是说，当HashMap长度为10的时候，有些index结果的出现几率会更大，而有些index结果永远不会出现（比如0111）！ 这样，显然不符合Hash算法均匀分布的原则。 反观长度16或者其他2的幂，Length - 1 的值是所有二进制位全为 1，这种情况下，index 的结果等同于 HashCode 后几位的值。只要输入的 HashCode 本身分布均匀，Hash 算法的结果就是均匀的。自此，2 的 n 次幂的相关问题就清楚了: 123456table 的 length 为什么是 2 的 n 次幂 为了利用位运算 &amp; 求 key 的下标求索引的时候为什么是：h &amp; (length-1)，而不是 h &amp; length，更不是 h % length h % length 效率不如位运算快 h &amp; length 会提高碰撞几率，导致 table 的空间得不到更充分的利用、降低 table 的操作效率 问题五：指定 initialCapacity调用 tableSizeFor 进行 threshold 的初始化: 123456789101112131415/** * Returns a power of two size for the given target capacity. * 返回 &gt;= cap 最小的 2^n * cap = 10, 则返回 2^4 = 16; * cap = 5, 则返回 2^3 = 8; */static final int tableSizeFor(int cap) &#123; int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;&#125; 虽然此处初始化的是 threshold，但后面初始化 table 的时候，会将其用于 table 的 length，同时会重置 threshold 为 table.length * loadFactor 自此，问题 5 也就清楚了: 12345Map map = new HashMap(1000); 当我们存入多少个元素时会触发map的扩容 此时的 table.length = 2^10 = 1024; threshold = 1024 * 0.75 = 768; 所以存入第 769 个元素时进行扩容Map map1 = new HashMap(10000); 我们存入第 10001个元素时会触发 map1 扩容吗 此时的 table.length = 2^14 = 16384; threshold = 16384 * 0.75 = 12288; 所以存入第 10001 个元素时不会进行扩容 问题六：加载因子1234为什么加载因子的默认值是 0.75，并且不推荐我们修改 如果 loadFactor 太小，那么 map 中的 table 需要不断的扩容，扩容是个耗时的过程 如果 loadFactor 太大，那么 map 中 table 放满了也不不会扩容，导致冲突越来越多，解决冲突而起的链表越来越长，效率越来越低 而 0.75 这是一个折中的值，是一个比较理想的值","categories":[{"name":"java 集合","slug":"java-集合","permalink":"http://example.com/categories/java-%E9%9B%86%E5%90%88/"}],"tags":[{"name":"java 集合","slug":"java-集合","permalink":"http://example.com/tags/java-%E9%9B%86%E5%90%88/"}]},{"title":"在浏览器中输入 url 地址，按下回车后发生了什么","slug":"在浏览器中输入URL","date":"2021-11-02T00:44:09.229Z","updated":"2021-11-02T01:06:17.456Z","comments":true,"path":"2021/11/02/在浏览器中输入URL/","link":"","permalink":"http://example.com/2021/11/02/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5URL/","excerpt":"打开一个网页，整个过程会使用哪些协议？","text":"打开一个网页，整个过程会使用哪些协议？ 总体来说分为以下几个过程: DNS 解析 TCP 连接(三次握手) 发送 HTTP 请求(通过TCP套接字发送) 服务器处理请求并返回 HTTP 报文 浏览器解析渲染页面 连接结束(四次挥手) 1.DNS 解析NS解析的过程就是寻找哪台机器上有你需要资源的过程。当你在浏览器中输入一个地址时，例如www.baidu.com，其实不是百度网站真正意义上的地址。互联网上每一台计算机的唯一标识是它的IP地址，但是IP地址并不方便记忆。用户更喜欢用方便记忆的网址去寻找互联网上的其它计算机，也就是上面提到的百度的网址。所以互联网设计者需要在用户的方便性与可用性方面做一个权衡，这个权衡就是一个网址到IP地址的转换，这个过程就是DNS解析。它实际上充当了一个翻译的角色，实现了网址到IP地址的转换。网址到IP地址转换的过程是如何进行的? 1.1 解析过程DNS解析是一个递归查询的过程。 上述图片是查找www.google.com的IP地址过程。首先在本地域名服务器中查询IP地址，如果没有找到的情况下，本地域名服务器会向根域名服务器发送一个请求，如果根域名服务器也不存在该域名时，本地域名会向com顶级域名服务器发送一个请求，依次类推下去。直到最后本地域名服务器得到google的IP地址并把它缓存到本地，供下次查询使用。从上述过程中，可以看出网址的解析是一个从右向左的过程: com -&gt; google.com -&gt; www.google.com。但是你是否发现少了点什么，根域名服务器的解析过程呢？事实上，真正的网址是www.google.com.，并不是我多打了一个.，这个.对应的就是根域名服务器，默认情况下所有的网址的最后一位都是.，既然是默认情况下，为了方便用户，通常都会省略，浏览器在请求DNS的时候会自动加上，所有网址真正的解析过程为: . -&gt; .com -&gt; google.com. -&gt; www.google.com.。 1.2 DNS 优化了解了DNS的过程，可以为我们带来哪些？上文中请求到google的IP地址时，经历了8个步骤，这个过程中存在多个请求(大多数情况下 DNS 使用 UDP 进行传输，这就要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。)。如果每次都经过这么多步骤，是否太耗时间？如何减少该过程的步骤呢？那就是DNS缓存。 1.2.1 DNS 缓存DNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种: 浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。 1.2.2 DNS 负载均衡首先思考一个问题：DNS返回的IP地址是否每次都一样？如果每次都一样是否说明你请求的资源都位于同一台机器上面，那么这台机器需要多高的性能和储存才能满足亿万请求呢？其实真实的互联网世界背后存在成千上百台服务器，大型的网站甚至更多。但是在用户的眼中，它需要的只是处理他的请求，哪台机器处理请求并不重要。DNS可以返回一个合适的机器的IP给用户，例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等，这种过程就是DNS负载均衡，又叫做DNS重定向。 2. TCP 连接HTTP 是基于 TCP 协议传输的,客户端与服务器通过三次握手建立起 TCP 连接，具体过程可参考：TCP的三次握手。 3. 发送 HTTP 请求(前端 HTTP)建立了TCP连接之后，发起一个http请求,发送HTTP请求的过程就是构建HTTP请求报文并通过TCP协议中发送到服务器指定端口(HTTP协议80/8080, HTTPS协议443)。HTTP请求报文是由三部分组成: 请求行, 请求报头和请求正文。 3.1 请求行格式如下:Method Request-URL HTTP-Version CRLF 1eg: GET index.html HTTP/1.1 常用的方法有: GET, POST, PUT, DELETE, OPTIONS, HEAD。 3.1.1 Get 和 POST 有什么区别？ Http报文层面： GET请求信息放在URL，POST放在报文体中 GET请求中一般浏览器对URL长度有限制；POST请求数据长度无限制 数据库层面： GET服务幂等性（对数据库的一次操作和多次操作上一致的）和安全性（没有改变数据库的数据） POST不符合幂等性和安全性 其他层面： GET可以被缓存，被存储，而POST不行 GET请求的内容会被保存在浏览器中 超过90%的GET请求都被CDN(Content Delivery Network)缓存了，大大减少web服务起器的负担 3.2 请求报头请求报头允许客户端向服务器传递请求的附加信息和客户端自身的信息。 PS: 客户端不一定特指浏览器，有时候也可使用Linux下的CURL命令以及HTTP客户端测试工具等。 常见的请求报头有: Acce pt, Accept-Charset, Accept-Encoding, Accept-Language, Content-Type, Authorization, Cookie, User-Agent等。 Accept用于指定客户端用于接受哪些类型的信息。 Accept-Encoding与Accept类似，它用于指定接受的编码方式。 Connection设置为Keep-alive用于告诉客户端本次HTTP请求结束之后并不需要关闭TCP连接，这样可以使下次HTTP请求使用相同的TCP通道，节省TCP连接建立的时间。 3.3 请求正文当使用POST, PUT等方法时，通常需要客户端向服务器传递数据。这些数据就储存在请求正文中。在请求包头中有一些与请求正文相关的信息，例如: 现在的Web应用通常采用Rest架构，请求的数据格式一般为json。这时就需要设置Content-Type: application/json。 4. 服务器处理请求并返回HTTP报文(后端 HTTP)后端从在固定的端口接收到TCP报文开始，这一部分对应于编程语言中的socket。它会对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装成HTTP Request对象，供上层使用。这一部分工作一般是由Web服务器去进行，如Tomcat, Jetty和Netty等等。 HTTP响应报文也是由三部分组成: 状态码, 响应报头和响应报文。 4.1 状态码状态码是由3位数组成，第一个数字定义了响应的类别，且有五种可能取值: 1xx：指示信息–表示请求已接收，继续处理。 2xx：成功–表示请求已被成功接收、理解、接受。 3xx：重定向–要完成请求必须进行更进一步的操作。 4xx：客户端错误–请求有语法错误或请求无法实现。 5xx：服务器端错误–服务器未能实现合法的请求。 平时遇到比较常见的状态码有: 200 OK :正常返回信息。 400 Bad Rqquest：客户端请求有语法错误，不能被服务器理解。 401 Unauthorized：请求未经授权，这个状态代码和WWW-Authenticate报头域一起使用。 403 Forbidden：服务器收到请求，但是拒绝提供服务。 404 Not Found：请求资源不存在，比如输入了错误的URL。 500 Internal Server Error：服务器发生了不可预期的错误。 503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常。 4.1.1 301 和 302 有什么区别？301和302状态码都表示重定向，就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址，这个地址可以从响应的Location首部中获取（用户看到的效果就是他输入的地址A瞬间变成了另一个地址B）——这是它们的共同点。 他们的不同在于: 301表示旧地址A的资源已经被永久地移除了（这个资源不可访问了），搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址。 302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，搜索引擎会抓取新的内容而保存旧的网址。 4.2 响应报头常见的响应报头字段有: Server, Connection。 4.3 响应报文服务器返回给浏览器的文本信息，通常HTML, CSS, JS, 图片等文件就放在这一部分。 5. 浏览器解析渲染页面客户端浏览器解析HTML内容，这部分暂时没有深入学习。 6. 连接结束 (四次挥手)具体过程可参考：TCP 的四次挥手","categories":[{"name":"计算机网","slug":"计算机网","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91/"}],"tags":[{"name":"计算机网","slug":"计算机网","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91/"}]},{"title":"TCP的四次挥手","slug":"TCP的四次挥手","date":"2021-11-02T00:43:59.496Z","updated":"2021-11-02T00:55:52.744Z","comments":true,"path":"2021/11/02/TCP的四次挥手/","link":"","permalink":"http://example.com/2021/11/02/TCP%E7%9A%84%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/","excerpt":"TCP 的四次挥手(45条消息) 两张动图-彻底明白TCP的三次握手与四次挥手_qzcsu的博客-CSDN博客_三次握手四次挥手详解 TCP 四次挥手的过程1234A：老师，下课了。B：好，我知道了，我说完这点。B：好了，说完了，下课吧。A：谢谢老师，老师再见。","text":"TCP 的四次挥手(45条消息) 两张动图-彻底明白TCP的三次握手与四次挥手_qzcsu的博客-CSDN博客_三次握手四次挥手详解 TCP 四次挥手的过程1234A：老师，下课了。B：好，我知道了，我说完这点。B：好了，说完了，下课吧。A：谢谢老师，老师再见。 客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送 服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加 1 。和 SYN 一样，一个 FIN 将占用一个序号 服务器-关闭与客户端的连接，发送一个 FIN 给客户端 客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加 1 任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接。 为什么要四次挥手客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。 TIME_WAIT 状态客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSLMSL是Maximum Segment Lifetime，报文最大生存时间。这么做有两个理由： 确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。 等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。 为什么建立连接是三次握手，关闭连接确是四次挥手呢？建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。","categories":[{"name":"计算机网","slug":"计算机网","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91/"}],"tags":[{"name":"计算机网","slug":"计算机网","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91/"}]},{"title":"TCP的三次握手","slug":"TCP的三次握手","date":"2021-11-02T00:43:59.164Z","updated":"2021-11-02T00:55:37.968Z","comments":true,"path":"2021/11/02/TCP的三次握手/","link":"","permalink":"http://example.com/2021/11/02/TCP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/","excerpt":"TCP的三次握手1. IP协议 IP协议是无连接的通信协议，他不会占用两个正在通信的计算机之间的通信线路，这样IP就降低了对网络线路的需求，每条线可以同时满足许多不同的计算机之间的通信需要。 通过IP消息或者其他数据会被分割为较小的独立的包，并通过因特网在计算机之间传送。 IP负责将每个包路由至他的目的地，但IP协议没有确认数据包是否按顺序发送或者包是否损坏，所以IP数据包是不可靠的，需要由他的上层协议作出控制。","text":"TCP的三次握手1. IP协议 IP协议是无连接的通信协议，他不会占用两个正在通信的计算机之间的通信线路，这样IP就降低了对网络线路的需求，每条线可以同时满足许多不同的计算机之间的通信需要。 通过IP消息或者其他数据会被分割为较小的独立的包，并通过因特网在计算机之间传送。 IP负责将每个包路由至他的目的地，但IP协议没有确认数据包是否按顺序发送或者包是否损坏，所以IP数据包是不可靠的，需要由他的上层协议作出控制。 2. TCP 三次握手的过程123A：您好，我是 A。B：您好 A，我是 B。A：您好 B。 首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。 A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。 B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。 A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。 B 收到 A 的确认后，连接建立。 3. 为什么要三次握手三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。 第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常 第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常 第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常 所以三次握手就能确认双发收发功能都正常，缺一不可。 当然 A 发给 B 的应答之应答也会丢，也会绕路，甚至 B 挂了。按理来说，还应该有个应答之应答之应答，这样下去就没底了。所以四次握手是可以的，四十次都可以，关键四百次也不能保证就真的可靠了。只要双方的消息都有去有回，就基本可以了。 其次，第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。 客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。 3.1 第 2 次握手传回了 ACK，为什么还要传回 SYN？接收端传回发送端所发送的 ACK 是为了告诉客户端，我接收到的信息确实就是你所发送的信号了，这表明从客户端到服务端的通信是正常的。而回传 SYN 则是为了建立并确认从服务端到客户端的通信。” SYN 同步序列编号(Synchronize Sequence Numbers) 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement）消息响应。这样在客户机和服务器之间才能建立起可靠的 TCP 连接，数据才可以在客户机和服务器之间传递。","categories":[{"name":"计算机网","slug":"计算机网","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91/"}],"tags":[{"name":"计算机网","slug":"计算机网","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91/"}]},{"title":"递归算法学习笔记","slug":"递归算法学习笔记","date":"2021-09-04T14:32:51.527Z","updated":"2021-10-26T09:22:24.397Z","comments":true,"path":"2021/09/04/递归算法学习笔记/","link":"","permalink":"http://example.com/2021/09/04/%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"1.递归的概念递归就是方法自己调用自己,每次调用时传入不同的变量.递归有助于解决复杂的问题的同时还可以让代码变得更加简洁。但是值得注意的是，递归只是让解决方案变得清晰，并没有性能上的优势，有时甚至还没有循环的性能好，而这也是递归的主要缺点之一。 比如定义函数 f(x)=x+f(x-1)：","text":"1.递归的概念递归就是方法自己调用自己,每次调用时传入不同的变量.递归有助于解决复杂的问题的同时还可以让代码变得更加简洁。但是值得注意的是，递归只是让解决方案变得清晰，并没有性能上的优势，有时甚至还没有循环的性能好，而这也是递归的主要缺点之一。 比如定义函数 f(x)=x+f(x-1)： 123public void f(int x)&#123; return x + f(x-1);&#125; 1.1 递归的条件和规则递归自己调用自己，因此写递归时很容易出错，陷入无限循环。因此编写递归方法时，必须设定条件告诉递归何时停止。如上面的例子： 如果代入 f(2)： 返回 2+f(1)； 调用 f(1)； 返回 1+f(0)； 调用 f(0)； 返回 0+f(-1)； …… 这时程序会无休止地运行下去，直到崩溃。 如果我们加一个判断语句 x&gt;0; 1234567public void f(int x)&#123; if(x &gt; 0)&#123; return x + f(x-1); &#125; else &#123; return 0; &#125;&#125; 这次计算 f(2)=2+f(1)=2+1+f(0)=2+1+0=3。 由此可得递归的两个规律： 递归函数必须要有终止条件，否则会出错； 递归函数先不断调用自身，直到遇到终止条件后进行回溯，最终返回答案。 执行一个方法时，就创建一个新的受保护的独立空间(栈空间) 方法的局部变量是独立的，不会相互影响, 比如 n 变量 如果方法中使用的是引用类型变量(比如数组)，就会共享该引用类型的数据. 递归必须向退出递归的条件逼近，否则就是无限递归,会报栈溢出的错误 。 当一个方法执行完毕，或者遇到 return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或 者返回时，该方法也就执行完毕。 1.2 递归的机制图解 2 递归的应用场景2.1 阶乘问题问题描述：使用递归方法来完成自然数的阶乘。 1234567public static int factorial(int n) &#123; if (n == 1) &#123; return 1; &#125; else &#123; return factorial(n - 1) * n; // 1 * 2 * 3 &#125;&#125; 2.2 迷宫问题 如图所示的迷宫为小球找到路，使其能走到迷宫的右下角。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091package com.atguigu.recursion;public class MiGong &#123; public static void main(String[] args) &#123; // 先创建一个二维数组，模拟迷宫 // 地图 int[][] map = new int[8][7]; // 使用1 表示墙 // 上下全部置为1 for (int i = 0; i &lt; 7; i++) &#123; map[0][i] = 1; map[7][i] = 1; &#125; // 左右全部置为1 for (int i = 0; i &lt; 8; i++) &#123; map[i][0] = 1; map[i][6] = 1; &#125; //设置挡板, 1 表示 map[3][1] = 1; map[3][2] = 1; // 输出地图 System.out.println(&quot;地图的情况&quot;); for (int i = 0; i &lt; 8; i++) &#123; for (int j = 0; j &lt; 7; j++) &#123; System.out.print(map[i][j] + &quot; &quot;); &#125; System.out.println(); &#125; //使用递归回溯给小球找路 System.out.println(&quot;小球走过，并标识过的 地图的情况&quot;); setWay(map, 1, 1); //setWay2(map, 1, 1); //输出新的地图, 小球走过，并标识过的递归 for (int i = 0; i &lt; 8; i++) &#123; for (int j = 0; j &lt; 7; j++) &#123; System.out.print(map[i][j] + &quot; &quot;); &#125; System.out.println(); &#125; &#125; //使用递归回溯来给小球找路 //说明 //1. map 表示地图 //2. i,j 表示从地图的哪个位置开始出发 (1,1) //3. 如果小球能到 map[6][5] 位置，则说明通路找到. //4. 约定： 当map[i][j] 为 0 表示该点没有走过 当为 1 表示墙 ； 2 表示通路可以走 ； 3 表示该点已经走过，但是走不通 //5. 在走迷宫时，需要确定一个策略(方法) 下-&gt;右-&gt;上-&gt;左 , 如果该点走不通，再回溯 /** * @param map 表示地图 * @param i 从哪个位置开始找 * @param j * @return 如果找到通路，就返回true, 否则返回false */ public static boolean setWay(int[][] map, int i, int j) &#123; if (map[6][5] == 2) &#123; // 通路已经找到ok return true; &#125; else &#123; System.out.printf(&quot;(%d,%d)&quot;, i, j); System.out.println(); if (map[i][j] == 0) &#123; //如果当前这个点还没有走过 //按照策略 下-&gt;右-&gt;上-&gt;左 走 map[i][j] = 2; // 假定该点是可以走通. if (setWay(map, i + 1, j)) &#123;//向下走 return true; &#125; else if (setWay(map, i, j + 1)) &#123; //向右走 return true; &#125; else if (setWay(map, i - 1, j)) &#123; //向上 return true; &#125; else if (setWay(map, i, j - 1)) &#123; // 向左走 return true; &#125; else &#123; //说明该点是走不通，是死路 map[i][j] = 3; return false; &#125; &#125; else &#123; // 如果map[i][j] != 0 , 可能是 1， 2， 3 return false; &#125; &#125; &#125;&#125; 2.3 N皇后问题问题描述（此处以8皇后为例）：在 8×8 格的国际象棋上摆放八个皇后，使其不能互相攻击，即：任意两个皇后都不能处于同一行、 同一列或同一斜线上，问有多少种摆法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package com.atguigu.recursion;public class Queue8 &#123; //定义一个max表示共有多少个皇后 int max = 8; //定义数组array, 保存皇后放置位置的结果,比如 arr = &#123;0 , 4, 7, 5, 2, 6, 1, 3&#125; int[] array = new int[max]; static int count = 0; static int judgeCount = 0; public static void main(String[] args) &#123; //测试一把 ， 8皇后是否正确 Queue8 queue8 = new Queue8(); queue8.check(0); System.out.printf(&quot;一共有%d解法&quot;, count); System.out.printf(&quot;一共判断冲突的次数%d次&quot;, judgeCount); // 1.5w &#125; //编写一个方法，放置第n个皇后 //特别注意： check 是 每一次递归时，进入到check中都有 for(int i = 0; i &lt; max; i++)，因此会有回溯 private void check(int n) &#123; if (n == max) &#123; //n = 8 , 其实8个皇后就已然放好 print(); return; &#125; //依次放入皇后，并判断是否冲突 for (int i = 0; i &lt; max; i++) &#123; //先把当前这个皇后 n , 放到该行的第1列 array[n] = i; //判断当放置第n个皇后到i列时，是否冲突 if (judge(n)) &#123; // 不冲突 //接着放n+1个皇后,即开始递归 check(n + 1); // &#125; //如果冲突，就继续执行 array[n] = i; 即将第n个皇后，放置在本行得 后移的一个位置 &#125; &#125; //查看当我们放置第n个皇后, 就去检测该皇后是否和前面已经摆放的皇后冲突 /** * @param n 表示第n个皇后 * @return */ private boolean judge(int n) &#123; judgeCount++; for (int i = 0; i &lt; n; i++) &#123; // 说明 //1. array[i] == array[n] 表示判断 第n个皇后是否和前面的n-1个皇后在同一列 //2. Math.abs(n-i) == Math.abs(array[n] - array[i]) 表示判断第n个皇后是否和第i皇后是否在同一斜线 // n = 1 放置第 2列 1 n = 1 array[1] = 1 // Math.abs(1-0) == 1 Math.abs(array[n] - array[i]) = Math.abs(1-0) = 1 //3. 判断是否在同一行, 没有必要，n 每次都在递增 if (array[i] == array[n] || Math.abs(n - i) == Math.abs(array[n] - array[i])) &#123; return false; &#125; &#125; return true; &#125; //写一个方法，可以将皇后摆放的位置输出 private void print() &#123; count++; for (int i = 0; i &lt; array.length; i++) &#123; System.out.print(array[i] + &quot; &quot;); &#125; System.out.println(); &#125;&#125; 说明： 理论上应该创建一个二维数组来表示棋盘，但是实际上可以通过算法，用一个一维数组即可解决问题. 1arr[8] = &#123;0 , 4, 7, 5, 2, 6, 1, 3&#125; //对应 arr 下标 表示第几行，即第几个皇后，arr[i] = val , val 表示第 i+1 个皇后，放在第 i+1 行的第 val+1 列。 3 leetcode上对应的easy递归题目1234567891011206.反转一个单链表。示例:输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL进阶:你可以迭代或递归地反转链表。你能否用两种方法解决这道题？来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/reverse-linked-list 1234567891011121314151617181920递归解法 class Solution &#123; public ListNode reverseList(ListNode head) &#123; //递归终止条件是当前为空，或者下一个节点为空 if(head==null || head.next==null) &#123; return head; &#125; //这里的cur就是最后一个节点 ListNode cur = reverseList(head.next); //这里请配合动画演示理解 //如果链表是 1-&gt;2-&gt;3-&gt;4-&gt;5，那么此时的cur就是5 //而head是4，head的下一个是5，下下一个是空 //所以head.next.next 就是5-&gt;4 head.next.next = head; //防止链表循环，需要将head.next设置为空 head.next = null; //每层递归函数都返回cur，也就是最后一个节点 return cur; &#125;&#125; 1234567891011121314151617181920212223242526509.斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：F(0) = 0，F(1) = 1F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1给你 n ，请计算 F(n) 。 示例 1：输入：2输出：1解释：F(2) = F(1) + F(0) = 1 + 0 = 1示例 2：输入：3输出：2解释：F(3) = F(2) + F(1) = 1 + 1 = 2示例 3：输入：4输出：3解释：F(4) = F(3) + F(2) = 2 + 1 = 3来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/fibonacci-number 12345678910111213class Solution &#123; public int fib(int n) &#123; int Fn = 0; if(n==0)&#123; return 0; &#125; if(n==1)&#123; return 1; &#125; Fn = fib(n-1)+fib(n-2); return Fn; &#125;&#125; 需要注意的是，对这题来说递归并不是最好的解法，相较于动态优化来说其性能并不是很优。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"枚举与注解复习总结","slug":"枚举与注解复习总结","date":"2021-09-04T14:32:51.524Z","updated":"2021-10-26T09:22:53.641Z","comments":true,"path":"2021/09/04/枚举与注解复习总结/","link":"","permalink":"http://example.com/2021/09/04/%E6%9E%9A%E4%B8%BE%E4%B8%8E%E6%B3%A8%E8%A7%A3%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93/","excerpt":"枚举主要内容: 如何自定义枚举类 如何使用关键字enum定义枚举类 Enum类的主要方法 实现接口的枚举类 一、枚举类的使用 1.枚举类的理解：类的对象只有有限个，确定的。我们称此类为枚举类 2.当需要定义一组常量(final关键字)时，强烈建议使用枚举类 3.如果枚举类中只有一个对象，则可以作为单例模式的实现方式。 二、如何定义枚举类 方式一：jdk5.0之前，自定义枚举类","text":"枚举主要内容: 如何自定义枚举类 如何使用关键字enum定义枚举类 Enum类的主要方法 实现接口的枚举类 一、枚举类的使用 1.枚举类的理解：类的对象只有有限个，确定的。我们称此类为枚举类 2.当需要定义一组常量(final关键字)时，强烈建议使用枚举类 3.如果枚举类中只有一个对象，则可以作为单例模式的实现方式。 二、如何定义枚举类 方式一：jdk5.0之前，自定义枚举类 方式二：jdk5.0，可以使用enum关键字定义枚举类 1.自定义枚举类1234567891011121314151617181920212223242526272829303132333435//自定义枚举类class Season&#123; //1.声明Season对象的属性:private final修饰 private final String seasonName; private final String seasonDesc; //2.私有化类的构造器,并给对象属性赋值 private Season(String seasonName,String seasonDesc)&#123; this.seasonName = seasonName; this.seasonDesc = seasonDesc; &#125; //3.提供当前枚举类的多个对象：public static final的 public static final Season SPRING = new Season(&quot;春天&quot;,&quot;春暖花开&quot;); public static final Season SUMMER = new Season(&quot;夏天&quot;,&quot;夏日炎炎&quot;); public static final Season AUTUMN = new Season(&quot;秋天&quot;,&quot;秋高气爽&quot;); public static final Season WINTER = new Season(&quot;冬天&quot;,&quot;冰天雪地&quot;); //4.其他诉求1：获取枚举类对象的属性 public String getSeasonName() &#123; return seasonName; &#125; public String getSeasonDesc() &#123; return seasonDesc; &#125; //4.其他诉求1：提供toString() @Override public String toString() &#123; return &quot;Season&#123;&quot; + &quot;seasonName=&#x27;&quot; + seasonName + &#x27;\\&#x27;&#x27; + &quot;, seasonDesc=&#x27;&quot; + seasonDesc + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 2.使用enum关键字定义枚举类说明： 定义的枚举类默认继承于java.lang.Enum类,因此不能再继承其他类 枚举类的构造器只能使用 private 权限修饰符 枚举类的所有实例必须在枚举类中显式列出(, 分隔 ; 结尾)。列出的 实例系统会自动添加 ==public static final==修饰 ==必须在枚举类的第一行声明枚举类对象== 12345678910111213141516171819202122232425262728//使用enum关键字枚举类enum Season1 implements Info&#123; //1.提供当前枚举类的对象，多个对象之间用&quot;,&quot;隔开，末尾对象&quot;;&quot;结束 SPRING(&quot;春天&quot;,&quot;春暖花开&quot;), SUMMER(&quot;夏天&quot;,&quot;夏日炎炎&quot;), AUTUMN(&quot;秋天&quot;,&quot;秋高气爽&quot;), WINTER(&quot;冬天&quot;,&quot;天寒地冻&quot;); //2.声明Season对象的属性:private final修饰 private final String seasonName; private final String seasonDesc; //2.私有化类的构造器,并给对象属性赋值 private Season1(String seasonName,String seasonDesc)&#123; this.seasonName = seasonName; this.seasonDesc = seasonDesc; &#125; //4.其他诉求1：获取枚举类对象的属性 public String getSeasonName() &#123; return seasonName; &#125; public String getSeasonDesc() &#123; return seasonDesc; &#125; 三、Enum类的主要方法： values()方法：返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值。 valueOf(String str)：可以把一个字符串转为对应的枚举类对象。要求字符 串必须是枚举类对象的“名字”。如不是，会有运行时异常： IllegalArgumentException。 toString()：返回当前枚举类对象常量的名称。 四、使用enum关键字定义的枚举类实现接口的情况12情况一：实现接口，在enum类中实现抽象方法情况二：让枚举类的对象分别实现接口中的抽象方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051interface Info&#123; void show();&#125;//使用enum关键字枚举类enum Season1 implements Info&#123; //1.提供当前枚举类的对象，多个对象之间用&quot;,&quot;隔开，末尾对象&quot;;&quot;结束 SPRING(&quot;春天&quot;,&quot;春暖花开&quot;)&#123; @Override public void show() &#123; System.out.println(&quot;春天在哪里？&quot;); &#125; &#125;, SUMMER(&quot;夏天&quot;,&quot;夏日炎炎&quot;)&#123; @Override public void show() &#123; System.out.println(&quot;宁夏&quot;); &#125; &#125;, AUTUMN(&quot;秋天&quot;,&quot;秋高气爽&quot;)&#123; @Override public void show() &#123; System.out.println(&quot;秋天不回来&quot;); &#125; &#125;, WINTER(&quot;冬天&quot;,&quot;冰天雪地&quot;)&#123; @Override public void show() &#123; System.out.println(&quot;大约在冬季&quot;); &#125; &#125;; //2.声明Season对象的属性:private final修饰 private final String seasonName; private final String seasonDesc; //2.私有化类的构造器,并给对象属性赋值 private Season1(String seasonName,String seasonDesc)&#123; this.seasonName = seasonName; this.seasonDesc = seasonDesc; &#125; //4.其他诉求1：获取枚举类对象的属性 public String getSeasonName() &#123; return seasonName; &#125; public String getSeasonDesc() &#123; return seasonDesc; &#125; 注解主要内容：123456注解(Annotation)概述常见的Annotation示例自定义AnnotationJDK中的元注解利用反射获取注解信息（在反射部分涉及）JDK 8中注解的新特性 一、概述 从 JDK 5.0 开始, Java 增加了对元数据(MetaData) 的支持, 也就是 Annotation(注解) Annotation 其实就是代码里的特殊标记（如@Override）, 这些标记可以在编译, 类加 载, 运行时被读取, 并执行相应的处理。通过使用 Annotation, 程序员 可以在不改变原有逻辑的情况下, 在源文件中嵌入一些补充信息。代 码分析工具、开发工具和部署工具可以通过这些补充信息进行验证 或者进行部署。 Annotation 可以像修饰符一样被使用, 可用于修饰包,类, 构造器, 方 法, 成员变量, 参数, 局部变量的声明, 这些信息被保存在 Annotation 的 “name=value” 对中。 在 JavaSE 中，注解的使用目的比较简单，例如标记过时的功能， 忽略警告等。在 JavaEE/Android 中注解占据了更重要的角色，例如 用来配置应用程序的任何切面，代替 JavaEE 旧版中所遗留的繁冗 代码和XML配置等。 开发模式都是基于注解的，JPA是基于注解的，Spring2.5以上都是基于注解的，Hibernate3.x 以后也是基于注解的，现在的 Struts2 有一部分也是基于注解的了，注解是一种趋势，一定程度上 可以说：==框架 = 注解 + 反射 + 设计模式==。 使用 Annotation 时要在其前面增加 @ 符号, 并把该 Annotation 当成 一个修饰符使用。用于修饰它支持的程序元素。 二、常见的Annotation示例（1）在编译时进行格式检查(JDK内置的三个基本注解) @Override: 限定重写父类方法, 该注解只能用于方法。 @Deprecated: 用于表示所修饰的元素(类, 方法等)已过时。通常是因为所修饰的结构危险或==存在更好的选择。==但不影响使用。 @SuppressWarnings: 抑制编译器警告。如在IDEA中定义的变量未使用时，变量以灰色的形式显示。加上@SuppressWarnings(“unused”)后以黑色显示。 （2）跟踪代码依赖性，实现替代配置文件功能Servlet3.0提供了注解(annotation),使得不再需要在web.xml文件中进行Servlet的部署。 123456789@WebServlet(&quot;/login&quot;)public class LoginServlet extends HttpServlet &#123;private static final long serialVersionUID = 1L;protected void doGet(HttpServletRequest request, HttpServletResponse response) throwsServletException, IOException &#123; &#125;protected void doPost(HttpServletRequest request, HttpServletResponse response) throwsServletException, IOException &#123;doGet(request, response);&#125; &#125; 123456789&lt;servlet&gt;&lt;servlet-name&gt;LoginServlet&lt;/servlet-name&gt;&lt;servlet-class&gt;com.servlet.LoginServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;&lt;servlet-name&gt;LoginServlet&lt;/servlet-name&gt;&lt;url-pattern&gt;/login&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; spring框架中关于“事务”的管理 12345678910@Transactional(propagation=Propagation.REQUIRES_NEW,isolation=Isolation.READ_COMMITTED,readOnly=false,timeout=3)public void buyBook(String username, String isbn) &#123;//1.查询书的单价int price = bookShopDao.findBookPriceByIsbn(isbn);//2. 更新库存bookShopDao.updateBookStock(isbn);//3. 更新用户的余额bookShopDao.updateUserAccount(username, price);&#125; 三、自定义 Annotation，参照@SuppressWarnings定义 定义新的 Annotation 类型使用 @interface 关键字。 自定义注解自动继承了java.lang.annotation.Annotation接口。 Annotation 的成员变量在 Annotation 定义中以无参数方法的形式来声明。其 方法名和返回值定义了该成员的名字和类型。我们称为配置参数。==类型只能是八种基本数据类型、String类型、Class类型、enum类型、Annotation类型、 以上所有类型的数组==。 可以在定义 Annotation 的成员变量时为其指定初始值, 指定成员变量的初始 值可使用 default 关键字。 如果只有一个参数成员，建议使用参数名为value。 如果定义的注解含有配置参数，那么使用时必须指定参数值，除非它有默认 值。格式是“参数名 = 参数值” ，如果只有一个参数成员，且名称为value， 可以省略“value=”。 没有成员定义的 Annotation 称为标记; 包含成员变量的 Annotation 称为元数 据 Annotation。 注意：自定义注解必须配上注解的信息处理流程（使用反射）才有意义。自定义注解通过都会指明两个元注解：Retention、Target 12345678910111213141516@MyAnnotation(value=&quot;尚硅谷&quot;)public class MyAnnotationTest &#123; public static void main(String[] args) &#123; Class clazz = MyAnnotationTest.class; Annotation a = clazz.getAnnotation(MyAnnotation.class); MyAnnotation m = (MyAnnotation) a; String info = m.value(); System.out.println(info); &#125;&#125;@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)@interface MyAnnotation&#123; String value() default &quot;auguigu&quot;;&#125; JDK 中的元注解元注解：对现有的注解进行解释说明的注解。 JDK 的元 Annotation 用于修饰其他 Annotation 定义 JDK5.0提供了4个标准的meta-annotation类型，分别是： Retention@Retention: 只能用于修饰一个 Annotation 定义, 用于指定该 Annotation 的生命 周期, @Rentention 包含一个 RetentionPolicy 类型的成员变量, 使用 @Rentention 时必须为该 value 成员变量指定值: RetentionPolicy.SOURCE:在源文件中有效（即源文件保留），编译器直接丢弃这种策略的注释。 RetentionPolicy.CLASS（默认行为）:在class文件中有效（即class保留） ，当运行 Java 程序时, JVM 不会保留注解。 这是默认值 RetentionPolicy.RUNTIME:在运行时有效（即运行时保留），当==运行 Java 程序时, JVM 会 保留注释。程序可以通过反射获取该注释。==只有声明为RUNTIME生命周期的注解，才能通过反射获取。 1234567891011public enum RetentionPolicy&#123; SOURCE, CLASS, RUNTIME&#125;@Retention(RetentionPolicy.SOURCE)@interface MyAnnotation1&#123; &#125;@Retention(RetentionPolicy.RUNTIME)@interface MyAnnotation2&#123; &#125; Target@Target: 用于修饰 Annotation 定义, 用于指定被修饰的 Annotation 能用于 修饰哪些程序元素。 @Target 也包含一个名为 value 的成员变量。S ### Documented @Documented:用于指定被该元 Annotation 修饰的 Annotation 类将被 javadoc 工具提取成文档。默认情况下，javadoc是不包括注解的。 定义为Documented的注解必须设置Retention值为RUNTIME。 ### Inherited @Inherited: 被它修饰的 Annotation 将具有继承性。如果某个类使用了被 @Inherited 修饰的 Annotation, 则其子类将自动具有该注解。 比如：如果把标有@Inherited注解的自定义的注解标注在类级别上，子类则可以继承父类类级别的注解 实际应用中，使用较少 JDK8中注解的新特性Java 8对注解处理提供了两点改进：可重复的注解及可用于类型的注解。此外，反射也得到了加强，在Java8中能够得到方法参数的名称。这会简化标注在方法参数上的注解。 ① 在MyAnnotation上声明@Repeatable，成员值为MyAnnotations.class ② MyAnnotation的Target和Retention等元注解与MyAnnotations相同。 类型注解：JDK1.8之后，关于元注解@Target的参数类型ElementType枚举值多了两个： TYPE_PARAMETER,TYPE_USE。在Java 8之前，注解只能是在声明的地方所使用，Java8开始，注解可以应用 在任何地方。 ElementType.TYPE_PARAMETER 表示该注解能写在类型变量的声明语 句中（如：泛型声明）。 ElementType.TYPE_USE 表示该注解能写在使用类型的任何语句中。","categories":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/tags/java%E5%9F%BA%E7%A1%80/"}]},{"title":"排序算法","slug":"排序算法","date":"2021-09-04T14:32:51.522Z","updated":"2021-10-26T09:23:26.840Z","comments":true,"path":"2021/09/04/排序算法/","link":"","permalink":"http://example.com/2021/09/04/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","excerpt":"排序的分类内部排序在排序时仅使用主存储器的排序算法成为内部排序，对所有的存储器都能够高速随机存储。 外部排序在排序时需要使用外部存储的排序算法都属于外部排序。 冒泡排序冒泡排序的基本思想是迭代地对输入序列中的第一个元素到最后一个元素进行两两比较，当需要时交换这两个元素的位置（升序或者降序），持续迭代直到在一趟排序过程中不需要交换位置为止。由于排序的过程中较小的元素像气泡一样逐渐到序列的顶端，故得名“冒泡排序”。 冒泡排序代码如下：","text":"排序的分类内部排序在排序时仅使用主存储器的排序算法成为内部排序，对所有的存储器都能够高速随机存储。 外部排序在排序时需要使用外部存储的排序算法都属于外部排序。 冒泡排序冒泡排序的基本思想是迭代地对输入序列中的第一个元素到最后一个元素进行两两比较，当需要时交换这两个元素的位置（升序或者降序），持续迭代直到在一趟排序过程中不需要交换位置为止。由于排序的过程中较小的元素像气泡一样逐渐到序列的顶端，故得名“冒泡排序”。 冒泡排序代码如下： 123456789101112131415161718192021public static int[] bubble(int[] arr) &#123; int temp = 0; boolean flag = false; for (int i = 0; i &lt; arr.length; i++) &#123; for (int j = 0; j &lt; arr.length - i - 1; j++) &#123; int count = 0; if (arr[j] &gt; arr[j + 1]) &#123; flag = true; temp = arr[j + 1]; arr[j + 1] = arr[j]; arr[j] = temp; &#125; &#125; if (!flag) &#123; break; &#125; else &#123; flag = false; &#125; &#125; return arr; &#125; 代码中增加了一个附加标志位flag改进算法，用该标志位来记录是否发生了元素的交换，没有交换就意味着排序已经完成，通过判断标志位的状态来结束算法。 选择排序选择排序是一种原地排序算法，不需要额外的存储空间。选择排序的基本思路是寻找序列中的最小值，用当前位置的值交换最小值，而后对所有的元素重复执行上述过程，直到整个排序完成。 12345678910111213public static int[] fastSort(int[] arr) &#123; int min = 0; for (int i = 0; i &lt; arr.length-1; i++) &#123; for (int j = i+1; j &lt; arr.length; j++) &#123; if (arr[i] &gt; arr[j]) &#123; min = arr[j]; arr[j] = arr[i]; arr[i] = min; &#125; &#125; &#125; return arr; &#125; 插入排序插入式排序属于内部排序法，是对于欲排序的元素以插入的方式找寻该元素的适当位置，以达到排序的目的。插入排序的基本思想是：把 n 个待排序的元素看成为一个有序表和一个无序表，开始时有 序表中只包含一个元素，无序表中包含有 n-1 个元素，排序过程中每次从无序表中取出第一个元素，把它的排 序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。 例子：给定一个序列 6 2 4 5 3 8，按升序排列 ​ 6 2 4 5 3 8 （有序数列6，索引位置0，索引1-5为无序数列） ​ 2 6 4 5 3 8 （将无序数列的第一个数按照一定的顺序插入到有序数列中） ​ 2 4 6 5 3 8 （将无序数列中的数依次按顺序加入到有序数列中，知道排序完成） ​ 2 4 5 6 3 8 ​ 2 3 4 5 6 8 ​ 2 3 4 5 6 8 12345678910111213141516171819202122public static int[] insert(int[] arr) &#123; int insertVal = 0; int insertIndex = 0; for (int i = 1; i &lt; arr.length; i++) &#123; insertVal = arr[i]; insertIndex = i - 1; // 1. insertIndex &gt;= 0 保证在给 insertVal 找插入位置，不越界 // 2. insertVal &lt; arr[insertIndex] 待插入的数，还没有找到插入位置 // 3. 就需要将 arr[insertIndex] 后移 while (insertIndex &gt;= 0 &amp;&amp; insertVal &lt; arr[insertIndex]) &#123; arr[insertIndex + 1] = arr[insertIndex]; insertIndex--; &#125; //判断是否需要赋值，如果相等说明不满足赋值的条件，及还没有找到合适的插入位置，需要继续查找 if (insertIndex + 1 != i) &#123; arr[insertIndex + 1] = insertVal; &#125; &#125; return arr; &#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"Spring5框架学习系列（二）","slug":"Spring5框架学习(二)","date":"2021-09-04T14:32:51.521Z","updated":"2021-10-26T09:21:34.272Z","comments":true,"path":"2021/09/04/Spring5框架学习(二)/","link":"","permalink":"http://example.com/2021/09/04/Spring5%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0(%E4%BA%8C)/","excerpt":"AOP(面向切面编程)Ⅰ.什么是 AOP（1）面向切面编程（方面），利用 AOP 可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 （2）通俗描述：不通过修改源代码方式，在主干功能里面添加新功能 （3）使用登录例子说明 AOP","text":"AOP(面向切面编程)Ⅰ.什么是 AOP（1）面向切面编程（方面），利用 AOP 可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 （2）通俗描述：不通过修改源代码方式，在主干功能里面添加新功能 （3）使用登录例子说明 AOP Ⅱ.AOP底层原理1、AOP 底层使用动态代理(1)有两种情况动态代理第一种 有接口情况，使用 JDK 动态代理 创建接口实现类代理对象，增强类的方法 第二种 没有接口情况，使用 CGLIB 动态代理 创建子类的代理对象，增强类的方法 Ⅲ.AOP(JDK动态代理)1、使用 JDK 动态代理，使用 Proxy 类里面的方法创建代理对象 （1）调用 newProxyInstance 方法 该方法有三个参数： 第一参数，类加载器 第二参数，增强方法所在的类，这个类实现的接口，支持多个接口 第三参数，实现这个接口 InvocationHandler，创建代理对象，写增强的部分 2、编写 JDK 动态代理代码（1）创建接口，定义方法 1234public interface UserDao &#123; public int add(int a,int b); public String update(String id);&#125; （2）创建接口实现类，实现方法 12345678910111213public class UserDaoImpl implements UserDao &#123; @Override public int add(int a, int b) &#123; System.out.println(&quot;add方法执行了.....&quot;); return a+b; &#125; @Override public String update(String id) &#123; System.out.println(&quot;update方法执行了.....&quot;); return id; &#125;&#125; （3）使用 Proxy 类创建接口代理对象(即增强的功能) 123456789101112131415161718192021222324252627282930313233343536373839404142public class JDKProxy &#123; public static void main(String[] args) &#123; //创建接口实现类代理对象 Class[] interfaces = &#123;UserDao.class&#125;;// Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces, new InvocationHandler() &#123;// @Override// public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;// return null;// &#125;// &#125;); 即使用匿名内部类实现 UserDaoImpl userDao = new UserDaoImpl(); UserDao dao = (UserDao)Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces, new UserDaoProxy(userDao)); int result = dao.add(1, 2); System.out.println(&quot;result:&quot;+result); &#125;&#125;//创建代理对象代码class UserDaoProxy implements InvocationHandler &#123; //1 把创建的是谁的代理对象，把谁传递过来 //有参数构造传递 private Object obj; public UserDaoProxy(Object obj) &#123; this.obj = obj; &#125; //增强的逻辑 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //方法之前 System.out.println(&quot;方法之前执行....&quot;+method.getName()+&quot; :传递的参数...&quot;+ Arrays.toString(args)); //被增强的方法执行 Object res = method.invoke(obj, args); //方法之后 System.out.println(&quot;方法之后执行....&quot;+obj); return res; &#125;&#125; Ⅳ.AOP术语1.连接点类里面有哪些方法可以被增强，这些方法就被叫做连接点。 2.切入点实际真正被增强的方法就被称为切入点。 3.通知（增强）（1）实际增强的逻辑部分就叫做通知（增强）。 （2）通知有多种类型 前置通知：在被增强方法之前执行 后置通知：在被增强方法之后执行 环绕通知：在被增强方法之前和之后都会执行 异常通知：在被增强方法抛出异常时会执行 最终通知：类似finally，一定会执行 4.切面是动作上的一个操作，即把通知应用到切入点的过程就叫做切面。 Ⅴ.AOP 操作（准备工作）1、Spring 框架一般都是基于 AspectJ 实现 AOP 操作什么是AspectJ：AspectJ 不是 Spring 组成部分，独立 AOP 框架，一般把 AspectJ 和 Spirng 框架一起使用，进行 AOP 操作。 2、基于 AspectJ 实现 AOP 操作（1）基于 xml 配置文件实现 （2）基于注解方式实现（实际中一般使用注解方式实现） 3、在项目工程里面引入 AOP 相关依赖 4、切入点表达式（1）切入点表达式作用：知道对哪个类里面的哪个方法进行增强 （2）语法结构： execution([权限修饰符] [返回类型] [类全路径] [方法名称] （[参数列表]）) 123//举例 1：对 com.atguigu.dao.BookDao 类里面的 add 进行增强 *表示任意修饰符，返回类型可以省略execution(* com.atguigu.dao.BookDao.add(..)) 12//举例 2：对 com.atguigu.dao.BookDao 类里面的所有的方法进行增强execution(* com.atguigu.dao.BookDao.* (..)) Ⅵ.AOP 操作（AspectJ 注解）1、创建类，在类里面定义方法123456public class User &#123; public void add() &#123; System.out.println(&quot;add.......&quot;); &#125;&#125; 2、创建增强类（编写增强逻辑）（1）在增强类里面，创建方法，让不同方法代表不同通知类型 123456//增强的类public class UserProxy &#123; public void before() &#123;//前置通知 System.out.println(&quot;before......&quot;); &#125;&#125; 3、进行通知的配置（1）在 spring 配置文件中，开启注解扫描 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!-- 开启注解扫描 --&gt; &lt;context:component-scan base-package=&quot;com.atguigu.spring5.aopanno&quot;&gt;&lt;/context:component-scan&gt;&lt;/beans&gt; （2）使用注解创建 User 和 UserProxy 对象 12345678//被增强的类@Componentpublic class User &#123;//增强的类@Component@Order(3)public class UserProxy &#123; （3）在增强类上面添加注解 @Aspect 12345//增强的类@Component@Aspect //生成代理对象@Order(3)public class UserProxy &#123; （4）在 spring 配置文件中开启生成代理对象 12&lt;!-- 开启Aspect生成代理对象--&gt;&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt; 4、配置不同类型的通知（1）在增强类的里面，在作为通知方法上面添加通知类型注解，使用切入点表达式配置 123456789101112131415161718192021222324252627282930313233343536373839404142//增强的类@Component@Aspect //生成代理对象public class UserProxy &#123; //前置通知 //@Before 注解表示作为前置通知 @Before(value = &quot;execution(* com.atguigu.spring5.aopanno.User.add(..))&quot;) public void before() &#123; System.out.println(&quot;before.........&quot;); &#125; //后置通知（返回通知） @AfterReturning(value = &quot;execution(* com.atguigu.spring5.aopanno.User.add(..))&quot;) public void afterReturning() &#123; System.out.println(&quot;afterReturning.........&quot;); &#125; //最终通知 @After(value = &quot;execution(* com.atguigu.spring5.aopanno.User.add(..))&quot;) public void after() &#123; System.out.println(&quot;after.........&quot;); &#125; //异常通知 @AfterThrowing(value = &quot;execution(* com.atguigu.spring5.aopanno.User.add(..))&quot;) public void afterThrowing() &#123; System.out.println(&quot;afterThrowing.........&quot;); &#125; //环绕通知 @Around(value = &quot;execution(* com.atguigu.spring5.aopanno.User.add(..))&quot;) public void around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable &#123; System.out.println(&quot;环绕之前.........&quot;); //被增强的方法执行 proceedingJoinPoint.proceed(); System.out.println(&quot;环绕之后.........&quot;); &#125;&#125; 5、相同的切入点抽取123456789101112//相同切入点抽取@Pointcut(value = &quot;execution(* com.atguigu.spring5.aopanno.User.add(..))&quot;)public void pointdemo() &#123;&#125;//前置通知//@Before注解表示作为前置通知@Before(value = &quot;pointdemo()&quot;)public void before() &#123; System.out.println(&quot;before.........&quot;);&#125; 6、有多个增强类多同一个方法进行增强，设置增强类优先级（1）在增强类上面添加注解 @Order(数字类型值)，数字类型值越小优先级越高 1234@Component@Aspect@Order(1)public class PersonProxy 7、完全使用注解开发（1）创建配置类，不需要创建 xml 配置文件 12345@Configuration@ComponentScan(basePackages = &#123;&quot;com.atguigu&quot;&#125;)@EnableAspectJAutoProxy(proxyTargetClass = true)public class ConfigAop &#123;&#125; Ⅶ.AOP 操作（AspectJ 配置文件）1、创建两个类，增强类和被增强类，创建方法2、在 spring 配置文件中创建两个类对象123&lt;!--创建对象--&gt;&lt;bean id=&quot;book&quot; class=&quot;com.atguigu.spring5.aopxml.Book&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;bookProxy&quot; class=&quot;com.atguigu.spring5.aopxml.BookProxy&quot;&gt;&lt;/bean&gt; 3、在 spring 配置文件中配置切入点12345678910&lt;!--配置aop增强--&gt;&lt;aop:config&gt; &lt;!--切入点--&gt; &lt;aop:pointcut id=&quot;p&quot; expression=&quot;execution(* com.atguigu.spring5.aopxml.Book.buy(..))&quot;/&gt; &lt;!--配置切面（切面：将通知应用到切入点的过程）--&gt; &lt;aop:aspect ref=&quot;bookProxy&quot;&gt; &lt;!--增强作用在具体的方法上--&gt; &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;p&quot;/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt;","categories":[{"name":"Spring","slug":"Spring","permalink":"http://example.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://example.com/tags/Spring/"}]},{"title":"Spring5框架学习系列（三）","slug":"Spring5框架学习(三)","date":"2021-09-04T14:32:51.519Z","updated":"2021-10-26T09:21:49.493Z","comments":true,"path":"2021/09/04/Spring5框架学习(三)/","link":"","permalink":"http://example.com/2021/09/04/Spring5%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0(%E4%B8%89)/","excerpt":"事务Ⅰ.事务操作(事务的概念)1、什么是事务（1）事务是数据库操作最基本单元，逻辑上的一组操作，要么都成功，如果有一个失败所有操作都失败。 （2）典型场景：银行转账。","text":"事务Ⅰ.事务操作(事务的概念)1、什么是事务（1）事务是数据库操作最基本单元，逻辑上的一组操作，要么都成功，如果有一个失败所有操作都失败。 （2）典型场景：银行转账。 lucy 转账 100 元 给 mary lucy 少 100，mary 多 100 2、事务四个特性（ACID）（1）原子性：整体 【原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚】 （2）一致性：数据 【一个事务执行之前和执行之后都必须处于一致性状态】 拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。 （3）隔离性: 隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。 并发 【对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。】 （4）持久性: 结果 【持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作】 Ⅱ.事务操作（搭建事务操作环境） WEB层（视图层）、Service（业务逻辑层）、Dao（数据访问层）是Javaee操作中的三层结构。 1、创建数据库表，添加记录 2、创建 service，搭建 dao，完成对象创建和注入关系（1）service 注入 dao，在 dao 注入 JdbcTemplate，在 JdbcTemplate 注入 DataSource 123456789101112@Servicepublic class UserService &#123; //注入 dao @Autowired private UserDao userDao;&#125;@Repositorypublic class UserDaoImpl implements UserDao &#123; @Autowired private JdbcTemplate jdbcTemplate;&#125; 3、在 dao 创建两个方法：多钱和少钱的方法，在 service 创建方法（转账的方法）1234567891011121314151617181920212223242526272829303132@Repositorypublic class UserDaoImpl implements UserDao &#123; @Autowired private JdbcTemplate jdbcTemplate; //lucy 转账 100 给 mary //少钱 @Override public void reduceMoney() &#123; String sql = &quot;update t_account set money=money-? where username=?&quot;; jdbcTemplate.update(sql,100,&quot;lucy&quot;); &#125; //多钱 @Override public void addMoney() &#123; String sql = &quot;update t_account set money=money+? where username=?&quot;; jdbcTemplate.update(sql,100,&quot;mary&quot;); &#125;&#125;@Servicepublic class UserService &#123; //注入 dao @Autowired private UserDao userDao; //转账的方法 public void accountMoney() &#123; //lucy 少 100 userDao.reduceMoney(); //mary 多 100 userDao.addMoney(); &#125;&#125; 4、上面代码，如果正常执行没有问题的，但是如果代码执行过程中出现异常就会有问题12345678910111213//转账的方法 public void accountMoney() &#123; //lucy少100 userDao.reduceMoney(); //模拟异常 int i = 10/0; //mary多100 userDao.addMoney(); &#125;&#125; 在上面的例子中，如果在少钱方法执行以后发生了异常，就会导致少钱方法得到了执行而多钱方法没有得到执行的现象出现，即总的钱少了 100，从而不满足事务的一致性原则。 5. 如何解决上面的问题？使用事务来解决，也就是一个失败的话，所有的都失败。 事务操作过程123456789101112131415161718192021//转账的方法 public void accountMoney() &#123;// try &#123; //第一步 开启事务 //第二步 进行业务操作 //lucy少100 userDao.reduceMoney(); //模拟异常 int i = 10/0; //mary多100 userDao.addMoney(); //第三步 没有发生异常，提交事务// &#125;catch(Exception e) &#123; //第四步 出现异常，事务回滚（回滚就是回到操作前的状态）// &#125; &#125;&#125; Ⅲ.事务操作（Spring 事务管理介绍）1、事务添加到 JavaEE 三层结构里面 Service 层（业务逻辑层）理论上加到哪一层都可以，但是建议加到Service层中去，因为Service层会调用Dao层里面的多个方法。 2、在 Spring 进行事务管理操作有两种方式：编程式事务管理和声明式事务管理（使用） 3、声明式事务管理（1）基于注解方式（使用） （2）基于 xml 配置文件方式 4、在 Spring 进行声明式事务管理，底层使用 AOP 原理即在不改变源代码的情况下可以增强类中的方法。 5、Spring 事务管理 API提供一个接口，代表事务管理器（Spring中做事务管理都是用接口做到的），这个接口针对不同的框架提供不同的实现类。 Ⅳ.事务操作（注解声明式事务管理）1、在 spring 配置文件配置事务管理器123456&lt;!--创建事务管理器,就是创建实现类的对象--&gt;&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;!--注入数据源--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 2、在 spring 配置文件，开启事务注解（1）在 spring 配置文件引入名称空间 tx 123456789101112&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; （2）开启事务注解 12&lt;!--开启事务注解--&gt;&lt;tx:annotation-driven transactionManager=&quot;transactionManager&quot;&gt;&lt;/tx:annotation-driven&gt; 3、在 service 类上面（或者 service 类里面方法上面）添加事务注解（1）@Transactional，这个注解添加到类上面，也可以添加方法上面 （2）如果把这个注解添加类上面，这个类里面所有的方法都添加事务 （3）如果把这个注解添加方法上面，那么只是为这个方法添加事务 123@Service@Transactionalpublic class UserService &#123; Ⅴ.事务操作（声明式事务管理参数配置）1、在 service 类上面添加注解@Transactional，在这个注解里面可以配置事务相关参数 2、propagation：事务传播行为（1）多事务方法直接进行调用，这个过程中事务 是如何进行管理的 事务的传播行为可以由传播属性决定。Spring指定了7种类传播行为。 123@Service@Transactional(propagation = Propagation.REQUIRED)public class UserService &#123; 3、isolation：事务隔离级别隔离级别是为了解决事务中的隔离性，事务的隔离性指的是在并发操作中产生的一些问题。 事务有特性称为隔离性，多事务操作之间不会产生影响。但是不考虑隔离性会产生很多问题 有三个读问题：脏读、不可重复读、虚（幻）读 脏读：一个未提交事务读取到另一个未提交事务的数据 不可重复读：一个未提交事务读取到另一提交事务修改数据 （5）虚读：一个未提交事务读取到另一提交事务添加数据 （6）解决：通过设置事务隔离级别，解决读问题 4、timeout：超时时间（1）事务需要在一定时间内进行提交，如果不提交进行回滚 （2）默认值是 -1 ，设置时间以秒单位进行计算 5、readOnly：是否只读（1）读：查询操作，写：添加修改删除操作 （2）readOnly 默认值 false，表示可以查询，可以添加修改删除操作 （3）设置 readOnly 值是 true，设置成 true 之后，只能查询 6、rollbackFor：回滚设置出现哪些异常进行事务回滚 7、noRollbackFor：不回滚设置出现哪些异常不进行事务回滚 123@Service@Transactional(readOnly = false,timeout = -1,propagation = Propagation.REQUIRED,isolation = Isolation.REPEATABLE_READ)public class UserService &#123; Ⅵ.事务操作（XML 声明式事务管理）1、在 spring 配置文件中进行配置第一步 配置事务管理器 第二步 配置通知(增强的部分就叫做通知，这里要增强的部分就是事务) 第三步 配置切入点（即将事务加到哪个类的哪个方法上）和切面（就是把事务加到方法的过程） 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!-- 组件扫描 --&gt; &lt;context:component-scan base-package=&quot;com.atguigu&quot;&gt;&lt;/context:component-scan&gt; &lt;!-- 数据库连接池 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; destroy-method=&quot;close&quot;&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///user_db&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot; /&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt; &lt;/bean&gt; &lt;!-- JdbcTemplate对象 --&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;!--注入dataSource--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--1 创建事务管理器--&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;!--注入数据源--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--2 配置通知--&gt; &lt;tx:advice id=&quot;txadvice&quot;&gt; &lt;!--配置事务参数--&gt; &lt;tx:attributes&gt; &lt;!--指定哪种规则的方法上面添加事务--&gt; &lt;tx:method name=&quot;accountMoney&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;!--&lt;tx:method name=&quot;account*&quot;/&gt;--&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!--3 配置切入点和切面--&gt; &lt;aop:config&gt; &lt;!--配置切入点--&gt; &lt;aop:pointcut id=&quot;pt&quot; expression=&quot;execution(* com.atguigu.spring5.service.UserService.*(..))&quot;/&gt; &lt;!--配置切面--&gt; &lt;aop:advisor advice-ref=&quot;txadvice&quot; pointcut-ref=&quot;pt&quot;/&gt; &lt;/aop:config&gt;&lt;/beans&gt; Ⅶ.事务操作（完全注解声明式事务管理）1、创建配置类，使用配置类替代 xml 配置文件12345678910111213141516171819202122232425262728293031323334@Configuration //配置类@ComponentScan(basePackages = &quot;com.atguigu&quot;) //组件扫描@EnableTransactionManagement //开启事务public class TxConfig &#123; //创建数据库连接池 @Bean public DruidDataSource getDruidDataSource() &#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;); dataSource.setUrl(&quot;jdbc:mysql:///user_db&quot;); dataSource.setUsername(&quot;root&quot;); dataSource.setPassword(&quot;root&quot;); return dataSource; &#125; //创建JdbcTemplate对象 @Bean public JdbcTemplate getJdbcTemplate(DataSource dataSource) &#123; //到ioc容器中根据类型找到dataSource JdbcTemplate jdbcTemplate = new JdbcTemplate(); //注入dataSource jdbcTemplate.setDataSource(dataSource); return jdbcTemplate; &#125; //创建事务管理器 @Bean public DataSourceTransactionManager getDataSourceTransactionManager(DataSource dataSource) &#123; DataSourceTransactionManager transactionManager = new DataSourceTransactionManager(); transactionManager.setDataSource(dataSource); return transactionManager; &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"http://example.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://example.com/tags/Spring/"}]},{"title":"Spring5框架学习系列（一）","slug":"spring5框架学习(一)","date":"2021-09-04T14:32:51.517Z","updated":"2021-10-26T09:21:58.693Z","comments":true,"path":"2021/09/04/spring5框架学习(一)/","link":"","permalink":"http://example.com/2021/09/04/spring5%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0(%E4%B8%80)/","excerpt":"spring5框架概述1.Spring 是轻量级的开源的 JavaEE 框架。 2.Spring 可以解决企业应用开发的复杂性。 3.Spring 有两个核心部分：IOC 和 Aop IOC：控制反转，把创建对象过程交给 Spring 进行管理 Aop：面向切面，不修改源代码进行功能增强","text":"spring5框架概述1.Spring 是轻量级的开源的 JavaEE 框架。 2.Spring 可以解决企业应用开发的复杂性。 3.Spring 有两个核心部分：IOC 和 Aop IOC：控制反转，把创建对象过程交给 Spring 进行管理 Aop：面向切面，不修改源代码进行功能增强 4.Spring 特点 * 方便解耦，简化开发 * Aop 编程支持 * 方便程序测试 * 方便和其他框架进行整合 * 方便进行事务操作 * 降低 API 开发难度 spring入门1.下载Spring5下载地址：https://repo.spring.io/release/org/springframework/spring/ 2.创建一个普通的Java项目 3.导入Spring5相关的jar包 4.用Spring的方式来创建对象首先创建一个普通类，然后在这个类里面创建一个普通的方法。 12345public class User &#123; public void add() &#123; System.out.println(&quot;user的add方法........&quot;); &#125;&#125; 5.创建 Spring 配置文件，在配置文件配置创建的对象Spring里创建对象有多种方式，可以使用配置文件，还可以使用注解方式，这里先简单的使用配置文件的方式来创建对象。 1234&lt;!--配置User对象创建--&gt; &lt;bean id=&quot;user&quot; class=&quot;com.atguigu.Spring5.User&quot;&gt;&lt;/bean&gt; //注意这里的id是自己起的名字，对应后面的getBean方法中的var1 //getBean(String var1, Class&lt;T&gt; var2) throws BeansException; 6.进行测试代码编写本代码只完成测试功能，在后续的工作中不会用到。建立一个测试类专门用来做测试。 12345678910111213141516171819public class testSpring5 &#123; @Test public void testAdd() &#123; //具体的测试代码，代码只用在测试中 //1.加载Spring的配置文件 //注意：由于类名有ClassPath即类路径，也就是src下所以可以直接写配置文件的名字， // 如果不在src下，则需要写下相对路径或者绝对路径（类名是FileSystemXmlApplication） BeanFactory context = new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;); //2.获取创建的对象 User user = context.getBean(&quot;user&quot;, User.class); System.out.println(user); user.add(); &#125;&#125;输出结果为： com.atguigu.Spring5.User@7c729a55 user的add方法........ 程序主要是通过Spring容器来访问容器中的Bean，==ApplicationContext是Spring容器最常用的接口，该接口有如下两个实现类==： ClassPathXmlApplicationContext: 从类加载路径下搜索配置文件，并根据配置文件来创建Spring容器。 FileSystemXmlApplicationContext: 从文件系统的相对路径或绝对路径下去搜索配置文件，并根据配置文件来创建Spring容器。 IOC容器Ⅰ.IOC底层的原理什么是IOC 控制反转，把对象创建和对象之间的调用过程，交给Spring进行管理。 使用Ioc的目的：为了降低耦合度 上文中的入门案例就是IOC实现 先来看spring官网的关于IOC容器的解释： The org.springframework.context.ApplicationContext interface represents the Spring IoC container and is responsible for instantiating, configuring, and assembling the beans. 大意就是： Spring IOC容器就是一个 org.springframework.context.ApplicationContext 的实例化对象。 容器负责实例化，配置以及装配一个bean。 从代码层面上看：spring容器就是一个实现了ApplicationContext接口的对象。 从功能层面来看：Spring 容器是 Spring 框架的核心，是用来管理对象的。容器将创建对象，把它们连接在一起，配置它们，并管理他们的整个生命周期从创建到销毁。 IOC底层原理 xml注解、工厂模式、反射（得到class文件，操作类中的内容） 1234567891011121314151617181920//工厂模式：//使用工厂模式的目的是将耦合度降低到最低限度,例如在下面的例子中，当有很多service调用dao层时，dao层包发生改变所有的service都需要改，而有了工厂类以后只需要改变工厂类就可以，从而降低了代码的耦合度。class UserService&#123; excute()&#123; UserDao dao = UserFactory.getDao(); dao.add(); &#125;&#125;class UserDao&#123; add()&#123; .........; &#125;&#125;class UserFactory&#123; public static UserDao()&#123; return new UserDao(); &#125;&#125; ==IOC过程分析：== 123456789101112//第一步：xml配置文件，配置创建的对象&lt;bean id=&quot;user&quot; class=&quot;com.atguigu.Spring5.User&quot;&gt;&lt;/bean&gt; //第二步：有service类和dao类，创建工厂类 class UserFactory &#123; public static userDao getDao()&#123; String classValue = class属性值;//xml解析 //通过反射创建对象 Class clazz = Class.forName(classValue); return (UserDao)calzz.newInstance(); &#125; &#125; IOC接口 IOC思想基于IOC容器完成，IOC容器底层就是对象工厂 Spring提供了IOC容器实现的两种方式：（即两个接口） （1）BeanFactory：IOC容器基本实现方式，时Spring内部的使用接口，不提供开发人员进行使用。 加载配置文件的时候不会创建对象，获取对象的时候才去创建对象 （2）ApplicationContext：BeanFactory接口的子接口，提供更多更强大的功能，一般由开发人员进行使用。 加载配置文件的时候就会把在配置文件的对象进行创建。 ApplicationContext接口有实现类 ClassPathXmlApplicationContext: 从类加载路径下搜索配置文件，并根据配置文件来创建Spring容器。 FileSystemXmlApplicationContext: 从文件系统的相对路径或绝对路径下去搜索配置文件，并根据配置文件来创建Spring容器。 Ⅱ.IOC操作Bean管理（概念）1.什么是Bean管理（0）Bean管理指的是两个操作（1）（2）（1）Spring创建对象（2）Spring注入属性2.Bean管理操作有两种方式（1）基于xml配置文件方式实现（2）基于注解方式实现Ⅲ.IOC操作Bean管理（基于xml方式）1.基于xml方式创建对象1&lt;bean id=&quot;user&quot; class=&quot;com.atguigu.Spring5.User&quot;&gt;&lt;/bean&gt; （1）在 spring 配置文件中，使用 bean 标签，标签里面添加对应属性，就可以实现对象的创建。 （2）在 bean 标签有很多属性，介绍常用的属性。 id 属性：唯一标识 user class 属性：类全路径（包类路径）com.atguigu.Spring5.User name属性：功能与id属性类似，区别在于name属性总可以加入特殊符号，但id属性不可以。用的很少 （3）创建对象时候，默认也是执行无参数构造方法完成对象的创建。 2.基于xml方式注入属性DI：依赖注入，就是注入属性。是IOC中的一种具体实现。注入属性需要在创建对象的基础之上完成。 ==第一种注入方式：使用set方法进行注入。（bean标签+property标签加属性的值就可以完成注入）== （1）创建类，定义属性和对应的set方法。 123456789101112131415/** * 演示使用set方法进行注入属性 */public class Book &#123; //创建属性 private String bname; private String bauthor; //创建属性对应的set方法 public void setBname(String bname) &#123; this.bname = bname; &#125; public void setBauthor(String bauthor) &#123; this.bauthor = bauthor; &#125;&#125; （2）在Spring配置文件配置对象创建，配置属性注入。 12345678&lt;!--2 set方法注入属性--&gt; &lt;bean id=&quot;book&quot; class=&quot;com.atguigu.Spring5.Book&quot;&gt; &lt;!--使用property完成属性注入 name：类里面属性名称 value：向属性注入的值--&gt; &lt;property name=&quot;bname&quot; value=&quot;易筋经&quot;&gt;&lt;/property&gt; &lt;property name=&quot;bauthor&quot; value=&quot;达摩老祖&quot;&gt;&lt;/property&gt; &lt;/bean&gt; ==第二种注入方式：使用有参数构造进行注入== （1）创建类，定义属性，创建属性对应有参数构造方法。 1234567891011121314151617/** * 使用有参数构造注入 */public class Orders &#123; //属性 private String oname; private String address; //有参数构造 public Orders(String oname,String address) &#123; this.oname = oname; this.address = address; &#125; public void ordersTest() &#123; System.out.println(oname+&quot;::&quot;+address); &#125;&#125; （2）在 spring 配置文件中进行配置 123456&lt;!--3 有参数构造注入属性--&gt; &lt;bean id=&quot;orders&quot; class=&quot;com.atguigu.Spring5.Orders&quot;&gt; &lt;constructor-arg name=&quot;oname&quot; value=&quot;电脑&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=&quot;address&quot; value=&quot;China&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; 注：&lt;constructor-arg&gt;&lt;/constructor-arg&gt;标签的作用：如果不加该标签则默认使用的是无参构造创建对象，而不是有参构造创建对象。 3.p名称空间注入（本质还是set方法注入属性）（1）使用p名称空间注入，可以简化基于xml配置方式。 第一步：在配置文件中添加p名称空间 123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; //在配置文件里加入p名称空间 xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; 第二步 进行属性注入，在 bean 标签里面进行操作。 1234&lt;!--2 set方法注入属性--&gt; &lt;bean id=&quot;book&quot; class=&quot;com.atguigu.Spring5.Book&quot; p:bname=&quot;九阳神功&quot; p:bauthor=&quot;无名氏&quot;&gt; &lt;/bean&gt; 底层还是使用set方法注入属性，但是对set方法注入进行了一定的简化。 Ⅳ.IOC操作Bean管理（xml注入其他类型属性）1.字面量字面量就是为属性设置一个固定值，例如： 1private String bname = &quot;&quot;;也可以使用&lt;property&gt;&lt;/property&gt;标签来设置字面量。 （1）设置属性值时设置为空值null。使用null标签（只是说明可以设置为null值，实际上引用类型默认为null） 1234&lt;!--设置null值--&gt; &lt;property name=&quot;address&quot; &gt; &lt;null&gt;&lt;/null&gt; &lt;/property&gt; 输出结果为： 12com.atguigu.Spring5.Book@4802796d易筋经::达摩老祖::null 可见空值属性已经设置成功了。 （2）属性值包含特殊符号。 1234567&lt;!--属性值包含特殊符号 1 把&lt;&gt;进行转义 &amp;lt; &amp;gt; 2 把带特殊符号内容写到CDATA --&gt; &lt;property name=&quot;address&quot;&gt; &lt;value&gt;&lt;![CDATA[&lt;&lt;南京&gt;&gt;]]&gt;&lt;/value&gt; &lt;/property&gt; 输出结果为： 12com.atguigu.Spring5.Book@65fb9ffc易筋经::达摩老祖::&lt;&lt;南京&gt;&gt; 2.注入属性-外部 bean（1）创建两个类 service 类和 dao 类 。 （2）在 service 调用 dao 里面的方法。 12345678910111213141516171819public class UserService &#123; //在Spring中做到 //创建UserDao类属性,生成set方法 private UserDao userDao; public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125; public void add()&#123; System.out.println(&quot;Service add...........&quot;); //原始方式 //创建userDao对象 UserDao userDao = new UserDaoImpl(); userDao.update(); &#125;&#125; （3）在 spring 配置文件中进行配置。 12345678910&lt;!--1 service和dao对象创建--&gt; &lt;bean id=&quot;userService&quot; class=&quot;com.atguigu.Spring5.service.UserService&quot;&gt; &lt;!--注入userDao对象 name属性：类里面属性名称 ref属性：创建userDao对象bean标签id值 --&gt; &lt;property name=&quot;userDao&quot; ref=&quot;userDaoImpl&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--注意接口不能new对象，应该找他的实现类--&gt; &lt;bean id=&quot;userDaoImpl&quot; class=&quot;com.atguigu.Spring5.dao.UserDaoImpl&quot;&gt;&lt;/bean&gt; 3.注入属性-内部 bean（1）一对多关系：部门和员工 一个部门里有多个员工，一个员工属于一个部门。部门是一，员工是多。 （2）实体类之间便是一对多关系，员工表示所属部门，使用对象类型属性进行表示。 12345678910111213141516171819202122232425262728//部门类public class Dept &#123; private String dname; public void setDname(String dname) &#123; this.dname = dname; &#125;&#125;//员工类public class Emp &#123; private String ename; private String gender; //表示员工属于某一个部门，适用对象形式表示 private Dept dept; public void setDept(Dept dept) &#123; this.dept = dept; &#125; public void setEname(String ename) &#123; this.ename = ename; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125;&#125; （3）在 spring 配置文件中进行配置. 123456789101112&lt;!--内部bean，即在一个bean里可以再嵌套另一个对象--&gt; &lt;bean id=&quot;emp&quot; class=&quot;com.atguigu.Spring5.bean.Emp&quot;&gt; &lt;!--设置两个普通属性--&gt; &lt;property name=&quot;ename&quot; value=&quot;lucy&quot;&gt;&lt;/property&gt; &lt;property name=&quot;gender&quot; value=&quot;女&quot;&gt;&lt;/property&gt; &lt;!--设置对象类型属性--&gt; &lt;property name=&quot;dept&quot;&gt; &lt;bean id=&quot;dept&quot; class=&quot;com.atguigu.Spring5.bean.Dept&quot;&gt; &lt;property name=&quot;dname&quot; value=&quot;安保部&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; 4.注入属性-级联赋值（1）第一种写法 1234567891011&lt;!--级联赋值--&gt; &lt;bean id=&quot;emp&quot; class=&quot;com.atguigu.Spring5.bean.Emp&quot;&gt; &lt;!--设置两个普通属性--&gt; &lt;property name=&quot;ename&quot; value=&quot;lucy&quot;&gt;&lt;/property&gt; &lt;property name=&quot;gender&quot; value=&quot;女&quot;&gt;&lt;/property&gt; &lt;!--级联赋值--&gt; &lt;property name=&quot;dept&quot; ref=&quot;dept&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;dept&quot; class=&quot;com.atguigu.Spring5.bean.Dept&quot;&gt; &lt;property name=&quot;dname&quot; value=&quot;财务部&quot;&gt;&lt;/property&gt; &lt;/bean&gt; （2）第二种写法 12345678910111213&lt;!--级联赋值--&gt; &lt;bean id=&quot;emp&quot; class=&quot;com.atguigu.Spring5.bean.Emp&quot;&gt; &lt;!--设置两个普通属性--&gt; &lt;property name=&quot;ename&quot; value=&quot;lucy&quot;&gt;&lt;/property&gt; &lt;property name=&quot;gender&quot; value=&quot;女&quot;&gt;&lt;/property&gt; &lt;!--级联赋值--&gt; &lt;property name=&quot;dept&quot; ref=&quot;dept&quot;&gt;&lt;/property&gt; //注意要使用dept.dname需要在Emp类中写get方法，否则会报错 &lt;property name=&quot;dept.dname&quot; value=&quot;技术部&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;dept&quot; class=&quot;com.atguigu.Spring5.bean.Dept&quot;&gt; &lt;property name=&quot;dname&quot; value=&quot;财务部&quot;&gt;&lt;/property&gt; &lt;/bean&gt; Ⅴ.IOC 操作 Bean 管理（xml 注入集合属性）1、注入数组类型属性2、注入 List 集合类型属性3、注入 Map 集合类型属性（1）创建类，定义数组、list、map、set 类型属性，生成对应 set 方法 12345678910111213141516171819202122232425262728293031323334353637public class Stu &#123; //1 数组类型属性 private String[] courses; //2 list集合类型属性 private List&lt;String&gt; list; //3 map集合类型属性 private Map&lt;String,String&gt; maps; //4 set集合类型属性 private Set&lt;String&gt; sets; //学生所学多门课程 private List&lt;Course&gt; courseList; public void setCourseList(List&lt;Course&gt; courseList) &#123; this.courseList = courseList; &#125; public void setSets(Set&lt;String&gt; sets) &#123; this.sets = sets; &#125; public void setCourses(String[] courses) &#123; this.courses = courses; &#125; public void setList(List&lt;String&gt; list) &#123; this.list = list; &#125; public void setMaps(Map&lt;String, String&gt; maps) &#123; this.maps = maps; &#125; public void test() &#123; System.out.println(Arrays.toString(courses)); System.out.println(list); System.out.println(maps); System.out.println(sets); System.out.println(courseList); &#125;&#125; （2）在 spring 配置文件进行配置。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!--1 集合类型属性注入--&gt; &lt;!--首先用bean标签创建对象--&gt; &lt;bean id=&quot;stu&quot; class=&quot;com.atguigu.Spring5.collectionType.Stu&quot;&gt; &lt;!--数组类型属性注入--&gt; &lt;property name=&quot;courses&quot;&gt; &lt;array&gt; &lt;value&gt;java课程&lt;/value&gt; &lt;value&gt;数据库课程&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;!--list类型属性注入--&gt; &lt;property name=&quot;list&quot;&gt; &lt;list&gt; &lt;value&gt;张三&lt;/value&gt; &lt;value&gt;小三&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!--map类型属性注入--&gt; &lt;property name=&quot;maps&quot;&gt; &lt;map&gt; &lt;entry key=&quot;JAVA&quot; value=&quot;java&quot;&gt;&lt;/entry&gt; &lt;entry key=&quot;PHP&quot; value=&quot;php&quot;&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;!--set类型属性注入--&gt; &lt;property name=&quot;sets&quot;&gt; &lt;set&gt; &lt;value&gt;MySQL&lt;/value&gt; &lt;value&gt;Redis&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;!--注入list集合类型，值是对象--&gt; &lt;property name=&quot;courseList&quot;&gt; &lt;list&gt; &lt;ref bean=&quot;course1&quot;&gt;&lt;/ref&gt; &lt;ref bean=&quot;course2&quot;&gt;&lt;/ref&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!--创建多个course对象--&gt; &lt;bean id=&quot;course1&quot; class=&quot;com.atguigu.Spring5.collectionType.Course&quot;&gt; &lt;property name=&quot;cname&quot; value=&quot;Spring5框架&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;course2&quot; class=&quot;com.atguigu.Spring5.collectionType.Course&quot;&gt; &lt;property name=&quot;cname&quot; value=&quot;MyBatis框架&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 4、在集合里面设置对象类型值1234567&lt;!--创建多个course对象--&gt; &lt;bean id=&quot;course1&quot; class=&quot;com.atguigu.Spring5.collectionType.Course&quot;&gt; &lt;property name=&quot;cname&quot; value=&quot;Spring5框架&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;course2&quot; class=&quot;com.atguigu.Spring5.collectionType.Course&quot;&gt; &lt;property name=&quot;cname&quot; value=&quot;MyBatis框架&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 1234567&lt;!--注入list集合类型，值是对象--&gt; &lt;property name=&quot;courseList&quot;&gt; &lt;list&gt; &lt;ref bean=&quot;course1&quot;&gt;&lt;/ref&gt; &lt;ref bean=&quot;course2&quot;&gt;&lt;/ref&gt; &lt;/list&gt; &lt;/property&gt; 5、把集合注入部分提取出来(1）在 spring 配置文件中引入名称空间 util 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:util=&quot;http://www.springframework.org/schema/util&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd&quot;&gt; （2）使用 util 标签完成 list 集合注入提取 1234567891011&lt;!--1 提取list集合类型属性注入--&gt; &lt;util:list id=&quot;bookList&quot;&gt; &lt;value&gt;易筋经&lt;/value&gt; &lt;value&gt;九阴真经&lt;/value&gt; &lt;value&gt;九阳神功&lt;/value&gt; &lt;/util:list&gt; &lt;!--2 提取list集合类型属性注入使用--&gt; &lt;bean id=&quot;book&quot; class=&quot;com.atguigu.Spring5.collectionType.Book&quot; scope=&quot;prototype&quot;&gt; &lt;property name=&quot;list&quot; ref=&quot;bookList&quot;&gt;&lt;/property&gt; &lt;/bean&gt; Ⅵ.IOC 操作 Bean 管理（FactoryBean）1、Spring 有两种类型 bean，一种普通 bean，另外一种工厂 bean（FactoryBean）2、普通 bean：在配置文件中定义 bean 类型就是返回类型3、工厂 bean：在配置文件定义 bean 类型可以和返回类型不一样 第一步 创建类，让这个类作为工厂 bean，实现接口 FactoryBean 第二步 实现接口里面的方法，在实现的方法中定义返回的 bean 类型 1234567891011121314151617181920public class MyBean implements FactoryBean&lt;Course&gt; &#123; //定义返回bean @Override public Course getObject() throws Exception &#123; Course course = new Course(); course.setCname(&quot;abc&quot;); return course; &#125; @Override public Class&lt;?&gt; getObjectType() &#123; return null; &#125; @Override public boolean isSingleton() &#123; return false; &#125;&#125; 12345678@Test public void test3() &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean3.xml&quot;); //factoryBean体现：定义的是MyBean类型的对象，返回的是Course类型的对象 Course course = context.getBean(&quot;myBean&quot;, Course.class); System.out.println(course); &#125; Ⅶ.IOC 操作 Bean 管理（bean 作用域）==重点==1、在 Spring 里面，设置创建 bean 实例是单实例还是多实例2、在 Spring 里面，默认情况下，bean 是单实例对象现在对其进行验证，创建两个不同的Book对象，输出他们的地址，若地址相同则说明是单实例，若地址不同说明是多实例。 12345678910@Test public void testCollection2() &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean2.xml&quot;); Book book1 = context.getBean(&quot;book&quot;, Book.class); Book book2 = context.getBean(&quot;book&quot;, Book.class); // book.test(); System.out.println(book1); System.out.println(book2); &#125; 输出结果为： 12com.atguigu.Spring5.collectionType.Book@6200f9cbcom.atguigu.Spring5.collectionType.Book@6200f9cb 可见两个对象的地址相同，说明默认bean是单实例对象。 3、如何设置单实例还是多实例（1）在 spring 配置文件 bean 标签里面有属性（scope）用于设置单实例还是多实例 （2）scope 属性值 第一个值 默认值，singleton，表示是单实例对象 第二个值 prototype，表示是多实例对象 1234&lt;!--2 提取list集合类型属性注入使用--&gt; &lt;bean id=&quot;book&quot; class=&quot;com.atguigu.Spring5.collectionType.Book&quot; scope=&quot;prototype&quot;&gt; &lt;property name=&quot;list&quot; ref=&quot;bookList&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 测试结果为： 12com.atguigu.Spring5.collectionType.Book@6200f9cbcom.atguigu.Spring5.collectionType.Book@2002fc1d （3）singleton 和 prototype 区别 第一 singleton 单实例，prototype 多实例 ==第二 当设置 scope 值是 singleton的时候，加载 spring 配置文件时候就会创建单实例对象，即== 12ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean2.xml&quot;); ==而当设置 scope 值是 prototype的时候，不是在加载 spring 配置文件时候创建对象，在调用 getBean 方法时候创建多实例对象。==即 12Book book1 = context.getBean(&quot;book&quot;, Book.class); Book book2 = context.getBean(&quot;book&quot;, Book.class); Ⅷ.IOC 操作 Bean 管理（bean 生命周期）==重点==1、生命周期（1）从对象创建到对象销毁的过程 2、bean 生命周期（1）通过构造器创建 bean 实例（无参数构造） （2）为 bean 的属性设置值和对其他 bean 引用（调用 set 方法） （3）调用 bean 的初始化的方法（需要进行配置初始化的方法） （4）bean 可以使用了（对象获取到了） （5）当容器关闭时候，调用 bean 的销毁的方法（需要进行配置销毁的方法） 3、演示 bean 生命周期1234567891011121314151617181920212223public class Orders &#123; //无参数构造 public Orders() &#123; System.out.println(&quot;第一步 执行无参数构造创建bean实例&quot;); &#125; private String oname; public void setOname(String oname) &#123; this.oname = oname; System.out.println(&quot;第二步 调用set方法设置属性值&quot;); &#125; //创建执行的初始化的方法 public void initMethod() &#123; System.out.println(&quot;第三步 执行初始化的方法&quot;); &#125; //创建执行的销毁的方法 public void destroyMethod() &#123; System.out.println(&quot;第五步 执行销毁的方法&quot;); &#125;&#125; 相关配置文件： 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:util=&quot;http://www.springframework.org/schema/util&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd&quot;&gt; &lt;bean id=&quot;orders&quot; class=&quot;com.atguigu.Spring5.bean.Orders&quot; init-method=&quot;initMethod&quot; destroy-method=&quot;destroyMethod&quot;&gt; &lt;property name=&quot;oname&quot; value=&quot;手机&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/beans&gt; 4、bean 的后置处理器，bean 生命周期有七步12345678910111213（1）通过构造器创建 bean 实例（无参数构造） （2）为 bean 的属性设置值和对其他 bean 引用（调用 set 方法） （3）把 bean 实例传递 bean 后置处理器的方法 postProcessBeforeInitialization （4）调用 bean 的初始化的方法（需要进行配置初始化的方法）（5）把 bean 实例传递 bean 后置处理器的方法 postProcessAfterInitialization （6）bean 可以使用了（对象获取到了） （7）当容器关闭时候，调用 bean 的销毁的方法（需要进行配置销毁的方法） 5、演示添加后置处理器效果（1）创建类，实现接口 BeanPostProcessor，创建后置处理器。 123456789101112131415public class MyBeanPost implements BeanPostProcessor &#123; @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println(&quot;在初始化之前执行的方法&quot;); //bean就是创建出来的实例对象 return bean; &#125; @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println(&quot;在初始化之后执行的方法&quot;); return bean; &#125;&#125;&lt;!--配置后置处理器--&gt; &lt;bean id=&quot;myBeanPost&quot; class=&quot;com.atguigu.Spring5.bean.MyBeanPost&quot;&gt;&lt;/bean&gt; 执行结果： 12345678第一步 执行无参数构造创建bean实例第二步 调用set方法设置属性值在初始化之前执行的方法第三步 执行初始化的方法在初始化之后执行的方法第四步 获取创建bean实例对象com.atguigu.Spring5.bean.Orders@28701274第五步 执行销毁的方法 Ⅸ.IOC 操作 Bean 管理（xml 自动装配）1、什么是自动装配即根据指定装配规则（属性名称或者属性类型），Spring 自动将匹配的属性值进行注入 2、演示自动装配过程（1）根据属性名称自动注入。 123456789&lt;!--实现自动装配 bean标签属性autowire，配置自动装配 autowire属性常用两个值： byName根据属性名称注入 ，注入值bean的id值和类属性名称一样 byType根据属性类型注入 --&gt; &lt;bean id=&quot;emp&quot; class=&quot;com.atguigu.Spring5.autowire.Emp&quot; autowire=&quot;byName&quot;&gt; &lt;!--&lt;property name=&quot;dept&quot; ref=&quot;dept&quot;&gt;&lt;/property&gt;--&gt; &lt;/bean&gt; （2）根据属性类型自动注入. 123456789&lt;!--实现自动装配 bean标签属性autowire，配置自动装配 autowire属性常用两个值： byName根据属性名称注入 ，注入值bean的id值和类属性名称一样 byType根据属性类型注入,需要注意的是当相同类型的bean定义多个会报错，此时只能用 byName --&gt; &lt;bean id=&quot;emp&quot; class=&quot;com.atguigu.Spring5.autowire.Emp&quot; autowire=&quot;byType&quot;&gt; &lt;!--&lt;property name=&quot;dept&quot; ref=&quot;dept&quot;&gt;&lt;/property&gt;--&gt; &lt;/bean&gt; Ⅹ.IOC 操作 Bean 管理(外部属性文件)1、直接配置数据库信息（1）配置德鲁伊druid连接池 （2）引入德鲁伊连接池依赖 jar 包 2、引入外部属性文件配置数据库连接池（1）创建外部属性文件，properties 格式文件，写数据库信息 1234prop.driverClass=com.mysql.jdbc.Driverprop.url=jdbc:mysql://localhost:3306/userDbprop.userName=rootprop.password=root （2）把外部 properties 属性文件引入到 spring 配置文件中 引入 context 名称空间 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:util=&quot;http://www.springframework.org/schema/util&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;&lt;/beans&gt; 需要着重注意的配置： xmlns:context=”http://www.springframework.org/schema/context&quot; http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot; 在 spring 配置文件使用标签引入外部属性文件 1234567891011&lt;!--引入外部属性文件--&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt; &lt;!--配置连接池--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;prop.driverClass&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;prop.url&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;prop.userName&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;prop.password&#125;&quot;&gt;&lt;/property&gt; &lt;/bean&gt; Ⅺ.IOC 操作 Bean 管理(基于注解方式)1、什么是注解 （1）注解是代码特殊标记，格式：@注解名称(属性名称=属性值, 属性名称=属性值..) （2）使用注解，注解可以作用在类上面，方法上面，属性上面 （3）使用注解目的：简化 xml 配置，使用更优雅的方式实现配置。 2、Spring 针对 Bean 管理中创建对象提供注解（1）@Component （2）@Service （3）@Controller （4）@Repository 上面四个注解功能是一样的，都可以用来创建 bean 实例 3、基于注解方式实现对象创建第一步 引入依赖 第二步 开启组件扫描：告诉Spring容器现在在哪个类里面加入注解，然后去扫描这个类。不开启的话Spring不知道要做什么事情，也不知道扫描哪个包中的哪个类。 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--开启组件扫描 1 如果扫描多个包，多个包使用逗号隔开 &lt;context:component-scan base-package=&quot;com.atguigu.Spring5,com.atguigu.Spring5.service&quot;&gt;&lt;/context:component-scan&gt; 2 扫描包上层目录 &lt;context:component-scan base-package=&quot;com.atguigu&quot;&gt;&lt;/context:component-scan&gt; --&gt; &lt;context:component-scan base-package=&quot;com.atguigu.Spring5,com.atguigu.Spring5.service&quot;&gt;&lt;/context:component-scan&gt; &lt;/beans&gt; 第三步 创建类，在类上面添加创建对象注解 1234567891011121314//在注解里面value属性值可以省略不写，//默认值是类名称，首字母小写 UserService -- userService//@Component(value = &quot;userService&quot;) //&lt;bean id=&quot;userService&quot; class=&quot;..&quot;/&gt;@Servicepublic class UserService &#123; @Value(value = &quot;abc&quot;) private String name; public void add() &#123; System.out.println(&quot;service add.......&quot;+name); userDao.add(); &#125;&#125; 4、开启组件扫描细节配置123456789&lt;!--示例1 use-default-filters=&quot;false&quot; 表示现在不使用默认 filter，而使用自己配置的 filter context:include-filter ，设置扫描哪些内容 Controller：表示在com.atguigu包下只扫描带@Controller注解的类--&gt; &lt;context:component-scan base-package=&quot;com.atguigu&quot; use-default-filters=&quot;false&quot;&gt; &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;&lt;/context:component-scan&gt; 12345678&lt;!--示例 2 下面配置扫描包所有内容 context:exclude-filter： 设置哪些内容不进行扫描 --&gt;&lt;context:component-scan base-package=&quot;com.atguigu&quot;&gt;&lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;&lt;/context:component-scan&gt; 5、基于注解方式实现属性注入（1）@Autowired：根据属性类型进行自动装配 第一步 把 service 和 dao 对象创建，在 service 和 dao 类添加创建对象注解 第二步 在 service 注入 dao 对象，在 service 类添加 dao 类型属性，在属性上面使用注解. 123456789101112@Servicepublic class UserService &#123; //定义 dao 类型属性 //不需要添加 set 方法 //添加注入属性注解 @Autowired private UserDao userDao; public void add() &#123; System.out.println(&quot;service add.......&quot;); userDao.add(); &#125;&#125; （2）@Qualifier：根据名称进行注入，这个 @Qualifier 注解要和上面 @Autowired 一起使用 123456//定义 dao 类型属性//不需要添加 set 方法//添加注入属性注解@Autowired //根据类型进行注入@Qualifier(value = &quot;userDaoImpl1&quot;) //根据名称进行注入private UserDao userDao; （3）@Resource：可以根据类型注入，也可以根据名称注入。注意：Resourse注解是javax.annotation.Resource包中的，因此尽量使用前面的方法注入属性。 123@Resource //根据类型进行注入@Resource(name = &quot;userDaoImpl1&quot;) //根据名称进行注入private UserDao userDao; （4）@Value：注入普通类型属性 12345 @Value(value = &quot;abc&quot;) private String name;//输出为：service add.......abcdao add..... 6.完全注解开发（1）创建配置类，替代 xml 配置文件 12345678910package com.atguigu.Spring5.config;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configuration //作为配置类，替代xml配置文件@ComponentScan(basePackages = &#123;&quot;com.atguigu&quot;&#125;)public class SpringConfig &#123;&#125; （2）编写测试类 123456789@Test public void testService2() &#123; //加载配置类 ApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class); UserService userService = context.getBean(&quot;userService&quot;, UserService.class); System.out.println(userService); userService.add(); &#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"http://example.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://example.com/tags/Spring/"}]},{"title":"Servlet，我还是爱你的","slug":"Servlet，我还是爱你的","date":"2021-09-04T14:32:51.516Z","updated":"2021-10-26T09:20:37.611Z","comments":true,"path":"2021/09/04/Servlet，我还是爱你的/","link":"","permalink":"http://example.com/2021/09/04/Servlet%EF%BC%8C%E6%88%91%E8%BF%98%E6%98%AF%E7%88%B1%E4%BD%A0%E7%9A%84/","excerpt":"Ⅰ. 为什么需要Servlet1.1 Tomcat","text":"Ⅰ. 为什么需要Servlet1.1 Tomcat Tomcat是一个Web服务器（同时也是Servlet容器），通过它我们可以很方便地接收和返回到请求（如果不用Tomcat，那我们需要自己写Socket来接收和返回请求）。 Tomcat的目录层次结构 1.2 什么是Servlet？Servlet其实就是一个遵循Servlet开发的java类。Serlvet是由服务器调用的，运行在服务器端。我们编写java程序想要在网上实现聊天、发帖、这样的一些交互功能，普通的java技术是非常难完成的。于是sun公司就提供了Serlvet这种技术供我们使用。 1.3 HTTP协议 超文本（HTML，css，JavaScript和图片等）传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。它是TCP/IP协议的一个应用层协议 直白的说，HTTP协议就是浏览器和服务器之间通讯的一种协议，就比如我们在点击网站链接打开一个网站的时候，浏览器会给服务器发送一段文本，告诉服务器自己打开的是哪一个网页，服务器收到请求以后，会返回给浏览器一段文本，浏览器解析后将其显示给用户。 1.4 HTTP 请求浏览器向服务器请求某个web资源时，称之为浏览器向服务器发送了一个http请求。 一个完整http请求应该包含三个部分： 请求行【描述客户端的请求方式、请求的资源名称，以及使用的HTTP协议版本号（1.0和1.1）】 多个消息头【描述客户端请求哪台主机，以及客户端的一些环境信息等】 一个空行 请求行请求行：GET /java.html HTTP/1.1 请求行中的GET称之为请求方式，请求方式有：POST,GET,HEAD,OPTIONS,DELETE,TRACE,PUT。 常用的有：POST,GET 一般来说，当我们点击超链接，通过地址栏访问都是get请求方式。通过表单提交的数据一般是post方式。 可以简单理解GET方式用来查询数据,POST方式用来提交数据，get的提交速度比post快 GET方式：在URL地址后附带的参数是有限制的，其数据容量通常不能超过1K。 POST方式：可以在请求的实体内容中向服务器发送数据，传送的数据量无限制。 请求头 Accept: text/html,image/* 【浏览器告诉服务器，它支持的数据类型】 Accept-Charset: ISO-8859-1 【浏览器告诉服务器，它支持哪种字符集】 Accept-Encoding: gzip,compress 【浏览器告诉服务器，它支持的压缩格式】 Accept-Language: en-us,zh-cn 【浏览器告诉服务器，它的语言环境】 Host: www.it315.org:80【浏览器告诉服务器，它的想访问哪台主机】 If-Modified-Since: Tue, 11 Jul 2000 18:23:51 GMT【浏览器告诉服务器，缓存数据的时间】 Referer: http://www.it315.org/index.jsp【浏览器告诉服务器，客户机是从那个页面来的---**反盗链**】 8.User-Agent: Mozilla/4.0 (compatible; MSIE 5.5; Windows NT 5.0)【浏览器告诉服务器，浏览器的内核是什么】 Cookie【浏览器告诉服务器，带来的Cookie是什么】 Connection: close/Keep-Alive 【浏览器告诉服务器，请求完后是断开链接还是保持链接】 Date: Tue, 11 Jul 2000 18:23:51 GMT【浏览器告诉服务器，请求的时间】 1.5 HTTP响应一个HTTP响应代表着服务器向浏览器回送数据 一个完整的HTTP响应应该包含四个部分: 一个状态行【用于描述服务器对请求的处理结果。】 多个消息头【用于描述服务器的基本信息，以及数据的描述，服务器通过这些数据的描述信息，可以通知客户端如何处理等一会儿它回送的数据】 一个空行 实体内容【服务器向客户端回送的数据】 状态行格式： HTTP版本号 状态码 原因叙述 状态行：HTTP/1.1 200 OK 状态码用于表示服务器对请求的处理结果，它是一个三位的十进制数。响应状态码分为5类 Ⅱ. Servlet的作用Servlet带给我们最大的作用就是能够处理浏览器带来HTTP请求，并返回一个响应给浏览器，从而实现浏览器和服务器的交互。 简单来说，Servlet 就是运行在服务器上的一个 java 小程序，它可以接收客户端发送过来的请求，并响应数据给客户端。 实现Servlet1、编写一个类去实现 Servlet 接口 2、实现 service 方法，处理请求，并响应数据 3、到 web.xml 中去配置 servlet 程序的访问地址。 首先实现 Servlet 接口，我们发现有5个方法需要重写， init【初始化】， destroy【销毁】, service【服务】, ServletConfig【Servlet配置】, getServletInfo【Serlvet信息】 发现service()方法是最有可能是写逻辑代码的地方。 12345678910111213public class HelloServlet implements Servlet &#123;/*** service 方法是专门用来处理请求和响应的* @param servletRequest* @param servletResponse* @throws ServletException* @throws IOException*/@Overridepublic void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123; System.out.println(&quot;Hello Servlet 被访问了&quot;); &#125;&#125; web.xml 中的配置： 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;!-- servlet标签给Tomcat配置Servlet程序 --&gt; &lt;servlet&gt; &lt;!--servlet-name标签 Servlet程序起一个别名（一般是类名） --&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;!--servlet-class是Servlet程序的全类名--&gt; &lt;servlet-class&gt;com.atguigu.servlet.HelloServlet&lt;/servlet-class&gt; &lt;!--init-param是初始化参数--&gt; &lt;init-param&gt; &lt;!--是参数名--&gt; &lt;param-name&gt;username&lt;/param-name&gt; &lt;!--是参数值--&gt; &lt;param-value&gt;root&lt;/param-value&gt; &lt;/init-param&gt; &lt;!--init-param是初始化参数--&gt; &lt;init-param&gt; &lt;!--是参数名--&gt; &lt;param-name&gt;url&lt;/param-name&gt; &lt;!--是参数值--&gt; &lt;param-value&gt;jdbc:mysql://localhost:3306/test&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;!--servlet-mapping标签给servlet程序配置访问地址--&gt; &lt;servlet-mapping&gt; &lt;!--servlet-name标签的作用是告诉服务器，我当前配置的地址给哪个Servlet程序使用--&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;!-- url-pattern标签配置访问地址 &lt;br/&gt; / 斜杠在服务器解析的时候，表示地址为：http://ip:port/工程路径 &lt;br/&gt; /hello 表示地址为：http://ip:port/工程路径/hello &lt;br/&gt; --&gt; &lt;url-pattern&gt;/hello&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; URL到 Servlet 程序的访问 Servlet 的生命周期1、执行 Servlet 构造器方法 2、执行 init 初始化方法 第一、二步，是在第一次访问的时候创建 Servlet 程序会调用。 3、执行 service 方法 第三步，每次访问都会调用。 4、执行 destroy 销毁方法 第四步，在 web 工程停止的时候调用 GET 和 POST 请求的分发处理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.atguigu.servlet;import javax.servlet.*;import javax.servlet.http.HttpServletRequest;import java.io.IOException;public class HelloServlet implements Servlet &#123; public HelloServlet() &#123; System.out.println(&quot;1 构造器方法&quot;); &#125; /** * service方法是专门用来处理请求和响应的 * @param servletRequest * @param servletResponse * @throws ServletException * @throws IOException */ @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123; System.out.println(&quot;3 service === Hello Servlet 被访问了&quot;); // 类型转换（因为它有getMethod()方法） HttpServletRequest httpServletRequest = (HttpServletRequest) servletRequest; // 获取请求的方式 String method = httpServletRequest.getMethod(); if (&quot;GET&quot;.equals(method)) &#123; doGet(); &#125; else if (&quot;POST&quot;.equals(method)) &#123; doPost(); &#125; &#125; /** * 做get请求的操作 */ public void doGet()&#123; System.out.println(&quot;get请求&quot;); System.out.println(&quot;get请求&quot;); &#125; /** * 做post请求的操作 */ public void doPost()&#123; System.out.println(&quot;post请求&quot;); System.out.println(&quot;post请求&quot;); &#125; &#125;&#125; 通过继承 HttpServlet 实现 Servlet 程序一般在实际项目开发中，都是使用继承 HttpServlet 类的方式去实现 Servlet 程序。 1、编写一个类去继承 HttpServlet 类 2、根据业务需要重写 doGet 或 doPost 方法 3、到 web.xml 中的配置 Servlet 程序的访问地址 12345678910111213141516171819202122232425262728293031323334353637383940414243public class HelloServlet2 extends HttpServlet &#123; @Override public void init(ServletConfig config) throws ServletException &#123; super.init(config); System.out.println(&quot;重写了init初始化方法,做了一些工作&quot;); &#125; /** * doGet（）在get请求的时候调用 * @param req * @param resp * @throws ServletException * @throws IOException */ @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; int i = 12 / 0; System.out.println(&quot;HelloServlet2 的doGet方法&quot;); // 也可以使用. ServletConfig servletConfig = getServletConfig(); System.out.println(servletConfig); // 2、获取初始化参数init-param System.out.println(&quot;初始化参数username的值是;&quot; + servletConfig.getInitParameter(&quot;username&quot;)); System.out.println(&quot;初始化参数url的值是;&quot; + servletConfig.getInitParameter(&quot;url&quot;)); &#125; /** * doPost（）在post请求的时候调用 * @param req * @param resp * @throws ServletException * @throws IOException */ @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;HelloServlet2 的doPost方法&quot;); &#125;&#125; Servlet类的继承体系 Ⅲ.HttpServletRequest 类HttpServletRequest 类有什么作用每次只要有请求进入 Tomcat 服务器，Tomcat 服务器就会把请求过来的 HTTP 协议信息解析好封装到 Request 对象中。 然后传递到 service 方法（doGet 和 doPost）中给我们使用。我们可以用HttpServletRequest 对象，获取到所有请求的 信息。 HttpServletRequesti. getRequestURI() 获取请求的资源路径 ii. getRequestURL() 获取请求的统一资源定位符（绝对路径） iii. getRemoteHost() 获取客户端的 ip 地址 iv. getHeader() 获取请求头 v. getParameter() 获取请求的参数 vi. getParameterValues() 获取请求的参数（多个值的时候使用） vii. getMethod() 获取请求的方式 GET 或 POST viii. setAttribute(key, value); 设置域数据 ix. getAttribute(key); 获取域数据 x. getRequestDispatcher() 获取请求转发对象 请求的转发请求转发是指，服务器收到请求后，从一次资源跳转到另一个资源的操作叫请求转发。 1234567891011121314151617181920212223public class Servlet1 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 获取请求的参数（办事的材料）查看 String username = req.getParameter(&quot;username&quot;); System.out.println(&quot;在Servlet1（柜台1）中查看参数（材料）：&quot; + username); // 给材料 盖一个章，并传递到Servlet2（柜台 2）去查看 req.setAttribute(&quot;key1&quot;,&quot;柜台1的章&quot;); // 问路：Servlet2（柜台 2）怎么走 /** * 请求转发必须要以斜杠打头，/ 斜杠表示地址为：http://ip:port/工程名/ , 映射到IDEA代码的web目录&lt;br/&gt; * */ RequestDispatcher requestDispatcher = req.getRequestDispatcher(&quot;/servlet2&quot;); // 走向Sevlet2（柜台 2） requestDispatcher.forward(req,resp); &#125;&#125; 123456789101112131415public class Servlet2 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 获取请求的参数（办事的材料）查看 String username = req.getParameter(&quot;username&quot;); System.out.println(&quot;在Servlet2（柜台2）中查看参数（材料）：&quot; + username); // 查看 柜台1 是否有盖章 Object key1 = req.getAttribute(&quot;key1&quot;); System.out.println(&quot;柜台1是否有章：&quot; + key1); // 处理自己的业务 System.out.println(&quot;Servlet2 处理自己的业务 &quot;); &#125;&#125; Ⅳ.HttpServletResponse 类HttpServletResponse 类的作用HttpServletResponse 类和 HttpServletRequest 类一样。每次请求进来，Tomcat 服务器都会创建一个 Response 对象传 递给 Servlet 程序去使用。HttpServletRequest 表示请求过来的信息，HttpServletResponse 表示所有响应的信息， 我们如果需要设置返回给客户端的信息，都可以通过 HttpServletResponse 对象来进行设置。 两个输出流的说明字节流 getOutputStream(); 常用于下载（传递二进制数据） 字符流 getWriter(); 常用于回传字符串（常用） 两个流同时只能使用一个。 使用了字节流，就不能再使用字符流，反之亦然，否则就会报错。 如何往客户端回传数据要求 ： 往客户端回传 字符串 数据 12345678public class ResponseIOServlet extends HttpServlet &#123;@Overrideprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException,IOException &#123; // 要求 ： 往客户端回传 字符串 数据。 PrintWriter writer = resp.getWriter(); writer.write(&quot;response&#x27;s content!!!&quot;); &#125;&#125; 响应的乱码解决123// 它会同时设置服务器和客户端都使用 UTF-8 字符集，还设置了响应头// 此方法一定要在获取流对象之前调用才有效resp.setContentType(&quot;text/html; charset=UTF-8&quot;); 请求重定向请求重定向，是指客户端给服务器发请求，然后服务器告诉客户端说。我给你一些地址。你去新地址访问。叫请求 重定向（因为之前的地址可能已经被废弃）。 注意转发与重定向的区别，转发访问的是同一个资源，最明显的特征是浏览器地址栏的地址不会发生变化，重定向访问的是新的资源，浏览器地址栏里的地址会发生变化。 请求重定向的第二种方案（推荐使用）： 1resp.sendRedirect(&quot;http://localhost:8080&quot;); Ⅴ.Servlet的一些细节1.一个已经注册的Servlet可以被多次映射同一个Servlet可以被映射到多个URL上。 1234567891011121314151617&lt;servlet&gt; &lt;servlet-name&gt;Demo1&lt;/servlet-name&gt; &lt;servlet-class&gt;zhongfucheng.web.Demo1&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;Demo1&lt;/servlet-name&gt; &lt;url-pattern&gt;/Demo1&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;Demo1&lt;/servlet-name&gt; &lt;url-pattern&gt;/ouzicheng&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 无论访问的是http://localhost:8080/Demo1还是http://localhost:8080/ouzicheng。访问的都是Demo1。 2.Servlet是单例的为什么Servlet是单例的浏览器多次对Servlet的请求，一般情况下，服务器只创建一个Servlet对象，也就是说，Servlet对象一旦创建了，就会驻留在内存中，为后续的请求做服务，直到服务器关闭。 每次访问请求对象和响应对象都是新的对于每次访问请求，Servlet引擎都会创建一个新的HttpServletRequest请求对象和一个新的HttpServletResponse响应对象，然后将这两个对象作为参数传递给它调用的Servlet的service()方法，service方法再根据请求方式分别调用doXXX方法。 3.线程安全问题当多个用户访问Servlet的时候，服务器会为每个用户创建一个线程。当多个用户并发访问Servlet共享资源的时候就会出现线程安全问题。 原则： 如果一个变量需要多个用户共享，则应当在访问该变量的时候，加同步机制synchronized (对象){} 如果一个变量不需要共享，则直接在 doGet() 或者 doPost()定义.这样不会存在线程安全问题。 Ⅵ. ServletContext对象什么是 ServletContext?1、ServletContext 是一个接口，它表示 Servlet 上下文对象 2、一个 web 工程，只有一个 ServletContext 对象实例。 3、ServletContext 对象是一个域对象。 4、ServletContext 是在 web 工程部署启动的时候创建。在 web 工程停止的时候销毁。 域对象，是可以像 Map 一样存取数据的对象，叫域对象。 这里的域指的是存取数据的操作范围，整个 web 工程。 ​ 存数据 取数据 删除 数据 Map put() get() remove() 域对象 setAttribute() getAttribute() removeAttribute(); ServletContext有什么用？ ServletContext既然代表着当前web站点，那么所有Servlet都共享着一个ServletContext对象，所以Servlet之间可以通过ServletContext实现通讯。 ServletConfig获取的是配置的是单个Servlet的参数信息，ServletContext可以获取的是配置整个web站点的参数信息 利用ServletContext读取web站点的资源文件 实现Servlet的转发【用ServletContext转发不多，主要用request转发】 Ⅶ. 会话技术 Cookie 和 Session1.为什么需要会话技术？ 会话是浏览器和服务器之间的多次请求和响应 也就是说，从浏览器访问服务器开始，到访问服务器结束，浏览器关闭为止的这段时间内容产生的多次请求和响应，合起来叫做浏览器和服务器之间的一次会话 实际上会话问题解决的还是客户端与服务器之间的通信问题，通过一些会话技术，可以将每个用户的数据以例如cookie/session的形式存储，方便以后用户访问web资源的时候使用。 假定场景：A和B两人在某个网上购物商场登陆账号后，A买了一个HHKB的键盘，而B则购买了一把民谣吉他，这些信息都会被保存下来 用途是：保存账户信息，登录时询问日后是否自动登录，或者根据之前浏览，购买过的商品，分析用户喜欢什么类型的商品，做出精准推送 2. 会话技术分类客户端会话技术 —— Cookie 服务器会话技术 —— Session 3. Cookie Cookie是由W3C组织提出，最早由netscape社区发展的一种机制 网页之间的交互是通过HTTP协议传输数据的，而Http协议是无状态的协议。无状态的协议是什么意思呢？一旦数据提交完后，浏览器和服务器的连接就会关闭，再次交互的时候需要重新建立新的连接。 服务器无法确认用户的信息，于是乎，W3C就提出了：给每一个用户都发一个通行证，无论谁访问的时候都需要携带通行证，这样服务器就可以从通行证上确认用户的信息。通行证就是Cookie. 如何创建Cookie 123456789101112protected void createCookie(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1 创建Cookie对象 Cookie cookie = new Cookie(&quot;key4&quot;, &quot;value4&quot;); //2 通知客户端保存Cookie resp.addCookie(cookie); //1 创建Cookie对象 Cookie cookie1 = new Cookie(&quot;key5&quot;, &quot;value5&quot;); //2 通知客户端保存Cookie resp.addCookie(cookie1); resp.getWriter().write(&quot;Cookie创建成功&quot;);&#125; 服务器如何获取 Cookie服务器获取客户端的 Cookie 只需要一行代码：req.getCookies():Cookie[] Cookie 的工具类 1234567891011121314151617181920public class CookieUtils &#123; /** * 查找指定名称的Cookie对象 * @param name * @param cookies * @return */ public static Cookie findCookie(String name , Cookie[] cookies)&#123; if (name == null || cookies == null || cookies.length == 0) &#123; return null; &#125; for (Cookie cookie : cookies) &#123; if (name.equals(cookie.getName())) &#123; return cookie; &#125; &#125; return null; &#125;&#125; Servlet 程序中的代码： 1234567891011121314151617protected void getCookie(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; Cookie[] cookies = req.getCookies(); for (Cookie cookie : cookies) &#123; // getName方法返回Cookie的key（名） // getValue方法返回Cookie的value值 resp.getWriter().write(&quot;Cookie[&quot; + cookie.getName() + &quot;=&quot; + cookie.getValue() + &quot;] &lt;br/&gt;&quot;); &#125; Cookie iWantCookie = CookieUtils.findCookie(&quot;key1&quot;, cookies); // 如果不等于null，说明赋过值，也就是找到了需要的Cookie if (iWantCookie != null) &#123; resp.getWriter().write(&quot;找到了需要的Cookie&quot;); &#125; &#125; Cookie值的修改1、先查找到需要修改的 Cookie 对象 2、调用 setValue()方法赋于新的 Cookie 值。 3、调用 response.addCookie()通知客户端保存修改 1234567891011121314151617181920protected void updateCookie(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 方案一：// 1、先创建一个要修改的同名的Cookie对象// 2、在构造器，同时赋于新的Cookie值。// Cookie cookie = new Cookie(&quot;key1&quot;,&quot;newValue1&quot;);// 3、调用response.addCookie( Cookie ); 通知 客户端 保存修改// resp.addCookie(cookie);// 方案二：// 1、先查找到需要修改的Cookie对象 Cookie cookie = CookieUtils.findCookie(&quot;key2&quot;, req.getCookies()); if (cookie != null) &#123;// 2、调用setValue()方法赋于新的Cookie值。 cookie.setValue(&quot;newValue2&quot;);// 3、调用response.addCookie()通知客户端保存修改 resp.addCookie(cookie); &#125; resp.getWriter().write(&quot;key1的Cookie已经修改好&quot;); &#125; 浏览器查看 Cookie： Cookie 生命控制Cookie 的生命控制指的是如何管理 Cookie 什么时候被销毁（删除） setMaxAge() 正数 表示在指定的秒数后过期 负数 表示浏览器一关，Cookie 就会被删除（默认值是-1） 零 表示马上删除 Cookie 123456789101112131415161718192021222324252627282930313233343536373839404142protected void life3600(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; Cookie cookie = new Cookie(&quot;life3600&quot;, &quot;life3600&quot;); cookie.setMaxAge(60 * 60); // 设置Cookie一小时之后被删除。无效 resp.addCookie(cookie); resp.getWriter().write(&quot;已经创建了一个存活一小时的Cookie&quot;);&#125;/** * 马上删除一个Cookie * @param req * @param resp * @throws ServletException * @throws IOException */protected void deleteNow(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 先找到你要删除的Cookie对象 Cookie cookie = CookieUtils.findCookie(&quot;key4&quot;, req.getCookies()); if (cookie != null) &#123; // 调用setMaxAge(0); cookie.setMaxAge(0); // 表示马上删除，都不需要等待浏览器关闭 // 调用response.addCookie(cookie); resp.addCookie(cookie); resp.getWriter().write(&quot;key4的Cookie已经被删除&quot;); &#125;&#125;/** * 默认的会话级别的Cookie * @param req * @param resp * @throws ServletException * @throws IOException */protected void defaultLife(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; Cookie cookie = new Cookie(&quot;defalutLife&quot;,&quot;defaultLife&quot;); cookie.setMaxAge(-1);//设置存活时间 resp.addCookie(cookie);&#125; 4.Session什么是 Session 会话?1、Session 就一个接口（HttpSession）。 2、Session 就是会话。它是用来维护一个客户端和服务器之间关联的一种技术。 3、每个客户端都有自己的一个 Session 会话。 4、Session 会话中，我们经常用来保存用户登录之后的信息。 Session 是另一种记录浏览器状态的机制。不同的是Cookie保存在浏览器中，Session保存在服务器中。用户使用浏览器访问服务器的时候，服务器把用户的信息以某种的形式记录在服务器，这就是Session 为什么要使用Session技术？Session比Cookie使用方便，Session可以解决Cookie解决不了的事情【Session可以存储对象，而Cookie只能存储字符串】。 如何创建 Session 和获取(id 号,是否为新）如何创建和获取 Session。它们的 API 是一样的。 request.getSession() 第一次调用是：创建 Session 会话之后调用都是：获取前面创建好的 Session 会话对象。 isNew(); 判断到底是不是刚创建出来的（新的） true 表示刚创建 false 表示获取之前创建 ​ 每个会话都有一个身份证号。也就是 ID 值。而且这个 ID 是唯一的。 getId() 得到 Session 的会话 id 值。 Session 域数据的存取123456789protected void setAttribute(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; req.getSession().setAttribute(&quot;key1&quot;, &quot;value1&quot;); resp.getWriter().write(&quot;已经往Session中保存了数据&quot;);&#125;protected void getAttribute(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; Object attribute = req.getSession().getAttribute(&quot;key1&quot;); resp.getWriter().write(&quot;从Session中获取出key1的数据是：&quot; + attribute);&#125; Session 生命周期控制public void setMaxInactiveInterval(int interval) 设置 Session 的超时时间（以秒为单位），超过指定的时长，Session 就会被销毁。 值为正数的时候，设定 Session 的超时时长。 负数表示永不超时（极少使用） public int getMaxInactiveInterval() 获取 Session 的超时时间 public void invalidate() 让当前 Session 会话马上超时无效。 Session 默认的超时时间长为 30 分钟。 因为在 Tomcat 服务器的配置文件 web.xml中默认有以下的配置，它就表示配置了当前 Tomcat 服务器下所有的 Session 超时配置默认时长为：30 分钟。 123&lt;session-config&gt;&lt;session-timeout&gt;30&lt;/session-timeout&gt;&lt;/session-config&gt; 如果说。你希望你的 web 工程，默认的 Session 的超时时长为其他时长。你可以在你自己的 web.xml 配置文件中做 以上相同的配置。就可以修改你的 web 工程所有 Seession 的默认超时时长。 123&lt;session-config&gt;&lt;session-timeout&gt;20&lt;/session-timeout&gt;&lt;/session-config&gt; 浏览器和 Session 之间关联的技术内幕 问题来了：服务器是如何实现一个session为一个用户浏览器服务的？换个说法：为什么服务器能够为不同的用户浏览器提供不同session？ HTTP协议是无状态的，Session不能依据HTTP连接来判断是否为同一个用户。于是乎：服务器向用户浏览器发送了一个名为JESSIONID的Cookie，它的值是Session的id值。其实Session依据Cookie来识别是否是同一个用户。 简单来说：Session 之所以可以识别不同的用户，依靠的就是Cookie 该Cookie是服务器自动颁发给浏览器的，不用我们手工创建的。该Cookie的maxAge值默认是-1，也就是说仅当前浏览器使用，不将该Cookie存在硬盘中 Ⅷ. 常见面试题1.Tomcat 有哪几种Connector 运行模式(优化)？ bio(blocking I/O)： 传统的Java I/O操作，同步且阻塞IO。 nio(non-blocking I/O)：JDK1.4开始支持，同步阻塞或同步非阻塞IO apr(Apache Portable Runtime/Apache可移植运行库)：Tomcat将以JNI的形式调用Apache HTTP服务器的核心动态链接库来处理文件读取或网络传输操作，从而大大地提高Tomcat对静态文件的处理性能 aio（nio.2）JDK7开始支持，异步非阻塞IO 2.Servlet生命周期Servlet生命周期可分为5个步骤 加载Servlet。当Tomcat第一次访问Servlet的时候，Tomcat会负责创建Servlet的实例 初始化。当Servlet被实例化后，Tomcat会调用init()方法初始化这个对象 处理服务。当浏览器访问Servlet的时候，Servlet 会调用service()方法处理请求 销毁。当Tomcat关闭时或者检测到Servlet要从Tomcat删除的时候会自动调用destroy()方法，让该实例释放掉所占的资源。一个Servlet如果长时间不被使用的话，也会被Tomcat自动销毁 卸载。当Servlet调用完destroy()方法后，等待垃圾回收。如果有需要再次使用这个Servlet，会重新调用init()方法进行初始化操作。 简单总结：只要访问Servlet，service()就会被调用。init()只有第一次访问Servlet的时候才会被调用。destroy()只有在Tomcat关闭的时候才会被调用。 3.get方式和post方式有何区别数据携带上: GET方式：在URL地址后附带的参数是有限制的，其数据容量通常不能超过1K。 POST方式：可以在请求的实体内容中向服务器发送数据，传送的数据量无限制。 请求参数的位置上: GET方式：请求参数放在URL地址后面，以?的方式来进行拼接 POST方式:请求参数放在HTTP请求包中 用途上: GET方式一般用来获取数据 POST方式一般用来提交数据 首先是因为GET方式携带的数据量比较小，无法带过去很大的数量 POST方式提交的参数后台更加容易解析(使用POST方式提交的中文数据，后台也更加容易解决) GET方式比POST方式要快。具体原因：为什么GET方式比POST方式要快 ？ 4.forward和redirect的区别 实际发生位置不同，地址栏不同 转发是发生在服务器的 转发是由服务器进行跳转的，也就是说浏览器是不知道该跳转的动作，转发是对浏览器透明的。实现转发只是一次的http请求，一次转发中request和response对象都是同一个。这也解释了为什么可以使用request作为域对象进行Servlet之间的通讯。 重定向是发生在浏览器的 - 重定向是由浏览器进行跳转的，进行重定向跳转的时候，浏览器的地址会发生变化的。实现重定向的原理是由response的状态码和Location头组合而实现的。这是由浏览器进行的页面跳转实现重定向会发出两个http请求，request域对象是无效的，因为它不是同一个request对象 用法不同: 很多人都搞不清楚转发和重定向的时候，资源地址究竟怎么写。有的时候要把应用名写上，有的时候不用把应用名写上。很容易把人搞晕。记住一个原则： 给服务器用的直接从资源名开始写，给浏览器用的要把应用名写上 request.getRequestDispatcher(“/资源名 URI”).forward(request,response) 转发时”/“代表的是本应用程序的根目录【zhongfucheng】 - response.send(“/web应用/资源名 URI”); - 重定向时”/“代表的是webapps目录 能够去往的URL的范围不一样: 转发是服务器跳转只能去往当前web应用的资源 重定向是服务器跳转，可以去往任何的资源 传递数据的类型不同 转发的request对象可以传递各种类型的数据，包括对象 重定向只能传递字符串 跳转的时间不同 转发时：执行到跳转语句时就会立刻跳转 重定向：整个页面执行完之后才执行跳转 那么转发(forward)和重定向(redirect)使用哪一个？ 根据上面说明了转发和重定向的区别也可以很容易概括出来。转发是带着转发前的请求的参数的。重定向是新的请求。 典型的应用场景： 转发: 访问 Servlet 处理业务逻辑，然后 forward 到 jsp 显示处理结果，浏览器里 URL 不变 重定向: 提交表单，处理成功后 redirect 到另一个 jsp，防止表单重复提交，浏览器里 URL 变了 5.tomcat容器是如何创建servlet类实例？用到了什么原理？ 当容器启动时，会读取在webapps目录下所有的web应用中的web.xml文件，然后对 xml文件进行解析，并读取servlet注册信息。然后，将每个应用中注册的servlet类都进行加载，并通过 反射的方式实例化。（有时候也是在第一次请求时实例化） 在servlet注册时加上1如果为正数，则在一开始就实例化，如果不写或为负数，则第一次请求实例化。 6.什么是cookie？Session和cookie有什么区别？ 网页之间的交互是通过HTTP协议传输数据的，而Http协议是无状态的协议。无状态的协议是什么意思呢？一旦数据提交完后，浏览器和服务器的连接就会关闭，再次交互的时候需要重新建立新的连接。 服务器无法确认用户的信息，于是乎，W3C就提出了：给每一个用户都发一个通行证，无论谁访问的时候都需要携带通行证，这样服务器就可以从通行证上确认用户的信息。通行证就是Cookie ​ 1. 从存储方式上比较 Cookie只能存储字符串，如果要存储非ASCII字符串还要对其编码。 Session可以存储任何类型的数据，可以把Session看成是一个容器 2.从有效期上比较 Cookie保存在硬盘中，只需要设置maxAge属性为比较大的正整数，即使关闭浏览器，Cookie还是存在的 Session的保存在服务器中，设置maxInactiveInterval属性值来确定Session的有效期。并且Session依赖于名为JSESSIONID的Cookie，该Cookie默认的maxAge属性为-1。如果关闭了浏览器，该Session虽然没有从服务器中消亡，但也就失效了。 3. 从对服务器的负担比较 Session是保存在服务器的，每个用户都会产生一个Session，如果是并发访问的用户非常多，是不能使用Session的，Session会消耗大量的内存。 Cookie是保存在客户端的。不占用服务器的资源。像baidu、Sina这样的大型网站，一般都是使用Cookie来进行会话跟踪。 4. 从浏览器的支持上比较 如果浏览器禁用了Cookie，那么Cookie是无用的了！ 如果浏览器禁用了Cookie，Session可以通过URL地址重写来进行会话跟踪。 5. 从跨域名上比较 Cookie可以设置domain属性来实现跨域名 Session只在当前的域名内有效，不可夸域名 6.从隐私安全上比较 Cookie存储在浏览器中，对客户端是可见的。信息容易泄露出去。如果使用Cookie，最好将Cookie加密 Session存储在服务器上，对客户端是透明的。不存在敏感信息泄露问题。 7.Servlet安全性问题由于Servlet是单例的，当多个用户访问Servlet的时候，服务器会为每个用户创建一个线程。当多个用户并发访问Servlet共享资源的时候就会出现线程安全问题。 原则： 如果一个变量需要多个用户共享，则应当在访问该变量的时候，加同步机制synchronized (对象){} 如果一个变量不需要共享，则直接在 doGet() 或者 doPost()定义.这样不会存在线程安全问题","categories":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/tags/java%E5%9F%BA%E7%A1%80/"}]},{"title":"Mybatis 学习（一）","slug":"mybatis笔记(一)","date":"2021-09-04T14:32:51.514Z","updated":"2021-10-26T09:20:01.198Z","comments":true,"path":"2021/09/04/mybatis笔记(一)/","link":"","permalink":"http://example.com/2021/09/04/mybatis%E7%AC%94%E8%AE%B0(%E4%B8%80)/","excerpt":"1.Mybatis简介1.1原始jdbc操作（查询数据） 1.2原始jdbc操作（插入数据）","text":"1.Mybatis简介1.1原始jdbc操作（查询数据） 1.2原始jdbc操作（插入数据） 1.3 原始jdbc操作的分析原始jdbc开发存在的问题如下： ①数据库连接创建、释放频繁造成系统资源浪费从而影响系统性能 ②sql 语句在代码中硬编码，造成代码不易维护，实际应用 sql 变化的可能较大，sql 变动需要改变java代码。 ③查询操作时，需要手动将结果集中的数据手动封装到实体中。插入操作时，需要手动将实体的数据设置到sql语句的占位符位置 应对上述问题给出的解决方案： ①使用数据库连接池初始化连接资源 ②将sql语句抽取到xml配置文件中 ③使用反射、内省等底层技术，自动将实体与表进行属性与字段的自动映射 1.4 什么是Mybatismybatis 是一个优秀的基于java的持久层框架，它内部封装了jdbc，使开发者只需要关注sql语句本身，而不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。 mybatis通过xml或注解的方式将要执行的各种 statement配置起来，并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句。 最后mybatis框架执行sql并将结果映射为java对象并返回。采用ORM思想(对象关系映射（Object Relational Mapping))解决了实体和数据库映射的问题，对jdbc 进行了封装，屏蔽了jdbc API 底层访问细节，使我们不用与jdbc API 打交道，就可以完成对数据库的持久化操作。 ORM思想**O(对象模型)**：实体对象，即我们在程序中根据数据库表结构建立的一个个实体Entity。 **R(关系型数据库的数据结构)**：即我们建立的数据库表。 **M(映射)**：从 R(数据库) 到 O(对象模型) 的映射，可通过XML文件映射。 为什么使用ORM？提高开发效率：ORM框架自动实现Entity实体的属性与关系型数据库字段的映射。CRUD的工作则可以交给ORM来自动生成代码方式实现。隐藏了数据访问细节，“封闭”的通用数据库交互，他使得我们的通用数据库交互变得简单易行，并且完全不用考虑SQL语句。大大提高我们开发效率， 这样一来也减少我们维护一个复杂 缺乏灵活性数据访问层的成本。 ORM作为是一种思想，帮助我们开发人员跟踪实体的变化,并将实体的变化翻译成sql脚本,执行到数据库中去,也就是将实体的变化映射到了表的变化。这样会给我们带来非常大的便利。但有得必有失，便利的同时也无可避免的带来了一些其他的问题：比如性能降低，复杂的查询ORM仍然力不从心等。 2.Mybatis的快速入门2.1 MyBatis开发步骤MyBatis官网地址：http://www.mybatis.org/mybatis-3/ MyBatis开发步骤： ①添加MyBatis的坐标 ②创建user数据表 ③编写User实体类 ④编写映射文件UserMapper.xml ⑤编写核心文件SqlMapConfig.xml ⑥编写测试类 2.2 环境搭建1)导入 MyBatis 的坐标和其他相关坐标 1234567891011121314151617181920212223242526272829&lt;!--mybatis坐标--&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.5&lt;/version&gt; &lt;!--compile：默认值 他表示被依赖项目需要参与当前项目的编译，还有后续的测试，运行周期也参与 其中，是一个比较强的依赖。打包的时候通常需要包含进去--&gt;&lt;/dependency&gt;&lt;!--mysql驱动坐标--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;!--runtime：表示被依赖项目无需参与项目的编译，不过后期的测试和运行周期需要其参与。与 compile相比，跳过了编译而已。例如JDBC驱动，适用运行和测试阶段--&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;!--单元测试坐标--&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;!--test：依赖项目仅仅参与测试相关的工作，包括测试代码的编译和执行，不会被打包，例如： junit--&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;!--日志坐标--&gt;&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.12&lt;/version&gt;&lt;/dependency&gt; 创建user数据表 编写User实体 123456public class User &#123; private int id; private String username; private String password; //省略get和set方法&#125; 4)编写UserMapper映射文件 123456789101112131415161718192021222324252627&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!-- mapper 为根元素节点， 一个 namespace 对应一个 dao --&gt;&lt;mapper namespace=&quot;userMapper&quot;&gt; &lt;!-- 1. id （必须配置） id是命名空间中的唯一标识符，可被用来代表这条语句。 一个命名空间（namespace） 对应一个 dao 接口, 这个 id 也应该对应 dao 里面的某个方法（相当于方法的实现）， 因此 id 应该与方法名一致--&gt; &lt;!-- 2.resultType 指定 resultType 返回值类型是 User 类型的， 只需要指定 resultType 的类型，MyBatis 会自动将查询的结果 映射成 JavaBean 中的属性。 对于resultType=&quot;string&quot; string 在这里是一个别名，代表的是 java.lang.String 对于引用数据类型，都是将大写字母转小写， 比如 HashMap 对应的别名是 &#x27;hashmap&#x27; 基本数据类型考虑到重复的问题， 会在其前面加上 &#x27;_&#x27;，比如 byte 对应的别名是 &#x27;_byte&#x27; --&gt; &lt;select id=&quot;findAll&quot; resultType=&quot;com.itheima.domain.User&quot;&gt; select * from User &lt;/select&gt;&lt;/mapper&gt; 编写MyBatis核心文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN“ &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;!--事务管理器 transactionManager 在 MyBatis 中有两种类型的事务管理器 （也就是 type=”[JDBC|MANAGED]”）： 1.JDBC -- 这个配置就是直接使用了 JDBC 的提交和回滚设置， 它依赖于从数据源得到的连接来管理事务作用域。 2.MANAGED – 这个配置几乎没做什么。 它从来不提交或回滚一个连接， 而是让容器来管理事务的整个生命周期（比如 JEE 应用服务器的上下文）。 默认情况下它会关闭连接，然而一些容器并不希望这样， 因此需要将 closeConnection 属性设置为 false 来阻止它默认的关闭行为。 提示：如果使用 Spring + MyBatis，则没有必要配置事务管理器， 因为 Spring 模块会使用自带的管理器来覆盖前面的配置。 --&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;!-- 数据源 dataSource 元素使用标准的 JDBC 数据源接口 来配置 JDBC 连接对象的资源。 许多 MyBatis 的应用程序会按示例中的例子来配置数据源。 虽然这是可选的，但为了使用延迟加载，数据源是必须配置的。 有三种内建的数据源类型（也就是 type=”[UNPOOLED|POOLED|JNDI]”）： POOLED– 这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来， 避免了创建新的连接实例时所必需的初始化和认证时间。 这是一种使得并发 Web 应用快速响应请求的流行处理方式。 POOLED 属性： driver – 这是 JDBC 驱动的 Java 类的完全限定名（并不是 JDBC 驱动中可能包含的 数据源类）。 url – 这是数据库的 JDBC URL 地址。 username – 登录数据库的用户名。 password – 登录数据库的密码。 defaultTransactionIsolationLevel – 默认的连接事务隔离级别。 poolMaximumActiveConnections – 在任意时间可以存在的活动（也就是正在使用） 连接数量，默认值：10 poolMaximumIdleConnections – 任意时间可能存在的空闲连接数。 poolMaximumCheckoutTime – 在被强制返回之前，池中连接被检出（checked out） 时间，默认值：20000 毫秒（即 20 秒） poolTimeToWait – 这是一个底层设置，如果获取连接花费了相当长的时间，连接池会打 印状态日志并重新尝试获取一个连接（避免在误配置的情况下一直安 静的失败），默认值：20000 毫秒（即 20 秒）。 poolMaximumLocalBadConnectionTolerance – 这是一个关于坏连接容忍度的底层 设置， 作用于每一个尝试从缓存池获取连接的线程. 如果这个线程 获取到的是一个坏的连接，那么这个数据源允许这个线程尝试重新获 取一个新的连接，默认值：3 (新增于 3.4.5) poolPingQuery – 发送到数据库的侦测查询，用来检验连接是否正常工作并准备接受请 求。默认是“NO PING QUERY SET”，这会导致多数数据库驱动失败 时带有一个恰当的错误消息。 poolPingEnabled – 是否启用侦测查询。若开启，需要设置 poolPingQuery 属性为 一个可执行的 SQL 语句（最好是一个速度非常快的 SQL 语 句），默认值：false。 poolPingConnectionsNotUsedFor – 配置 poolPingQuery 的频率。可以被设置 为和数据库连接超时时间一样，来避免不必要的侦测，默认值：0 （即所有连接每一时刻都被侦测 — 当然仅当 poolPingEnabled 为 true 时适用）。 --&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///test&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=&quot;com/itheima/mapper/UserMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 注意： 默认的环境 ID（比如:default=”development”）。 每个 environment 元素定义的环境 ID（比如:id=”development”）。 事务管理器的配置（比如:type=”JDBC”）。 数据源的配置（比如:type=”POOLED”）。 默认的环境和环境 ID 是自解释的，因此一目了然。可以对环境随意命名，但一定要保证默认的环境 ID 要匹配其中一个环境 ID。 2.3 编写测试代码12345678910111213//加载核心配置文件InputStream resourceAsStream = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);//获得 sqlSession 工厂对象SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);//获得 sqlSession 对象SqlSession sqlSession = sqlSessionFactory.openSession();//执行 sql 语句List&lt;User&gt; userList = sqlSession.selectList(&quot;userMapper.findAll&quot;);//打印结果System.out.println(userList);//释放资源sqlSession.close(); 2.4 小结MyBatis开发步骤： ①添加MyBatis的坐标 ②创建user数据表 ③编写User实体类 ④编写映射文件UserMapper.xml ⑤编写核心文件SqlMapConfig.xml ⑥编写测试类 3. MyBatis的映射文件概述 4. MyBatis的增删改查操作4.1 MyBatis的插入数据操作1)编写UserMapper映射文件 12345&lt;mapper namespace=&quot;userMapper&quot;&gt; &lt;insert id=&quot;add&quot; parameterType = &quot; com.itheima.domain.User &quot;&gt; insert into user values(#&#123;id&#125;,#&#123;username&#125;,#&#123;password&#125;) &lt;/insert&gt;&lt;/mapper&gt; 2)编写插入实体User的代码 123456789InputStream resourceAsStream = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);SqlSession sqlSession = sqlSessionFactory.openSession();int insert = sqlSession.insert(&quot;userMapper.add&quot;, user);System.out.println(insert);//提交事务sqlSession.commit();sqlSession.close(); 3)插入操作注意问题 • 插入语句使用insert标签 • 在映射文件中使用 parameterType 属性指定要插入的数据类型 • Sql 语句中使用#{实体属性名}方式引用实体中的属性值 • 插入操作使用的 API 是 sqlSession.insert(“命名空间.id”,实体对象); • 插入操作涉及数据库数据变化，所以要使用 sqlSession 对象显示的提交事务，即 sqlSession.commit() 4.2 MyBatis的修改数据操作1)编写UserMapper映射文件 123456&lt;mapper namespace=&quot;userMapper&quot;&gt; &lt;update id=&quot;update&quot; parameterType=&quot;com.itheima.domain.User&quot;&gt; update user set username=#&#123;username&#125;,password=#&#123;password&#125; where id=#&#123;id&#125; &lt;/update&gt;&lt;/mapper&gt; 2)编写修改实体User的代码 1234567InputStream resourceAsStream = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);SqlSession sqlSession = sqlSessionFactory.openSession();int update = sqlSession.update(&quot;userMapper.update&quot;, user);System.out.println(update);sqlSession.commit();sqlSession.close(); 3)修改操作注意问题 • 修改语句使用 update 标签 • 修改操作使用的API是sqlSession.update(“命名空间.id”,实体对象); 4.3 MyBatis的删除数据操作1)编写UserMapper映射文件 123456&lt;mapper namespace=&quot;userMapper&quot;&gt; &lt;delete id=&quot;delete&quot; parameterType=&quot;java.lang.Integer&quot;&gt; delete from user where id=#&#123;id&#125; &lt;/delete&gt;&lt;/mapper&gt; 2)编写删除数据的代码 1234567InputStream resourceAsStream = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);SqlSession sqlSession = sqlSessionFactory.openSession();int delete = sqlSession.delete(&quot;userMapper.delete&quot;,3);System.out.println(delete);sqlSession.commit();sqlSession.close(); 3)删除操作注意问题 • 删除语句使用delete标签 •Sql语句中使用#{任意字符串}方式引用传递的单个参数 •删除操作使用的API是sqlSession.delete(“命名空间.id”,Object); 4.4 知识小结1234567891011121314151617增删改查映射配置与API：查询数据： List&lt;User&gt; userList = sqlSession.selectList(&quot;userMapper.findAll&quot;); &lt;select id=&quot;findAll&quot; resultType=&quot;com.itheima.domain.User&quot;&gt; select * from User &lt;/select&gt;添加数据： sqlSession.insert(&quot;userMapper.add&quot;, user); &lt;insert id=&quot;add&quot; parameterType=&quot;com.itheima.domain.User&quot;&gt; insert into user values(#&#123;id&#125;,#&#123;username&#125;,#&#123;password&#125;) &lt;/insert&gt;修改数据： sqlSession.update(&quot;userMapper.update&quot;, user); &lt;update id=&quot;update&quot; parameterType=&quot;com.itheima.domain.User&quot;&gt; update user set username=#&#123;username&#125;,password=#&#123;password&#125; where id=#&#123;id&#125; &lt;/update&gt;删除数据：sqlSession.delete(&quot;userMapper.delete&quot;,3); &lt;delete id=&quot;delete&quot; parameterType=&quot;java.lang.Integer&quot;&gt; delete from user where id=#&#123;id&#125; &lt;/delete&gt; 5. MyBatis核心配置文件概述5.1 MyBatis核心配置文件层级关系 5.2 MyBatis常用配置解析1)environments标签 数据库环境的配置，支持多环境配置 其中，事务管理器（transactionManager）类型有两种： •JDBC：这个配置就是直接使用了JDBC 的提交和回滚设置，它依赖于从数据源得到的连接来管理事务作用域。 •MANAGED：这个配置几乎没做什么。它从来不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（比如 JEE 应用服务器的上下文）。 默认情况下它会关闭连接，然而一些容器并不希望这样，因此需要将 closeConnection 属性设置为 false 来阻止它默认的关闭行为。 其中，数据源（dataSource）类型有三种： • UNPOOLED：这个数据源的实现只是每次被请求时打开和关闭连接。 • POOLED：这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来。 • JNDI：这个数据源的实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的引用。 2)mapper标签 该标签的作用是加载映射的，加载方式有如下几种： • 使用相对于类路径的资源引用，例如： 1&lt;mapper resource=&quot;org/mybatis/builder/AuthorMapper.xml&quot;/&gt; • 使用完全限定资源定位符（URL），例如： 1&lt;mapper url=&quot;file:///var/mappers/AuthorMapper.xml&quot;/&gt; • 使用映射器接口实现类的完全限定类名，例如： 1&lt;mapper class=&quot;org.mybatis.builder.AuthorMapper&quot;/&gt; • 将包内的映射器接口实现全部注册为映射器，例如： 1&lt;package name=&quot;org.mybatis.builder&quot;/&gt; 3)Properties标签 实际开发中，习惯将数据源的配置信息单独抽取成一个properties文件，该标签可以加载额外配置的properties文件。 4)typeAliases标签 类型别名是为Java 类型设置一个短的名字。原来的类型名称配置如下 配置typeAliases，为com.itheima.domain.User定义别名为user 上面我们是自定义的别名，mybatis框架已经为我们设置好的一些常用的类型的别名 5.3 知识小结核心配置文件常用配置： properties标签：该标签可以加载外部的properties文件 1&lt;properties resource=&quot;jdbc.properties&quot;&gt;&lt;/properties&gt; typeAliases标签：设置类型别名 1&lt;typeAlias type=&quot;com.itheima.domain.User&quot; alias=&quot;user&quot;&gt;&lt;/typeAlias&gt; mappers标签：加载映射配置 1&lt;mapper resource=&quot;com/itheima/mapper/UserMapping.xml&quot;&gt;&lt;/mapper&gt; environments标签：数据源环境配置标签 6.MyBatis相应API6.1 SqlSession工厂构建器SqlSessionFactoryBuilder常用API：SqlSessionFactory build(InputStream inputStream) 通过加载mybatis的核心文件的输入流的形式构建一个 SqlSessionFactory 对象 1234String resource = &quot;org/mybatis/builder/mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); SqlSessionFactory factory = builder.build(inputStream); 其中， Resources 工具类，这个类在 org.apache.ibatis.io 包中。Resources 类帮助你从类路径下、文件系统或一个 web URL 中加载资源文件。 6.2 SqlSession工厂对象SqlSessionFactorySqlSessionFactory 有多个个方法创建SqlSession 实例。常用的有如下两个： 6.3 SqlSession会话对象SqlSession 实例在 MyBatis 中是非常强大的一个类。在这里你会看到所有执行语句、提交或回滚事务和获取映射器实例的方法。 执行语句的方法主要有： 123456&lt;T&gt; T selectOne(String statement, Object parameter) &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter) int insert(String statement, Object parameter) int update(String statement, Object parameter) int delete(String statement, Object parameter) 操作事务的方法主要有： 12void commit() void rollback()","categories":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://example.com/categories/Mybatis/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://example.com/tags/Mybatis/"}]},{"title":"Maven 学习","slug":"Maven回顾","date":"2021-09-04T14:32:51.513Z","updated":"2021-10-26T09:19:18.334Z","comments":true,"path":"2021/09/04/Maven回顾/","link":"","permalink":"http://example.com/2021/09/04/Maven%E5%9B%9E%E9%A1%BE/","excerpt":"Maven高级1.maven基础知识回顾1.1 maven介绍maven 是一个项目管理工具，主要作用是在项目开发阶段对Java项目进行依赖管理和项目构建。 Maven使用项目对象模型（POM-project Object Model）概念，可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工具，在Maven中每个项目都相当于是一个对象，对象（项目）和对象（项目）之间是有关系的。关系包含了：依赖、继承、聚合，实现Maven项目可以更加方便的实现导入jar包、拆包项目等结果。","text":"Maven高级1.maven基础知识回顾1.1 maven介绍maven 是一个项目管理工具，主要作用是在项目开发阶段对Java项目进行依赖管理和项目构建。 Maven使用项目对象模型（POM-project Object Model）概念，可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工具，在Maven中每个项目都相当于是一个对象，对象（项目）和对象（项目）之间是有关系的。关系包含了：依赖、继承、聚合，实现Maven项目可以更加方便的实现导入jar包、拆包项目等结果。 依赖管理：就是对jar包的管理。通过导入maven坐标，就相当于将仓库中的jar包导入了当前项目中。 项目构建：通过maven的一个命令就可以完成项目从清理、编译、测试、报告、打包，部署整个过程。 1.2 maven的仓库类型1.本地仓库 2.远程仓库 ①maven中央仓库（地址：http://repo2.maven.org/maven2/） ②maven私服（公司局域网内的仓库，需要自己搭建） ③其他公共远程仓库（例如apache提供的远程仓库，地址：http://repo.maven.apache.org/maven2/） 1.3 maven常用命令clean： 清理 compile：编译 test： 测试 package：打包 install： 安装 1.4 maven坐标书写规范 1.5 maven的依赖范围 依赖范围 对于编译classpath有效 对于测试classpath有效 对于运行时classpath有效 例子 compile Y Y Y spring-core test - Y - Junit provided Y Y - servlet-api runtime - Y Y JDBC驱动 system Y Y - 本地的，maven仓库之外的类库 1.6 Maven工程类型1.6.1 POM工程POM工程是逻辑工程，用在父级工程或者聚合工程中。用来做jar包的版本控制。（不会写逻辑业务代码，更多的是起到管理工程的作用，子工程继承了父工程以后，可以直接用通用的jar包） 1.6.2 JAR工程将会打包成jar，用作jar包使用。即常见的本地工程—-&gt;Java Project。 1.6.3 WAR工程将会打包成war，发布在服务器上的工程。 2. maven的依赖传递2.1 什么是依赖传递在maven中，依赖是可以传递的，假设存在三个项目，分别是项目A，项目B以及项目C。假设C依赖B，B依赖A，那么我们可以根据maven项目依赖的特征不难推出项目C也依赖A。 ​ 通过上面的图可以看到，我们的web项目直接依赖了spring-webmvc，而spring-webmvc依赖了sping-aop、spring-beans等。最终的结果就是在我们的web项目中间接依赖了spring-aop、spring-beans等。 2.2 什么是依赖冲突由于依赖传递现象的存在， spring-webmvc 依赖 spirng-beans-4.2.4，spring-aop 依赖 spring-beans-5.0.2，但是发现 spirng-beans-4.2.4 加入到了工程中，而我们希望 spring-beans-5.0.2 加入工程。这就造成了依赖冲突。 2.3 如何解决依赖冲突1.使用maven提供的依赖调解原则 第一声明者优先原则 ​ 路径近者优先原则 2.排除依赖 3.锁定版本 2.4 依赖调节原则——第一声明者优先原则在 pom 文件中定义依赖，以先声明的依赖为准。其实就是根据坐标导入的顺序来确定最终使用哪个传递过来的依赖。 结论：通过上图可以看到，spring-aop和spring-webmvc都传递过来了spring-beans，但是因为spring-aop在前面，所以最终使用的spring-beans是由spring-aop传递过来的，而spring-webmvc传递过来的spring-beans则被忽略了。 2.5 排除依赖可以使用exclusions标签将传递过来的依赖排除出去。 2.6 版本锁定采用直接锁定版本的方法确定依赖jar包的版本，版本锁定后则不考虑依赖的声明顺序或依赖的路径，以锁定的版本为准添加到工程中，此方法在企业开发中经常使用。 版本锁定的使用方式： 第一步：在dependencyManagement标签中锁定依赖的版本 第二步：在dependencies标签中声明需要导入的maven坐标 ①在dependencyManagement标签中锁定依赖的版本 ②在dependencies标签中声明需要导入的maven坐标 3.基于maven构建SSM工程案例3.1 需求描述本案例基于maven构建 SSM（Spring+SpringMVC+Mybatis）工程，通过maven坐标进行依赖管理。最终实现根据 id 查询商品信息的功能。 3.2 构建maven工程1.数据库环境搭建 ​ ①创建数据库ssmtest ​ ②创建商品表item 12345678CREATE TABLE `item` ( `id` int(11) NOT NULL auto_increment, `name` varchar(255) default NULL, `price` float default NULL, `createtime` datetime default NULL, `detail` varchar(255) default NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 2.maven项目构建 ①创建maven web项目 ②配置pom.xml文件 ③实现spring+mybatis整合 创建POJO类 12345678public class Item &#123;private Integer id;private String name;private Float price;private Date createtime;private String detail;//省略setter、getter&#125; 持久层DAO接口编写 123public interface ItemMapper &#123; public Item findById(int id);&#125; Mapper映射文件编写 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.itheima.ssm.dao.ItemMapper&quot;&gt;&lt;select id=&quot;findById&quot; parameterType=&quot;int&quot; resultType=&quot;item&quot;&gt; select * from item where id=#&#123;id&#125;&lt;/select&gt;&lt;/mapper&gt; 业务层Service编写 12345package com.itheima.ssm.service;import com.itheima.ssm.pojo.Item;public interface ItemService &#123; public Items findById(int id);&#125; 123456789@Service@Transactionalpublic class ItemServiceImpl implements ItemService &#123;@Autowiredprivate ItemMapper itemMapper;public Item findById(int id) &#123;return itemMapper.findById(id);&#125;&#125; spring配置文件applicationContext-dao.xml编写 123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/bean http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd&quot;&gt;&lt;!-- 数据库连接池 --&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;&lt;!-- 驱动 --&gt;&lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;&lt;!-- url --&gt;&lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/ssmtest&quot;/&gt;&lt;!-- 用户名 --&gt;&lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;&lt;!-- 密码 --&gt;&lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;&lt;/bean&gt;&lt;!-- mapper配置 --&gt; &lt;!-- 让spring管理sqlsessionfactory 使用mybatis和spring整合包中的 --&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;!-- 数据库连接池 --&gt;&lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;&lt;!--为指定包下的所有实体类创建别名--&gt;&lt;property name=&quot;typeAliasesPackage&quot; value=&quot;com.itheima.ssm.pojo&quot;/&gt;&lt;/bean&gt;&lt;!-- mapper扫描器 ：用来产生代理对象--&gt;&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;&lt;property name=&quot;basePackage&quot; value=&quot;com.itheima.ssm.dao&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; spring配置文件applicationContext-service.xml编写 ④加入springmvc相关配置 表现层Controller编写 123456789101112@Controller@RequestMapping(&quot;/item&quot;)public class ItemController &#123; @Autowired private ItemService itemService; @RequestMapping(&quot;/showItem/&#123;id&#125;&quot;) public String showItem(@PathVariable(&quot;id&quot;) int id, Model model)&#123; Item item = itemService.findById(id); model.addAttribute(&quot;item&quot;,item); return &quot;item&quot;; &#125;&#125; springmvc.xml文件编写 123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;com.itheima.ssm.controller&quot;/&gt;&lt;!-- 配置视图解析器的前缀和后缀 --&gt;&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix“ value=&quot;/WEB-INF/jsp/&quot;&gt;&lt;/property&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;/beans&gt; jsp页面编写 配置web.xml文件 4.分模块构建maven工程4.1 分模块构建maven工程分析在现实生活中，汽车厂家进行汽车生产时，由于整个生产过程非常复杂和繁琐，工作量非常大，所以车场都会将整个汽车的部件分开生产，最终再将生产好的部件进行组装，形成一台完整的汽车。 4.2 maven工程的继承在Java语言中，类之间是可以继承的，通过继承，子类就可以引用父类中非private的属性和方法。同样，在maven工程之间也可以继承，子工程继承父工程后，就可以使用在父工程中引入的依赖。继承的目的是为了消除重复代码。 4.3 maven工程的聚合在maven工程的pom.xml文件中可以使用标签将其他maven工程聚合到一起，聚合的目的是为了进行统一操作。 例如拆分后的maven工程有多个，如果要进行打包，就需要针对每个工程分别执行打包命令，操作起来非常繁琐。这时就可以使用标签将这些工程统一聚合到maven工程中，需要打包的时候，只需要在此工程中执行一次打包命令，其下被聚合的工程就都会被打包了。 4.4 分模块构建maven工程具体实现①父工程maven_parent构建 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293&lt;properties&gt; &lt;spring.version&gt;5.0.5.RELEASE&lt;/spring.version&gt; &lt;springmvc.version&gt;5.0.5.RELEASE&lt;/springmvc.version&gt; &lt;mybatis.version&gt;3.4.5&lt;/mybatis.version&gt; &lt;/properties&gt; &lt;!--锁定jar版本--&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- Mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- springMVC --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;springmvc.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; ②子工程maven_pojo构建 pom.xml 123456789101112&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; ③3.1子工程maven_dao构建 ​ 3.2 配置maven_dao工程的pom.xml文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.itheima&lt;/groupId&gt; &lt;artifactId&gt;maven_pojo&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Mybatis和mybatis与spring的整合 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MySql驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.32&lt;/version&gt; &lt;/dependency&gt; &lt;!-- druid数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.9&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring相关 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- junit测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; ​ 3.3 创建DAO接口和Mapper映射文件 12345678package com.itheima.ssm.dao;import com.itheima.ssm.pojo.Item;public interface ItemMapper &#123; public Item findById(int id);&#125; 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.itheima.ssm.dao.ItemMapper&quot;&gt; &lt;select id=&quot;findById&quot; parameterType=&quot;int&quot; resultType=&quot;Item&quot;&gt; select * from item where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; ​ 3.4 在resources目录下创建spring配置文件applicationContext-dao.xml 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; &lt;!--配置数据源信息，使用druid连接池--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/ssmtest&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;/bean&gt; &lt;!--配置spring整合mybatis框架的SQLSessionFactoryBean--&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;!--扫描pojo包，为实体类创建别名--&gt; &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;com.itheima.ssm.pojo&quot;/&gt; &lt;/bean&gt; &lt;!--mapper扫描器，用于产生代理对象--&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.itheima.ssm.dao&quot;/&gt; &lt;/bean&gt;&lt;/bean ④子工程maven_service构建 ​ 第一步：创建maven_service工程 ​ 第二步：配置maven_service工程的pom.xml文件 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.itheima&lt;/groupId&gt; &lt;artifactId&gt;maven_dao&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; ​ 第三步：创建Service接口和实现类 12345678package com.itheima.ssm.service;import com.itheima.ssm.pojo.Item;public interface ItemService &#123; public Item findById(int id);&#125; 123456789101112131415161718package com.itheima.ssm.service;import com.itheima.ssm.dao.ItemMapper;import com.itheima.ssm.pojo.Item;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;@Service@Transactionalpublic class ItemServiceImpl implements ItemService &#123; @Autowired private ItemMapper itemMapper; public Item findById(int id) &#123; return itemMapper.findById(id); &#125;&#125; 第四步：创建spring配置文件applicationContext-service.xml 123456789101112131415161718192021222324252627&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; &lt;!--配置扫描器，扫描Service--&gt; &lt;context:component-scan base-package=&quot;com.itheima.ssm.service&quot;/&gt; &lt;!--事务管理器--&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; &lt;!--事物注解驱动--&gt; &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;&lt;/beans&gt; ⑤子工程maven_web构建 ​ 第一步：创建maven_web工程，注意打包方式为war ​ 第二步：配置maven_web工程的pom.xml文件 ​ UTF-8 ​ 1.8 ​ 1.8 ​ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.itheima&lt;/groupId&gt; &lt;artifactId&gt;maven_service&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;finalName&gt;maven_web&lt;/finalName&gt; &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/plugin&gt; &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.22.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt;&lt;/build&gt; ​ ​ 第三步：创建Controller 123456789101112131415161718192021222324package com.itheima.ssm.controller;import com.itheima.ssm.pojo.Item;import com.itheima.ssm.service.ItemService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;@Controller@RequestMapping(&quot;/item&quot;)public class ItemController &#123; @Autowired private ItemService itemService; @RequestMapping(&quot;/showItem/&#123;id&#125;&quot;) public String findById(@PathVariable(&quot;id&quot;) int id, Model model)&#123; Item item = itemService.findById(id); model.addAttribute(&quot;item&quot;,item); return &quot;item&quot;; &#125;&#125; ​ 第四步：创建jsp页面 ​ 第五步：配置web.xml 1234567891011121314151617181920212223&lt;!--指定Spring配置文件位置--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath*:applicationContext*.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!--配置Spring框架启动时使用的监听器--&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!--配置SpringMVC的前端控制器--&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; ​ 第六步：创建springmvc配置文件springmvc.xml 12345678910111213141516171819202122232425&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; &lt;!--配置扫描器，扫描Controller--&gt; &lt;context:component-scan base-package=&quot;com.itheima.ssm.controller&quot;/&gt; &lt;!--视图解析器--&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 项目整体结构如下： 1）maven_parent为父工程，其余工程为子工程，都继承父工程maven_parent 2）maven_parent工程将其子工程都进行了聚合 3）子工程之间存在依赖关系，比如maven_dao依赖， maven_pojo、maven_service依赖maven_dao、 maven_web依赖maven_service 5. maven私服5.1 私服说明maven仓库分为本地仓库和远程仓库，而远程仓库又分为maven中央仓库、其他远程仓库和私服（私有服务器）。其中，中央仓库是由maven官方提供的，而私服就需要我们自己搭建了。 maven私服就是公司局域网内的maven远程仓库，每个员工的电脑上安装maven软件并且连接maven私服，程序员可以将自己开发的项目打成jar并发布到私服，其它项目组成员就可以从私服下载所依赖的jar。私服还充当一个代理服务器的角色，当私服上没有jar包时会从maven中央仓库自动下载。 nexus 是一个maven仓库管理器（其实就是一个软件），nexus可以充当maven私服，同时nexus还提供强大的仓库管理、构件搜索等功能。 5.2 搭建maven私服①下载nexus https://help.sonatype.com/repomanager2/download/download-archives---repository-manager-oss ②安装nexus 将下载的压缩包进行解压，进入bin目录 打开cmd窗口并进入上面bin目录下，执行nexus.bat install命令安装服务（注意需要以管理员身份运行cmd命令） ③启动nexus 经过前面命令已经完成nexus的安装，可以通过如下两种方式启动nexus服务： 在Windows系统服务中启动nexus 在命令行执行nexus.bat start命令启动nexus ④访问nexus 启动nexus服务后，访问http://localhost:8081/nexus 点击右上角LogIn按钮，进行登录。使用默认用户名admin和密码admin123登录系统 登录成功后点击左侧菜单Repositories可以看到nexus内置的仓库列表（如下图） nexus仓库类型 通过前面的仓库列表可以看到，nexus默认内置了很多仓库，这些仓库可以划分为4种类型，每种类型的仓库用于存放特定的jar包，具体说明如下： ①hosted，宿主仓库，部署自己的jar到这个类型的仓库，包括Releases和Snapshots两部分，Releases为公司内部发布版本仓库、 Snapshots为公司内部测试版本仓库 ②proxy，代理仓库，用于代理远程的公共仓库，如maven中央仓库，用户连接私服，私服自动去中央仓库下载jar包或者插件 ③group，仓库组，用来合并多个hosted/proxy仓库，通常我们配置自己的maven连接仓库组 ④virtual(虚拟)：兼容Maven1版本的jar或者插件 nexus仓库类型与安装目录对应关系 5.3 将项目发布到maven私服maven私服是搭建在公司局域网内的maven仓库，公司内的所有开发团队都可以使用。例如技术研发团队开发了一个基础组件，就可以将这个基础组件打成jar包发布到私服，其他团队成员就可以从私服下载这个jar包到本地仓库并在项目中使用。 将项目发布到maven私服操作步骤如下： 配置maven的settings.xml文件 12345678910&lt;server&gt;&lt;id&gt;releases&lt;/id&gt;&lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin123&lt;/password&gt;&lt;/server&gt;&lt;server&gt;&lt;id&gt;snapshots&lt;/id&gt;&lt;username&gt;admin&lt;/username&gt;&lt;password&gt;admin123&lt;/password&gt;&lt;/server&gt; ​ 注意：一定要在idea工具中引入的maven的settings.xml文件中配置 配置项目的pom.xml文件 12345678&lt;distributionManagement&gt;&lt;repository&gt; &lt;id&gt;releases&lt;/id&gt; &lt;url&gt;http://localhost:8081/nexus/content/repositories/releases/&lt;/url&gt;&lt;/repository&gt;&lt;snapshotRepository&gt; &lt;id&gt;snapshots&lt;/id&gt; &lt;url&gt;http://localhost:8081/nexus/content/repositories/snapshots/&lt;/url&gt; &lt;/snapshotRepository&gt;&lt;/distributionManagement&gt; 执行mvn deploy命令 5.4 从私服下载jar到本地仓库前面我们已经完成了将本地项目打成jar包发布到maven私服，下面我们就需要从maven私服下载jar包到本地仓库。 具体操作步骤如下： 在maven的settings.xml文件中配置下载模板 12345678910111213141516171819202122232425262728&lt;profile&gt; &lt;id&gt;dev&lt;/id&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;!--仓库地址，即nexus仓库组的地址--&gt; &lt;url&gt; http://localhost:8081/nexus/content/groups/public/&lt;/url&gt; &lt;!--是否下载releases构件--&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;!--是否下载snapshots构件--&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt;&lt;pluginRepositories&gt; &lt;!-- 插件仓库，maven的运行依赖插件，也需要从私服下载插件 --&gt; &lt;pluginRepository&gt; &lt;id&gt;public&lt;/id&gt; &lt;name&gt;Public Repositories&lt;/name&gt; &lt;url&gt; http://localhost:8081/nexus/content/groups/public/&lt;/url&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt;&lt;/profile&gt; 在maven的settings.xml文件中配置激活下载模板 123&lt;activeProfiles&gt; &lt;activeProfile&gt;dev&lt;/activeProfile&gt;&lt;/activeProfiles&gt; 6. 将第三方jar安装到本地仓库和maven私服在maven工程的pom.xml文件中配置某个jar包的坐标后，如果本地的maven仓库不存在这个jar包，maven工具会自动到配置的maven私服下载，如果私服中也不存在，maven私服就会从maven中央仓库进行下载。 但是并不是所有的jar包都可以从中央仓库下载到，比如常用的Oracle数据库驱动的jar包在中央仓库就不存在。此时需要到Oracle的官网下载驱动jar包，然后将此jar包通过maven命令安装到我们本地的maven仓库或者maven私服中，这样在maven项目中就可以使用maven坐标引用到此jar包了。 6.1 将第三方jar安装到本地仓库①下载Oracle的jar包（略） ②mvn install命令进行安装 ​ mvn install:install-file -Dfile=ojdbc14-10.2.0.4.0.jar -DgroupId=com.oracle -DartifactId=ojdbc14 – ​ Dversion=10.2.0.4.0 -Dpackaging=jar ③查看本地maven仓库，确认安装是否成功 6.2 将第三方jar安装到maven私服①下载Oracle的jar包（略） ②在maven的settings.xml配置文件中配置第三方仓库的server信息 12345&lt;server&gt; &lt;id&gt;thirdparty&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin123&lt;/password&gt;&lt;/server&gt; ③执行mvn deploy命令进行安装 ​ mvn deploy:deploy-file -Dfile=ojdbc14-10.2.0.4.0.jar -DgroupId=com.oracle -DartifactId=ojdbc14 – ​ Dversion=10.2.0.4.0 -Dpackaging=jar – ​ Durl=http://localhost:8081/nexus/content/repositories/thirdparty/ -DrepositoryId=thirdparty","categories":[{"name":"Maven","slug":"Maven","permalink":"http://example.com/categories/Maven/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"http://example.com/tags/Maven/"}]},{"title":"LeetCode二叉树刷题总结","slug":"LeetCode二叉树刷题总结","date":"2021-09-04T14:32:51.511Z","updated":"2021-10-26T09:18:55.230Z","comments":true,"path":"2021/09/04/LeetCode二叉树刷题总结/","link":"","permalink":"http://example.com/2021/09/04/LeetCode%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/","excerpt":"本篇博客的思路大部分来自labuladong的算法小抄和LeetCode中相应题的题解讨论区。在此做一个总结，以便日后方便复习回顾。 在二叉树的题目中，大多数的二叉树问题的本质都是树的遍历，关于树的增删改查的操作归根结底都是在对树的遍历的基础上进行的，所以在解决二叉树问题时，树的遍历算法占据着举足轻重的地位。而二叉树的遍历又跟递归有着非常紧密的联系，可以说大部分递归的题目都跟树的遍历有关系。","text":"本篇博客的思路大部分来自labuladong的算法小抄和LeetCode中相应题的题解讨论区。在此做一个总结，以便日后方便复习回顾。 在二叉树的题目中，大多数的二叉树问题的本质都是树的遍历，关于树的增删改查的操作归根结底都是在对树的遍历的基础上进行的，所以在解决二叉树问题时，树的遍历算法占据着举足轻重的地位。而二叉树的遍历又跟递归有着非常紧密的联系，可以说大部分递归的题目都跟树的遍历有关系。 对于解决二叉树算法的设计的总路线：明确一个节点要做的事情，然后剩下的事让递归解决。 123456void traverse(TreeNode root) &#123; // root 需要做什么？在这做。 // 其他的不用 root 操心，抛给框架 traverse(root.left); traverse(root.right);&#125; 举两个简单的例子体会一下这个思路: 1. 如何把二叉树所有的节点中的值加一？ 1234567void plusOne(TreeNode root) &#123; if (root == null) return; root.val += 1; plusOne(root.left); plusOne(root.right);&#125; 2. 如何判断两棵二叉树是否完全相同？ 123456789101112boolean isSameTree(TreeNode root1, TreeNode root2) &#123; // 都为空的话，显然相同 if (root1 == null &amp;&amp; root2 == null) return true; // 一个为空，一个非空，显然不同 if (root1 == null || root2 == null) return false; // 两个都非空，但 val 不一样也不行 if (root1.val != root2.val) return false; // root1 和 root2 该比的都比完了 return isSameTree(root1.left, root2.left) &amp;&amp; isSameTree(root1.right, root2.right);&#125; 二叉搜索树（Binary Search Tree，简称 BST）是一种很常用的的二叉树。它的定义是：一个二叉树中，任意节点的值要大于等于左子树所有节点的值，且要小于等于右边子树的所有节点的值。 如下就是一个符合定义的 BST： 下面实现 BST 的基础操作：判断 BST 的合法性、增、删、查。其中“删”和“判断合法性”略微复杂。 零、判断 BST 的合法性这里是有坑的哦，我们按照刚才的思路，每个节点自己要做的事不就是比较自己和左右孩子吗？看起来应该这样写代码： 12345678boolean isValidBST(TreeNode root) &#123; if (root == null) return true; if (root.left != null &amp;&amp; root.val &lt;= root.left.val) return false; if (root.right != null &amp;&amp; root.val &gt;= root.right.val) return false; return isValidBST(root.left) &amp;&amp; isValidBST(root.right);&#125; 但是这个算法出现了错误，BST 的每个节点应该要小于右边子树的所有节点，下面这个二叉树显然不是 BST，但是我们的算法会把它判定为 BST。 我们重新看一下 BST 的定义，root 需要做的不只是和左右子节点比较，而是要整个左子树和右子树所有节点比较。怎么办，鞭长莫及啊！ 这种情况，我们可以使用辅助函数，增加函数参数列表，在参数中携带额外信息，请看正确的代码： 1234567891011boolean isValidBST(TreeNode root) &#123; return isValidBST(root, null, null);&#125;boolean isValidBST(TreeNode root, TreeNode min, TreeNode max) &#123; if (root == null) return true; if (min != null &amp;&amp; root.val &lt;= min.val) return false; if (max != null &amp;&amp; root.val &gt;= max.val) return false; return isValidBST(root.left, min, root) &amp;&amp; isValidBST(root.right, root, max);&#125; 一、在 BST 中查找一个数是否存在根据我们的指导思想，可以这样写代码： 1234567boolean isInBST(TreeNode root, int target) &#123; if (root == null) return false; if (root.val == target) return true; return isInBST(root.left, target) || isInBST(root.right, target);&#125; 考虑一点细节问题：如何充分利用信息，把 BST 这个“左小右大”的特性用上？ 很简单，其实不需要递归地搜索两边，类似二分查找思想，根据 target 和 root.val 的大小比较，就能排除一边。我们把上面的思路稍稍改动： 12345678910boolean isInBST(TreeNode root, int target) &#123; if (root == null) return false; if (root.val == target) return true; if (root.val &lt; target) return isInBST(root.right, target); if (root.val &gt; target) return isInBST(root.left, target); // root 该做的事做完了，顺带把框架也完成了，妙&#125; 于是，我们对原始框架进行改造，抽象出一套针对 BST 的遍历框架： 12345678void BST(TreeNode root, int target) &#123; if (root.val == target) // 找到目标，做点什么 if (root.val &lt; target) BST(root.right, target); if (root.val &gt; target) BST(root.left, target);&#125; 二、在 BST 中插入一个数对数据结构的操作无非遍历 + 访问，遍历就是“找”，访问就是“改”。具体到这个问题，插入一个数，就是先找到插入位置，然后进行插入操作。 上一个问题，我们总结了 BST 中的遍历框架，就是“找”的问题。直接套框架，加上“改”的操作即可。一旦涉及“改”，函数就要返回 TreeNode 类型，并且对递归调用的返回值进行接收。 1234567891011TreeNode insertIntoBST(TreeNode root, int val) &#123; // 找到空位置插入新节点 if (root == null) return new TreeNode(val); // if (root.val == val) // BST 中一般不会插入已存在元素 if (root.val &lt; val) root.right = insertIntoBST(root.right, val); if (root.val &gt; val) root.left = insertIntoBST(root.left, val); return root;&#125; 三、在 BST 中删除一个数跟插入操作类似，先“找”再“改”，先把框架写出来再说： 12345678910TreeNode deleteNode(TreeNode root, int key) &#123; if (root.val == key) &#123; // 找到啦，进行删除 &#125; else if (root.val &gt; key) &#123; root.left = deleteNode(root.left, key); &#125; else if (root.val &lt; key) &#123; root.right = deleteNode(root.right, key); &#125; return root;&#125; 找到目标节点了，比方说是节点 A，如何删除这个节点，这是难点。因为删除节点的同时不能破坏 BST 的性质。有三种情况，用图片来说明。 情况 1：A 恰好是末端节点，两个子节点都为空，那么它可以当场去世了。 12if (root.left == null &amp;&amp; root.right == null) return null; 情况 2：A 只有一个非空子节点，那么它要让这个孩子接替自己的位置。 123// 排除了情况 1 之后if (root.left == null) return root.right;if (root.right == null) return root.left; 情况 3：A 有两个子节点，麻烦了，为了不破坏 BST 的性质，A 必须找到左子树中最大的那个节点，或者右子树中最小的那个节点来接替自己。我们以第二种方式讲解。 12345678if (root.left != null &amp;&amp; root.right != null) &#123; // 找到右子树的最小节点 TreeNode minNode = getMin(root.right); // 把 root 改成 minNode root.val = minNode.val; // 转而去删除 minNode root.right = deleteNode(root.right, minNode.val);&#125; 三种情况分析完毕，填入框架，简化一下代码： 1234567891011121314151617181920212223TreeNode deleteNode(TreeNode root, int key) &#123; if (root == null) return null; if (root.val == key) &#123; // 这两个 if 把情况 1 和 2 都正确处理了 if (root.left == null) return root.right; if (root.right == null) return root.left; // 处理情况 3 TreeNode minNode = getMin(root.right); root.val = minNode.val; root.right = deleteNode(root.right, minNode.val); &#125; else if (root.val &gt; key) &#123; root.left = deleteNode(root.left, key); &#125; else if (root.val &lt; key) &#123; root.right = deleteNode(root.right, key); &#125; return root;&#125;TreeNode getMin(TreeNode node) &#123; // BST 最左边的就是最小的 while (node.left != null) node = node.left; return node;&#125; 删除操作就完成了。注意一下，这个删除操作并不完美，因为我们一般不会通过 root.val = minNode.val 修改节点内部的值来交换节点，而是通过一系列略微复杂的链表操作交换 root 和 minNode 两个节点。因为具体应用中，val 域可能会很大，修改起来很耗时，而链表操作无非改一改指针，而不会去碰内部数据。 四、最后总结通过这篇文章，你学会了如下几个技巧： 二叉树算法设计的总路线：把当前节点要做的事做好，其他的交给递归框架，不用当前节点操心。 如果当前节点会对下面的子节点有整体影响，可以通过辅助函数增长参数列表，借助参数传递信息。 在二叉树框架之上，扩展出一套 BST 遍历框架： 12345678void BST(TreeNode root, int target) &#123; if (root.val == target) // 找到目标，做点什么 if (root.val &lt; target) BST(root.right, target); if (root.val &gt; target) BST(root.left, target);&#125; 五、LeetCode相关题目100.相同的树123题目描述： 给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。 12345678910111213141516题解：//如果两个二叉树都为空，则两个二叉树相同。如果两个二叉树中有且只有一个为空，则两个二叉树一定不相同。//如果两个二叉树都不为空，那么首先判断它们的根节点的值是否相同，若不相同则两个二叉树一定不同，若相同，再分别判断两个二叉树的左子树是否相同以及右子树是否相同。这是一个递归的过程，因此可以使用深度优先搜索，递归地判断两个二叉树是否相同。 class Solution &#123; public boolean isSameTree(TreeNode p, TreeNode q) &#123; if (p == null &amp;&amp; q == null) &#123; return true; &#125; else if (p == null || q == null) &#123; return false; &#125; else if (p.val != q.val) &#123; return false; &#125; else &#123; return isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right); &#125; &#125;&#125; 101.对称二叉树123题目描述： 给定一个二叉树，检查它是否是镜像对称的。 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 123456789101112131415161718题解： //指定两个节点 p 和 q 都同时指向根节点，当 p 往左子节点遍历时 q 就往右子节点遍历，然后判断 p.val 和 q.val 是否相同，如果值不同或者 p、q 不同时为空的话则树不是镜像对称的。 class Solution &#123; public boolean isSymmetric(TreeNode root) &#123; return check(root,root); &#125; public boolean check(TreeNode p,TreeNode q)&#123; if(p == null &amp;&amp; q == null)&#123; return true; &#125; if(p == null || q == null)&#123; return false; &#125; return p.val == q.val &amp;&amp; check(p.left,q.right) &amp;&amp; check(p.right,q.left); &#125;&#125; 104.二叉树的最大深度1234567891011121314题目描述： 给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。示例：给定二叉树 [3,9,20,null,null,15,7]， 3 / \\ 9 20 / \\ 15 7返回它的最大深度 3 。 12345678910111213题解： //给定一颗二叉树的根节点求二叉树的最大深度，其最大深度 = max(左子树的深度，右子树的深度) +1 //同样，左右子树的最大深度也可以用同样的方法来求，故可以使用递归的思想来解决这道题。 class Solution &#123; public int maxDepth(TreeNode root) &#123; if(root == null)&#123; return 0; &#125; int leftDepth = maxDepth(root.left); int rightDepth = maxDepth(root.right); return Math.max(leftDepth , rightDepth) + 1; &#125;&#125; 108.将有序数组转存为搜索二叉树123456789题目描述： 给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。示例 1：输入：nums = [-10,-3,0,5,9]输出：[0,-3,9,-10,null,5]解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案： 1234567891011121314151617181920212223题解： //二叉搜索树的中序遍历是升序序列，题目给定的数组是按照升序排序的有序数组，因此可以确保数组是二叉搜索树的中序遍历序列。 //直观地看，我们可以选择中间数字作为二叉搜索树的根节点，这样分给左右子树的数字个数相同或只相差 1，可以使得树保持平衡。如果数组长度是奇数，则根节点的选择是唯一的，如果数组长度是偶数，则可以选择中间位置左边的数字作为根节点或者选择中间位置右边的数字作为根节点，选择不同的数字作为根节点则创建的平衡二叉搜索树也是不同的。 //确定平衡二叉搜索树的根节点之后，其余的数字分别位于平衡二叉搜索树的左子树和右子树中，左子树和右子树分别也是平衡二叉搜索树，因此可以通过递归的方式创建平衡二叉搜索树。 class Solution &#123; public TreeNode sortedArrayToBST(int[] nums) &#123; return helper(nums, 0, nums.length - 1); &#125; public TreeNode helper(int[] nums, int left, int right) &#123; if (left &gt; right) &#123; return null; &#125; // 总是选择中间位置左边的数字作为根节点 int mid = (left + right) / 2; TreeNode root = new TreeNode(nums[mid]); root.left = helper(nums, left, mid - 1); root.right = helper(nums, mid + 1, right); return root; &#125;&#125; 110.平衡二叉树1234567题目描述： 给定一个二叉树，判断它是否是高度平衡的二叉树。 本题中，一棵高度平衡二叉树定义为： 一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。 示例 1： 输入：root = [3,9,20,null,null,15,7] 输出：true 1234567891011121314151617181920212223题解： //这道题中的平衡二叉树的定义是：二叉树的每个节点的左右子树的高度差的绝对值不超过 11，则二叉树是平衡二叉树。根据定义，一棵二叉树是平衡二叉树，当且仅当其所有子树也都是平衡二叉树，因此可以使用递归的方式判断二叉树是不是平衡二叉树，递归的顺序可以是自顶向下或者自底向上。 //自顶向下递归，对于同一个节点，函数getHeight 会被重复调用，导致时间复杂度较高。如果使用自底向上的做法，则对于每个节点，函数getHeight 只会被调用一次。 //自底向上递归的做法类似于后序遍历，对于当前遍历到的节点,先递归地判断其左右子树是否平衡，再判断以当前节点为根的子树是否平衡。如果一棵子树是平衡的，则返回其高度（高度一定是非负整数），否则返回 -1−1。如果存在一棵子树不平衡，则整个二叉树一定不平衡。 class Solution &#123; public boolean isBalanced(TreeNode root) &#123; return getHeight(root) &gt;= 0; &#125; public int getHeight(TreeNode root)&#123; if(root == null)&#123; return 0; &#125; int leftHeight = getHeight(root.left); int rightHeight = getHeight(root.right); if(leftHeight == -1 || rightHeight == -1 || Math.abs(leftHeight-rightHeight) &gt; 1)&#123; return -1; &#125; else &#123; return Math.max(leftHeight,rightHeight)+1; &#125; &#125;&#125; 111.二叉树的最小深度123456题目描述： 给定一个二叉树，找出其最小深度。 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 说明：叶子节点是指没有子节点的节点。 输入：root = [3,9,20,null,null,15,7] 输出：2 12345678910111213141516171819题解： //解题关键是搞清楚递归结束条件 //叶子节点的定义是左孩子和右孩子都为 null 时叫做叶子节点 //当 root 节点左右孩子都为空时，返回 1 //当 root 节点左右孩子有一个为空时，返回不为空的孩子节点的深度 //当 root 节点左右孩子都不为空时，返回左右孩子较小深度的节点值class Solution &#123; public int minDepth(TreeNode root) &#123; if(root == null)&#123; return 0; &#125; if(root.left == null &amp;&amp; root.right == null)&#123; return 1; &#125; int leftDepth = minDepth(root.left); int rightDepth = minDepth(root.right); return (root.left == null || root.right == null) ? leftDepth+rightDepth+1 : Math.min(leftDepth,rightDepth)+1; &#125;&#125; 112.路径总和12345题目描述： 给你二叉树的根节点 root 和一个表示目标和的整数 targetSum ，判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。 叶子节点 是指没有子节点的节点。示例：输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22 输出：true 123456789101112131415题解： /*观察要求我们完成的函数，我们可以归纳出它的功能：询问是否存在从当前节点 root 到叶子节点的路径，满足其路径和为 sum。假定从根节点到当前节点的值之和为 val，我们可以将这个大问题转化为一个小问题：是否存在从当前节点的子节点到叶子的路径，满足其路径和为 sum - val。不难发现这满足递归的性质，若当前节点就是叶子节点，那么我们直接判断 sum 是否等于 val 即可（因为路径和已经确定，就是当前节点的值，我们只需要判断该路径和是否满足条件）。若当前节点不是叶子节点，我们只需要递归地询问它的子节点是否能满足条件即可。*/ class Solution &#123; public boolean hasPathSum(TreeNode root, int targetSum) &#123; if(root == null)&#123; return false; &#125; if(root.left == null &amp;&amp; root.right == null)&#123; return root.val == targetSum; &#125; return hasPathSum(root.left , targetSum-root.val) || hasPathSum(root.right , targetSum-root.val); &#125;&#125; 226.翻转二叉树1234567891011121314151617181920212223题目描述：翻转一棵二叉树。题解： /*我们在做二叉树题目时候，第一想到的应该是用 递归 来解决。仔细看下题目的 输入 和 输出，输出的左右子树的位置跟输入正好是相反的，于是我们可以递归的交换左右子树来完成这道题。其实就是交换一下左右节点，然后再递归的交换左节点，右节点总结出递归的两个条件如下： 终止条件：当前节点为 null 时返回 交换当前节点的左右节点，再递归的交换当前节点的左节点，递归的交换当前节点的右节点*/class Solution &#123; public TreeNode invertTree(TreeNode root) &#123; if(root == null)&#123; return null; &#125; TreeNode temp = root.left; root.left = root.right; root.right = temp; invertTree(root.left); invertTree(root.right); return root; &#125;&#125; 235.二叉搜索树的最近公共祖先12题目描述：给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 12345678910111213141516171819202122题解： /*我们从根节点开始遍历； 如果当前节点的值大于 pp 和 qq 的值，说明 pp 和 qq 应该在当前节点的左子树，因此将当前节点移动到它的左子节点； 如果当前节点的值小于 pp 和 qq 的值，说明 pp 和 qq 应该在当前节点的右子树，因此将当前节点移动到它的右子节点； 如果当前节点的值不满足上述两条要求，那么说明当前节点就是「分岔点」。此时，pp 和 qq 要么在当前节点的不同的子树中，要么其中一个就是当前节点。 可以发现，如果我们将这两个节点放在一起遍历，我们就省去了存储路径需要的空间。*/ class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; TreeNode ancient = root; while(true)&#123; if(ancient.val &gt; p.val &amp;&amp; ancient.val &gt; q.val)&#123; ancient = ancient.left; &#125; else if(ancient.val &lt; p.val &amp;&amp; ancient.val &lt; q.val)&#123; ancient = ancient.right; &#125; else &#123; break; &#125; &#125; return ancient; &#125;&#125; 404.左叶子之和123456789题目描述： 计算给定二叉树的所有左叶子之和。 3 / \\ 9 20 / \\ 15 7在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24 123456789101112131415161718192021222324题解： /* 一个节点为「左叶子」节点，当且仅当它是某个节点的左子节点，并且它是一个叶子结点。因此我们可以考虑对整棵树进行遍历，当我们遍历到节点 \\textit&#123;node&#125;node 时，如果它的左子节点是一个叶子结点，那么就将它的左子节点的值累加计入答案。 */ class Solution &#123; public int sumOfLeftLeaves(TreeNode root) &#123; return root != null ? dfs(root) : 0; &#125; public int dfs(TreeNode node)&#123; int res = 0; if(node.left != null)&#123; res += isLeafNode(node.left) ? node.left.val : dfs(node.left); &#125; if(node.right != null &amp;&amp; !isLeafNode(node.right))&#123; res += dfs(node.right); &#125; return res; &#125; public boolean isLeafNode(TreeNode node)&#123; return node.left == null &amp;&amp; node.right == null; &#125;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"Java参数及参数传递","slug":"java参数及参数传递","date":"2021-09-04T14:32:51.510Z","updated":"2021-11-02T01:03:12.297Z","comments":true,"path":"2021/09/04/java参数及参数传递/","link":"","permalink":"http://example.com/2021/09/04/java%E5%8F%82%E6%95%B0%E5%8F%8A%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/","excerpt":"今天刷牛客网 Java 专项习题的时候碰到了一道关于 Java 参数及参数传递和String类型数据作为参数传递的情况，回顾了一下知识点，现在做一下简单的总结。","text":"今天刷牛客网 Java 专项习题的时候碰到了一道关于 Java 参数及参数传递和String类型数据作为参数传递的情况，回顾了一下知识点，现在做一下简单的总结。 1. 形式参数和实际参数在程序语言设计中，参数是有形式参数和实际参数之分的，先看一下形参和实参的定义： 形式参数：是在定义函数名和函数体的时候使用的参数，目的是用来接收调用该函数时传入的参数，简称“形参”。 实际参数：在主调函数中调用一个函数时，函数名后面括号中的参数称为“实际参数”，简称“实参”。 举个例子： 12345678910111213public class Person &#123; public static void main(String[] args) &#123; Person p = new Person(); // 实际参数为“张三” p.sout(&quot;张三&quot;); &#125; public void sout(String name) &#123; // 形式参数为 name System.out.print(name); &#125; &#125; Person类中定义了一个sout方法，该方法有个String类型的参数name，该参数即为形参。在main方法中，调用了sout方法，传入了一个参数“张三”，该参数即为实参。 问题来了：实际参数是如何传入方法的呢？ 2. 值传递和引用传递参数传递的机制有两种：值传递和引用传递，先上定义： 值传递：是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。 引用传递：是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。 基本数据类型作为参数传递基本数据类型作为参数传递时都是传递值的拷贝。 即在调用方法时，将要传递的值（实参）拷贝一份传入方法，因此无论方法怎么改变传入的值都不会影响实际参数的值。 简单地说就是把实参的拷贝值赋给形参，对形参的改变不会影响实参的值。 1234567891011121314public class Test &#123; public static void main(String[] args) &#123; Test test1 = new Test(); int i = 5; System.out.println(&quot;调用前的i=&quot; + i); test1.testPassParameter(i); //传递后,testPassParameter方法中对形参i的改变不会影响这里的i System.out.println(&quot;调用后的i=&quot; + i); &#125; public void testPassParameter(int i) &#123; i = 10;//这里只是对形参的改变 System.out.println(&quot;tpp方法中的i=&quot; + i); &#125;&#125; 输出结果为： 123调用前的i=5tpp方法中的i=10调用后的i=5 对象作为参数传递以下代码中 Dog dog 的 dog 是一个指针，存储的是对象的地址。在将一个参数传入一个方法时，本质上是将对象的地址以值的方式传递到形参中。 1234567891011121314151617181920public class Dog &#123; String name; Dog(String name) &#123; this.name = name; &#125; String getName() &#123; return this.name; &#125; void setName(String name) &#123; this.name = name; &#125; String getObjectAddress() &#123; return super.toString(); &#125;&#125; 在方法中改变对象的字段值会改变原对象该字段值，因为引用的是同一个对象。 1234567891011class PassByValueExample &#123; public static void main(String[] args) &#123; Dog dog = new Dog(&quot;A&quot;); func(dog); System.out.println(dog.getName()); // B &#125; private static void func(Dog dog) &#123; dog.setName(&quot;B&quot;); &#125;&#125; 但是在方法中将指针引用了其它对象，那么此时方法里和方法外的两个指针指向了不同的对象，在一个指针改变其所指向对象的内容对另一个指针所指向的对象没有影响。 12345678910111213141516public class PassByValueExample &#123; public static void main(String[] args) &#123; Dog dog = new Dog(&quot;A&quot;); System.out.println(dog.getObjectAddress()); // Dog@4554617c func(dog); System.out.println(dog.getObjectAddress()); // Dog@4554617c System.out.println(dog.getName()); // A &#125; private static void func(Dog dog) &#123; System.out.println(dog.getObjectAddress()); // Dog@4554617c dog = new Dog(&quot;B&quot;); System.out.println(dog.getObjectAddress()); // Dog@74a14482 System.out.println(dog.getName()); // B &#125;&#125; 由此可见，在java中对象作为参数传递时，传递的是引用的地址，是把对象在内存中的地址拷贝了一份传给了参数。所以为了方便理解，可以说在java中只有值传递没有引用传递，因为引用传递归根结底也是传递地址的拷贝值。 3.String类型数据作为参数传递基本数据类型的包装类型在传递参数时其实也是“按引用传递的”，只是因为包装类型变量都是不可变量，容易误解。 String是final类型，是个特殊的类，对它的一些操作符是重载的。比如： 1234String str = &quot;hello&quot;;//等价于String str=new String(&quot;hello&quot;); String str = &quot;hello&quot;; str = str + &quot;world&quot;;//等价于str = new String(new StringBuffer(str).append(&quot;world&quot;)); 由此容易理解以下代码的输出结果： 12345678910111213public class Test &#123; public static void fun(String str, char ch[]) &#123; str = &quot;world&quot;; ch[0] = &#x27;d&#x27;; &#125; public static void main(String[] args) &#123; String str = new String(&quot;hello&quot;); char[] ch = &#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;&#125;; fun(str, ch); System.out.println(str); System.out.println(ch); &#125;&#125; 12hello dbc 方法调用时，名称相同的实参和形参并不一样，一个是main()中的str,指向存放”hello”的内存地址。一个是fun()中的str，str=”world”,相当于new String(“world”)。==String是final类型，将在堆中重新分配一个内存空间存放”world”==。ch[0]=’d’,对象的内容发生改变。 参考： Java参数传递 String数据类型","categories":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/tags/java%E5%9F%BA%E7%A1%80/"}]},{"title":"Hexo个人博客搭建","slug":"hexo个人博客搭建","date":"2021-09-04T14:32:51.508Z","updated":"2021-10-26T09:00:37.526Z","comments":true,"path":"2021/09/04/hexo个人博客搭建/","link":"","permalink":"http://example.com/2021/09/04/hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/","excerpt":"在gitee上搭建Hexo个人博客所需的环境和大致步骤(Windows系统命令，Linux和Mac命令相差不大)：1.安装git。2.安装node、hexo。3.使用git命令创建个人博客对应的blog文件夹4.在gitee注册账号，创建新仓库。5.将本地的博客提交到gitee仓库。6.使用gitee pages服务获取自己的个人博客地址，使用该网址访问自己的个人博客。","text":"在gitee上搭建Hexo个人博客所需的环境和大致步骤(Windows系统命令，Linux和Mac命令相差不大)：1.安装git。2.安装node、hexo。3.使用git命令创建个人博客对应的blog文件夹4.在gitee注册账号，创建新仓库。5.将本地的博客提交到gitee仓库。6.使用gitee pages服务获取自己的个人博客地址，使用该网址访问自己的个人博客。 1 准备工作1.1 git的下载与安装打开 [git官网]https://git-scm.com，下载git对应操作系统的版本。如果官网下载太慢，我们可以使用淘宝镜像下载：https://npm.taobao.org/mirrors/git-for-windows。安装无脑下一步即可。 1.1.1 常用的git命令(1).cd 改变目录 (2).cd.. 回退到上一个目录 (3).rm 删除一个文件 (4).mkdir 新建一个文件夹 (5).mv 移动文件 (6).reset 重新初始化终端 (7).clear 清屏 (8).history 查看命令历史 (9).exit 退出 (10).# 注释 1.1.2 git配置12git config --global --list 查看当前用户配置git config --system --list 查看系统config 1.1.3 设置用户名与邮箱12git config --global user.name &quot;yourUsername&quot; #名称git config --global user.email yourEmail #邮箱 1.2 node和hexo的下载安装直接打开[node官网]https://nodejs.org/en/下载对应的node版本安装即可。 123456node -v #查看node版本npm -v #查看npm版本npm install -g cnpm --registry=http://registry.npm.taobao.org #安装淘宝的cnpm 管理器cnpm -v #查看cnpm版本cnpm install -g hexo-cli #安装hexo框架hexo -v #查看hexo版本 2.开始创建自己的个人博客2.1 创建blog本地文件夹首先，选择一个想要创建blog文件夹的地方然后右键—&gt;选择Git Bash Here打开git窗口。 123456mkdir blog #创建blog目录cd blog #进入blog目录sudo hexo init #生成博客 初始化博客hexo s #启动本地博客服务http://localhost:4000/ #本地访问地址hexo g #生成 打开访问地址能看到hexo的博客界面，说明准备工作已经成功了，就可以进行接下来将博客搭建到gitee上的工作了。 2.2将博客部署到gitee上先注册登录一个gitee账号，新建一个仓库。 此处的路径和仓库名称必须与账户名一致，否则博客无法正常显示。 创建成功后会有一个地址，复制下来。 其中repo的值就是刚才复制的地址。执行下列git命令： 1cnpm install --save hexo-deployer-git #在blog目录下安装git部署插件 而后打开blog文件夹中的配置文件_config.yml，拉到最下面，进行如图所示的配置： 最后执行： 1hexo d -g #将本地博客部署到gitee上 大功告成，最后使用gittee pages服务生成个人博客网址。 选择gitee，启动就能生成一个网址。 需要注意的是每次更新了博客内容以后都需要重新执行 1hexo d -g #每次更新后都要重新上传部署一下 然后在gitee pages服务页面点击更新。","categories":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]}],"categories":[{"name":"java 集合","slug":"java-集合","permalink":"http://example.com/categories/java-%E9%9B%86%E5%90%88/"},{"name":"计算机网","slug":"计算机网","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"java基础","slug":"java基础","permalink":"http://example.com/categories/java%E5%9F%BA%E7%A1%80/"},{"name":"Spring","slug":"Spring","permalink":"http://example.com/categories/Spring/"},{"name":"Mybatis","slug":"Mybatis","permalink":"http://example.com/categories/Mybatis/"},{"name":"Maven","slug":"Maven","permalink":"http://example.com/categories/Maven/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/categories/hexo/"}],"tags":[{"name":"java 集合","slug":"java-集合","permalink":"http://example.com/tags/java-%E9%9B%86%E5%90%88/"},{"name":"计算机网","slug":"计算机网","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"java基础","slug":"java基础","permalink":"http://example.com/tags/java%E5%9F%BA%E7%A1%80/"},{"name":"Spring","slug":"Spring","permalink":"http://example.com/tags/Spring/"},{"name":"Mybatis","slug":"Mybatis","permalink":"http://example.com/tags/Mybatis/"},{"name":"Maven","slug":"Maven","permalink":"http://example.com/tags/Maven/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]}